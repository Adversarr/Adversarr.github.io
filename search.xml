<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>15-769: Lecture 1-4: Shape Repersentation, Time Integration, Mass Spring system, Dirichlet bc.</title>
      <link href="/2023/12/14/ipc/chap1234/"/>
      <url>/2023/12/14/ipc/chap1234/</url>
      
        <content type="html"><![CDATA[<h1id="lecture-1-4-shape-repersentation-time-integration-mass-spring-system-dirichlet-bc.">15-769:Lecture 1-4: Shape Repersentation, Time Integration, Mass Spring system,Dirichlet bc.</h1><h2id="从零开始的-15-769-physically-based-animation-of-solids-and-fluids">从零开始的15-769: Physically-based Animation of Solids and Fluids</h2><p><a href="https://www.cs.cmu.edu/~minchenl/">Minchen Li</a> 在 CMU开设了 <a href="https://www.cs.cmu.edu/~15769-f23/">15-769</a>课程，里面用 Python 实现了一个基本的<ahref="https://github.com/liminchen/solid-sim-tutorial/tree/main">带碰撞的固体求解算法</a>，算法实现了20 年的 <ahref="https://dl.acm.org/doi/abs/10.1145/3386569.3392425">IPC</a>的基本功能，算法的本质是优化中广泛使用的内点法。</p><p>上面这一段提到的 Python 代码是开源在 Github 的，用了 PyGame进行可视化，整体上是一个二维的框架。为了更加深入了解这个算法，也是为了完善自己写的一个<ahref="https://github.com/adversarr/axes">计算框架</a>，考虑用C++移植这个算法，并且实现到三维。</p><h2 id="lecture-1-shape-representation">Lecture 1: ShapeRepresentation</h2><p>Discrete Representation of Space and Time.</p><p>第一节课主要是提到了一些表示几何物体的方式：</p><h3 id="sdfsigned-distance-function">SDF：Signed Distance Function</h3><p>设有几何物体 <span class="math inline">\(\Omega\)</span>，表面为<span class="math inline">\(\partial\Omega\)</span>，我们可以定义如下的带符号距离：</p><p><span class="math display">\[f(x) = \begin{cases}  -d &amp; x \in \bar\Omega\\  d&amp;\end{cases}\]</span></p><p>其中的 <span class="math inline">\(d = \min_{y\in \bar\Omega} \| x -y\|\)</span></p><p>反过来，给定 <span class="math inline">\(f(x)\)</span>也确定了这样的几何体 <span class="math inline">\(\Omega\)</span>。</p><p>问题是，如何给出 <span class="math inline">\(f(x)\)</span>的表达式呢？一类是简单的情况，例如半径为 <spanclass="math inline">\(r\)</span>，球心为 <spanclass="math inline">\(c\)</span> 的球，我们可以写出如下的：</p><p><span class="math display">\[ f(x) = \| x - c \| - r \]</span></p><p>这样有解析表达的几何体是很常见的，例如：</p><ol type="1"><li>半平面</li><li>包围盒</li><li>…</li></ol><p>但总体上，有解析表达的这些物体还是相对很简单的。这里的 Notes里给出了另一种新的可能，即用 Deep Learning 来表达 SDF（Park et al 2019,DeepSDF）。</p><p>当然也可以用离散的网格来存储格点处的 SDF值来描述，这样的网格可以是均匀且稠密的，也可以是 VDB之类的稀疏结构。</p><p>Remark：</p><ol type="1"><li>解析表达：准确、高校，但是形状是有限的，并且形状是不可变的</li><li>DL/NN：能更好嵌入到 AI 的任务中，还没有在 solid-simulation中见到</li><li>网格：对于形变更容易求解，但存储和计算成本搞。（类似 Eulerian视角的物理场描述）</li></ol><p>Note: All sdf are not often used for deformable solids (need bothefficient representation of complex shapes).</p><h3 id="points-and-particles.">Points, and particles.</h3><p>点云，例如表面重建。</p><p>SPH、MPM 方法，也可以一定程度上描述可变形体。</p><ul><li>优点：破碎、拓扑变化处理简单</li><li>缺点：为了较高的精度，通常需要很多的点来描述。</li></ul><h3 id="mesh">Mesh</h3><p>Points conneted by elements. -&gt; 顶点之间存在拓扑。</p><ul><li><p>FEM</p></li><li><p>Mass spring</p></li><li><p>优点：如果 mesh 的质量高，那么解是比较精确的</p></li><li><p>缺点：拓扑变化后，涉及到 Remesh 问题。</p></li></ul><h3 id="hybrid---mpm">Hybrid - MPM</h3><p>Particles on a background uniform grid.</p><ul><li>优点：破碎、相比 particle 更加准确。</li><li>缺点：仍然需要比较多的 particle，而且需要“好”的分布（更均匀）</li></ul><h3 id="time-discretization">Time Discretization</h3><p>这一部分没啥好说的，也不展开提，总体的形式是：</p><p><span class="math display">\[ F = M a \]</span></p><p>这里的 <span class="math inline">\(M\)</span>是质量矩阵。按通常的习惯：</p><p><span class="math display">\[F = \begin{bmatrix}  F_{1x}\\  F_{1y}\\  F_{1z}\\  \vdots\\  F_{nx}\\  F_{ny}\\  F_{nz}\end{bmatrix}\]</span></p><p>对 <span class="math inline">\(a\)</span> 也是类似的存储。</p><p>时间上的离散实际上很简单，只有一种方法，就是：</p><p><span class="math display">\[ t\_{i+1} = t_i + \Delta t \]</span></p><p>这样的划分。</p><h2 id="lecture-2-time-integration">Lecture 2: Time Integration</h2><p>这里我们假设读者已经知道基本的原理。</p><p>我们始终使用隐格式，因为通常认为隐格式能有更好的数值稳定性。</p><p><span class="math display">\[\begin{cases}    x^{n+1} = x^n + \Delta t v^{n+1}\\    v^{n+1} = v^n + \Delta t M^{-1} f^{n+1}\end{cases}\]</span></p><p>我们消除 <spanclass="math inline">\(v^{n+1}\)</span>，那么我们需要求解的是如下关于<span class="math inline">\(x^{n+1}\)</span> 的非线性方程组：</p><p><span class="math display">\[\frac{1}{\Delta t^2}M(x^{n+1} - (x^n + \Delta t v^n)) - f(x^{n+1}) = 0\]</span></p><p>继续之前我们指出，也有很多其他的数值格式，但为了方便，我们先只考虑这个格式。</p><p>通常我们还只考虑保守力的情况，也就是 <spanclass="math inline">\(\exists E, f(x) = -\nabla_xE(x)\)</span>，那整个问题实际上可以考虑为一个最优化问题（变分问题）</p><p><span class="math display">\[\min_{x^{n+1}} \Phi(x^{n+1}) = \frac{1}{\Delta t^2} \| x^{n+1} - y\|_M^2+ E(x^{n+1})\]</span></p><p>对于这个问题，我们可以直接利用结合如下技术的求解器进行计算：</p><ol type="1"><li>Newton 法 – 二阶方法</li><li>BackTracking Line-search</li></ol><p>其中，当我们拿到 Newton 法所需 Hessian矩阵时，需要消除其负特征值来保证下降方向的正确。</p><h2 id="lecture-3-mass-spring">Lecture 3: Mass Spring</h2><p>我们上面并没有考虑和弹性相关的内容，我们现在考虑最简单的一种情况，就是弹簧质点模型。</p><p>这里定义的 Potential 为</p><p><span class="math display">\[P_e (x) = l^2 \frac{1}{2} k \left( \frac{\|x_1 - x_2\|^2_2}{l^2} -1\right) ^ 2\]</span></p><p>它和 Hooke’s Law 不是完全相同的。</p><figure><img src="./media/image-20231122200000518.png"alt="image-20231122200000518" /><figcaption aria-hidden="true">image-20231122200000518</figcaption></figure><p>对于它的梯度、Hessian 矩阵求解为：</p><figure><img src="./media//image-20231122200046716.png"alt="image-20231122200046716" /><figcaption aria-hidden="true">image-20231122200046716</figcaption></figure><p>我们还需要做的是将这样的局部矩阵装填到全局。</p><h3 id="inertia-energy">Inertia Energy</h3><p>其实这部分很简单，就是动能。</p><figure><img src="./media//image-20231122200322315.png"alt="image-20231122200322315" /><figcaption aria-hidden="true">image-20231122200322315</figcaption></figure><p>最终将矩阵装填有如下的代码，Hessian 的表示选择的也是 NNZ 表的形式</p><figure><img src="./media//image-20231122200442798.png"alt="image-20231122200442798" /><figcaption aria-hidden="true">image-20231122200442798</figcaption></figure><p>时间积分代码：</p><figure><img src="./media//image-20231122200524605.png"alt="image-20231122200524605" /><figcaption aria-hidden="true">image-20231122200524605</figcaption></figure><h2 id="dirichlet-bc">Dirichlet BC</h2><p>我们可以进行后处理。</p><p>对于这种情况，我们只需要将 Hessian 中</p><ul><li><span class="math inline">\(row = col\)</span> 且为边界点的设为<span class="math inline">\(1\)</span></li><li><span class="math inline">\(row \ne col\)</span>但其中之一是边界点的设为 0</li></ul><p>Gradient 中：</p><ul><li><span class="math inline">\(row\)</span> 为边界点的设为 <spanclass="math inline">\(0\)</span></li></ul><p>即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>15-769: Lecture 5: Normal Contact with Distance Barrier</title>
      <link href="/2023/12/14/ipc/chap5/"/>
      <url>/2023/12/14/ipc/chap5/</url>
      
        <content type="html"><![CDATA[<h1 id="lecture-5-normal-contact-with-distance-barrier">15-769: Lecture5: Normal Contact with Distance Barrier</h1><blockquote><p>没有碰撞的固体是没有灵魂的</p><p>没有摩擦的碰撞是没有灵魂的</p><p>—— 蒋陈凡夫《Variational Contact》</p></blockquote><p>在上一篇中，我们主要提到了如下几点：</p><ol type="1"><li>物体的表示，我们后面主要用的是拉格朗日视角的描述，最最主要的是三角网格；</li><li>各类的Energy：Inertia（惯性 or 动能），Gravity，Spring；</li><li>Time Integration，特别是 Implicit、Optimize-based TimeIntegration，将整个时间积分变为优化问题；</li></ol><p>这次我们来看看 IPC中最重要的一个部分：<strong>碰撞处理</strong>。</p><p>碰撞处理实际上还有很多方面的问题：</p><ol type="1"><li>碰撞检测，最难的是连续碰撞检测，也就是CCD</li><li>碰撞响应，在检测到碰撞后，正确处理碰撞</li></ol><p>IPC解决的是碰撞响应，它观察到：</p><blockquote><p>物体没有碰撞 <span class="math inline">\(\iff\)</span>物体的运动路径，没有<strong>几何相交</strong></p></blockquote><p>它的核心思想是：</p><blockquote><p>定义基于几何体距离的Log-Barrier，添加到原本的优化函数中，做内点法。</p></blockquote><p>其实如果是了解后续几篇文章的读者不难看出，有一些文章是针对如何实现这样的barrier，例如：</p><ul><li>(JCP21) BFEMP：MPM-FEM</li><li>(SIG 23) A Contact Proxy Splitting Method for Lagrangian Solid-FluidCoupling：引入SPH流体</li></ul><figure><img src="./media//image-20231129201132391.png" alt="BFEMP" /><figcaption aria-hidden="true">BFEMP</figcaption></figure><figure><img src="./media//image-20231129201631234.png"alt="A Contact Proxy Splitting Method for Lagrangian Solid-Fluid Coupling" /><figcaption aria-hidden="true">A Contact Proxy Splitting Method forLagrangian Solid-Fluid Coupling</figcaption></figure><h2 id="formulation">Formulation</h2><p>Inequality constraints: <span class="math display">\[\forall k\quad d_k(x) \ge 0\]</span> 这里的 <span class="math inline">\(k\)</span>是任何一对不同的点。<span class="math inline">\(d_k\)</span>实际上是带符号的距离，之前我们在SDF提到过。例如，对于高度为<spanclass="math inline">\(0\)</span>的水平地面，我们可以定义（<spanclass="math inline">\(-y\)</span> 为重力方向）： <spanclass="math display">\[d(\bold{x}) = y - 0\]</span> 在后面的课程中，<spanclass="math inline">\(d\)</span>也可以是无符号的距离，例如空间中两个不同的点的欧式距离。</p><p>我们首先考虑解的性质，Recap 之前的能量定义： <spanclass="math display">\[E(x) = \frac{1}{2 h^2} \| x - y \| _M^2 + P(x)\]</span> 最小化问题为： <span class="math display">\[\min E(x) \quad \mathrm{s.t.} A x = b,d_k(x) \ge 0\quad  \forall k\]</span> 其中的 <span class="math inline">\(A\)</span>表明了系统的Dirichlet边界。</p><p>写出拉格朗日函数 <span class="math display">\[\mathcal L = E(x) - \lambda&#39; (Ax - b) + \sum_k \gamma_k d_k(x)\]</span> 然后对 <span class="math inline">\(x\)</span> 求梯度，应用KKT<span class="math display">\[\nabla E(x) - A&#39; \lambda - \sum_k \gamma_k \nabla d_k(x) = 0\]</span> 外加几个条件：</p><ol type="1"><li>原始可行性：<span class="math inline">\(Ax = b, d_k(x) \ge0\)</span></li><li>对偶可行性：<span class="math inline">\(\gamma_k \ge 0\)</span></li><li>互补松弛性：<span class="math inline">\(\gamma_k d_k(x) =0\)</span>，这里因为<span class="math inline">\(\gamma,d\)</span>都是非负的所以每一项都是 <spanclass="math inline">\(0\)</span></li></ol><p>在PPT中，提到了这几个性质给出的力学特征：</p><ul><li>原始可行性 <span class="math inline">\(\implies\)</span>无穿透条件</li><li>对偶可行性 <span class="math inline">\(\implies\)</span>支持力不能指向墙内部</li><li>稳定性条件 <span class="math inline">\(\implies\)</span>受力平衡</li><li>互补松弛性 <span class="math inline">\(\implies\)</span>支持力只出现在出现碰撞的地方</li></ul><figure><img src="./media//image-20231129203725204.png" alt="KKT" /><figcaption aria-hidden="true">KKT</figcaption></figure><p>之前也有针对这样的问题的求解方法：</p><ol type="1"><li>Penalty - 惩罚方法，转化到无约束优化 ⇒不保证原始可行性，即不保证无穿透</li><li>Active set - 转化到等式优化 ⇒ 不保证收敛</li><li>Primal Dual-交替迭代 <span class="math inline">\(x, \gamma\)</span>⇒ 收敛速度慢</li></ol><p>我们的方法是Barrier method，它由如下的特点</p><ol type="1"><li>转化到无约束优化问题</li><li>保证收敛、保证原始可行性、保证收敛速度</li></ol><blockquote><p>那么牺牲的是什么呢？后面再提。</p></blockquote><p>有一些其他方法失败的例子，例如：</p><ol type="1"><li>出现穿透（Interpenetration）</li><li>数值不稳定</li></ol><figure><img src="./media//image-20231129205902576.png" alt="SQP" /><figcaption aria-hidden="true">SQP</figcaption></figure><h2 id="barrier-method">Barrier Method</h2><blockquote><p>Convex Optimization(Stephen Boyd)</p></blockquote><p>在这里我们先考虑最简单的情况，即墙面、地面等静止物体和一个可运动的物体的碰撞。我们要处理的碰撞实际上就是：<span class="math display">\[d_{k} \ge 0\]</span> 内点法的形式是，对于优化问题： <span class="math display">\[\begin{aligned}    \min \quad &amp;f_0(x)\\    \text{s.t.}\quad &amp;f_i (x) \le 0, i = 1\dots m\\    &amp; Ax = b\end{aligned}\]</span> 转化为不含不等式约束，但含有指示函数<spanclass="math inline">\(I_-\)</span>的形式： <span class="math display">\[\begin{aligned}    \min \quad &amp;f_0(x) + \sum_i I_-(f_i(x)) \\    \text{s.t.}\quad    &amp; Ax = b\end{aligned}\]</span> 其中的 <span class="math display">\[I_-(x) = \begin{cases}    0 &amp; u \le 0\\ \infty &amp; u &gt; 0\end{cases}\]</span>它保证了，如果可行域非空，那么一定目标函数的最优值一定不是<spanclass="math inline">\(\infty\)</span>，从而保证不等式约束满足。</p><p>实际计算中，<span class="math inline">\(I_-\)</span>通常可以通过Log函数近似。</p><figure><img src="./media//image-20231130102802785.png" alt="CVX Book" /><figcaption aria-hidden="true">CVX Book</figcaption></figure><p>很显然的是，引入这样的Log-Barrier函数会使得最终求解得到的结果不完全是原问题的最优解，随着Log-Barrier对<spanclass="math inline">\(I_-\)</span>的逼近程度提高，结果会越来越逼近最优解。例如如下的线性规划问题。</p><figure><img src="./media//image-20231130103323725.png" alt="LP" /><figcaption aria-hidden="true">LP</figcaption></figure><p>在Convex Optimization的567页，就有关于内点法的力学解释：</p><blockquote><p>We can give a simple mechanics interpretation of the central path interms of potential forces acting on a particle in the strictly feasibleset C. For simplicity we assume that there are no equalityconstraints.</p><p>We associate with each constraint the force <spanclass="math inline">\(F_i(x) = -\nabla (-\log (-f_i(x)))\)</span>,acting on the particle when it is at position <spanclass="math inline">\(x\)</span>. The potential associated with thetotal force field generated by the constraints is the logarithmicbarrier <span class="math inline">\(\phi\)</span>. As the particle movestoward the boundary of the feasible set, it is strongly repelled by theforces generated by the constraints.</p><p>…</p></blockquote><p>总结来说，描述了两件事情：</p><ol type="1"><li>Log-Barrier实际上是添加了边界对粒子的一个势能，这个势能在粒子充分靠近边界时趋于<spanclass="math inline">\(+\infty\)</span>，从而产生充分大的作用力将粒子推离边界；</li><li>另一方面，随着Log-Barrier不断逼近 <spanclass="math inline">\(I_-\)</span>，边界产生的力场在更多的区域上趋零，在边界处越来越逼近了<spanclass="math inline">\(I_-\)</span>，那么粒子的平衡位置，也就是求解结果随着这个逼近过程越来越靠近最优解</li></ol><figure><img src="./media//image-20231130104340511.png" alt="Force Field" /><figcaption aria-hidden="true">Force Field</figcaption></figure><p>好吧，让我们回到这门课的内容，这里我们定义的Log-Barrier是不太一样的，因为我们的不等式约束是非常多的，假设我们的场景中有<span class="math inline">\(N\)</span>个几何体（点、线、面），考虑它们之间不相互穿透带来的不等式约束，那么很可能产生的不等式数量是<spanclass="math inline">\(O(N^2)\)</span>量级的，一个较为简单的模型，例如一个四面体就包含了<span class="math inline">\(N = 4 + 6 + 4 = 14\)</span>个这样的元素，<span class="math inline">\(N\)</span>的量级是很大的。</p><p>因此，在这里采取的做法是，将Log-Barrier在一定的范围外直接置零，这里的范围选作<span class="math inline">\(\hat d\)</span></p><figure><img src="./media//image-20231130105145925.png"alt="Contact Potential" /><figcaption aria-hidden="true">Contact Potential</figcaption></figure><p>但是有一点需要注意的是，这里的 <span class="math inline">\(b\)</span>的定义实际上并不是IPC原文的定义：</p><figure><img src="./media//image-20231130105332928.png"alt="Incremental Potential Contact" /><figcaption aria-hidden="true">Incremental PotentialContact</figcaption></figure><p>其主要的区别在于，这个函数在 <span class="math inline">\(\hatd\)</span> 处是否是 <span class="math inline">\(C^2\)</span>的。</p><p>这样一番操作是否理论上合理呢，PPT给出了答案：</p><figure><img src="./media//image-20231130105519027.png"alt="KKT-Barrier Method" /><figcaption aria-hidden="true">KKT-Barrier Method</figcaption></figure><ol type="1"><li>原始可行性 - Barrier函数保证</li><li>对偶可行性 - Barrier 函数保证</li><li>稳定性 -被迭代终止条件保证，这里说的Newton实际上可以换做任何一个求解器</li><li>互补松弛性 - 降低 <span class="math inline">\(\hat d\)</span>可以提升精度</li></ol><h2 id="实现">实现</h2><p>一个问题：下降方向 <span class="math inline">\(p = -H^{-1} g\)</span>并不能保证原始可行性，即无穿透条件。我们可以做的一个方法是：</p><ol type="1"><li>搜索 <span class="math inline">\(x \tox+p\)</span>上，产生碰撞的最小时间 <span class="math inline">\(t_0 \in(0, 1]\)</span>（这个过程实际上就是CCD）</li><li>将线搜索的初始步长设置为 <span class="math inline">\(\alpha =\min\{1, t_0\}\)</span>，实际为了避免距离直接变为 <spanclass="math inline">\(0\)</span>，设置为 <spanclass="math inline">\(\alpha = \min\{1, 0.9 t_0\}\)</span></li></ol><figure><img src="./media//image-20231130110035585.png"alt="image-20231130110035585" /><figcaption aria-hidden="true">image-20231130110035585</figcaption></figure><p>最终算法：</p><figure><img src="./media//image-20231130110110450.png"alt="Barrier Aware Newton Method" /><figcaption aria-hidden="true">Barrier Aware Newton Method</figcaption></figure><h2 id="remarks">Remarks</h2><p>几点说明，首先是CCD是必须的，我们找的是路径上不发生穿透的点：</p><figure><img src="./media//image-20231130110420103.png" alt="CCD" /><figcaption aria-hidden="true">CCD</figcaption></figure><p>第二点，也是我最近比较关注的点，就是如果不是拉格朗日视角的物体表达怎么办？</p><ol type="1"><li>欧拉网格的流体，实际上固定网格点的数据</li><li>SDF表达的数据</li></ol><figure><img src="./media//image-20231130111609484.png" alt="PPT" /><figcaption aria-hidden="true">PPT</figcaption></figure><p>这里带来的一个问题是CutCell，用线性插值带来的通常是不精确、不光滑的物体边界。这里也提供了可能的解决方案：</p><ol type="1"><li>高阶的B-样条，解决光滑性</li><li>始终使用同一种插值方法</li></ol><figure><img src="./media//image-20231130111334411.png"alt="体积云（Multi-Threading in OpenVDB SIGGRAPH Course 2023）" /><figcaption aria-hidden="true">体积云（Multi-Threading in OpenVDBSIGGRAPH Course 2023）</figcaption></figure><h3 id="简单提一下代码实现">简单提一下代码实现。</h3><p>存在的问题：</p><ol type="1"><li>能量的value、grad、hessian暂时写头文件了，后面可能还得改改</li><li>实现部分没啥注释</li><li>没做Project Newton，假定所有的Hessian正定，收敛会慢一点</li></ol><p>主要代码：</p><ol type="1"><li>求解器：<ahref="https://github.com/Adversarr/axes/blob/main/axes/source/physics/solid_sim/solver.cpp">solver.cpp</a></li><li>相关能量的实现：<ahref="https://github.com/Adversarr/axes/tree/main/axes/include/axes/physics/solid_sim">solid_sim</a></li><li>具体的可执行程序：<ahref="https://github.com/Adversarr/axes/tree/main/examples/solidsim-spring">solidsim-spring</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Computer Aided Geometry Design</title>
      <link href="/2023/11/09/geometry/CAGD/"/>
      <url>/2023/11/09/geometry/CAGD/</url>
      
        <content type="html"><![CDATA[<h1 id="cagd">CAGD</h1><h2 id="考试内容">考试内容</h2><ul><li>平时作业：0.6；期末考试：0.4</li></ul><p>Bezier Curve:</p><ul><li>Bernstein Basis, Properties</li><li>De Casteljau</li><li>Other properties.</li><li>升阶和细分</li></ul><p>Bezier spline：</p><ul><li>连续性</li><li>参数化</li></ul><p>B样条：</p><ul><li>定义</li><li>deBoor</li><li>三次等距B样条</li><li>性质</li></ul><p>极形式、开花</p><p>有理曲线： - 齐次表达 - 权系数的意义 - 圆弧如何表达</p><p>张量积曲面</p><p>Bezier曲面片：重心坐标</p><p>细分 - 重心坐标</p><p>隐式曲面</p><p>其他：插值逼近、微分几何</p><p>作业！</p><ol type="1"><li>NURBS是什么？</li><li>控制点、参数、样条的阶数</li></ol><h2 id="lecture-01---插值与逼近">Lecture 01 - 插值与逼近</h2><p>一般形式： <span class="math display">\[\forall i= 1 \dots n, \sum \lambda_j b_j (x_i) = y_i\]</span> 矩阵： <span class="math display">\[[b_j(x_i)] \Lambda = Y\]</span></p><h3 id="多项式插值">多项式插值</h3><p>计算：</p><ul><li><span class="math inline">\(b_j(x) = x^{j-1}\)</span></li><li>代入后，得到的 <span class="math inline">\(B = [b_j(x_i)]\)</span>是Vandermonde矩阵</li></ul><p>这个基存在的问题：</p><ol type="1"><li>矩阵稠密</li><li>容易产生病态矩阵 ⇒ 条件数</li></ol><p>解决方法：</p><ol type="1"><li>从条件数：使用正交多项式基（Gram-Schmidt正交化）</li><li>避免求解方程组：使用拉格朗日插值方法</li></ol><p><span class="math display">\[P(x) = \sum_i y_i l_i\]</span></p><p>其中的<span class="math inline">\(l_i(x_j)=  \delta_{ij}\)</span></p><p>多项式插值的结果：</p><ol type="1"><li>Runge现象：高插值点数导致震荡。</li><li>不稳定</li></ol><h3 id="逼近">逼近</h3><p>多项式逼近：</p><ol type="1"><li>Weierstrass定理</li><li>Bernstein多项式</li></ol><p>最小二乘逼近： <span class="math display">\[M = (b_j(x_i)) \implies \text{min} \| M \Lambda -Y\|\]</span> 法方程： <span class="math display">\[M&#39;M \Lambda = M&#39;Y\]</span></p><h2 id="lec2-bezier-curves">Lec2 Bezier Curves</h2><p>Reason:</p><p>幂函数基缺少几何含义（我们希望通过控制点控制曲线）</p><figure><img src="./CAGD/image-20231217132229236.png"alt="image-20231217132229236" /><figcaption aria-hidden="true">image-20231217132229236</figcaption></figure><h3 id="de-casteljau-algorithm">De Casteljau Algorithm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Bezier</span>(<span class="params">k, t</span>):</span><br><span class="line"><span class="keyword">return</span> reduce(k, <span class="keyword">lambda</span> a, b: (<span class="number">1</span> - t) * a + t * b)</span><br></pre></td></tr></table></figure><figure><img src="./CAGD//image-20231217132524365.png"alt="image-20231217132524365" /><figcaption aria-hidden="true">image-20231217132524365</figcaption></figure><h3 id="properties.">Properties.</h3><ol type="1"><li>凸包性质：生成的曲线一定在控制点的凸包内</li><li>Variationdiminishing：任何的直线与Bezier曲线的相交次数不多于与控制曲线的相交次数</li><li>Global + pseudo-local：控制点的影响几乎是局部的（在局部最大）</li><li>Affine Invariance</li><li>Symmetry：<code>bezier(rev(k), rev(t)) == bezier(k, t)</code></li><li>Linear Precision</li></ol><h3 id="polynomial-description">Polynomial description</h3><p><span class="math display">\[x(t) = \sum_{i = 0}^n B_i^n(t) b_i\]</span></p><p>我们希望的性质：</p><ol type="1"><li>smooth basis functions</li><li>local control.</li><li>affine invariance</li><li>Convex Hull Property.</li></ol><p>主要讨论后两个</p><p><strong>Affine invariance</strong></p><p>线性不变（与线性变换和交换）：这是自然成立的，由基函数是线性组合给出</p><p>平移不变：这需要我们的基函数是Partition of Unity的，即对于所有的<span class="math inline">\(t, \sum B= 1\)</span></p><p><strong>Convex Hull Property</strong></p><p>所有的系数都是正数。</p><h3 id="bernstein-basis">Bernstein Basis</h3><p><span class="math display">\[B_i^n (t) = C_n^i t^i (1-t)^{n-i}\]</span> Properties:</p><ol type="1"><li>Affine invariance.</li><li>Convex hull.</li><li>Smoothness -&gt; Ok!</li><li>Local control: 全局基函数，但有一定的局部性。</li></ol><p>Other Properties.</p><p><em>Recursive computation</em>:</p><p><span class="math display">\[ B_i^n(t) := (1-t) B_i^{n-1} (t) + tB_{i-1}^{n-1}(1-t).\]</span></p><p>如果取到边界，那么：</p><p><span class="math display">\[ B_0^0(t) = 1, B_i^n(t) = 0 (\text{if i}\ne 0, ..., n) \]</span></p><p><em>Symmetry</em>:</p><p><span class="math display">\[ B_i^n = B_{n-i} \]</span></p><p><em>Non-negativity</em>:</p><p><span class="math display">\[ B_i^n \ge 0 \quad \forall t \in [0, 1]\]</span></p><h3 id="degree-elevation">Degree elevation</h3><p>输入：<span class="math inline">\(n+1\)</span>个控制点，<spanclass="math inline">\(n\)</span> 次 Bernstein 多项式。</p><p>输出：<span class="math inline">\(n+2\)</span> 个控制点，<spanclass="math inline">\(n+1\)</span> 次 Bernstein 多项式。</p><p>Solution:</p><p>$ b_0 = b_0, b_1 = b_1, b_j = b_{j-1} + (1- j{n+1}) b_j $</p><p>Use following to prove:</p><p><span class="math display">\[ f(t) = (1 - t) f(t) + t f(t) = \sum(1-t + t) B_i^n b_i = ... \]</span></p><h3 id="bezier-curves---subdivision">Bezier Curves - Subdivision</h3><p>Input: <span class="math inline">\(n\)</span> 次 Bezier Curve</p><p>Output: 2 个 <span class="math inline">\(n\)</span> 次 BezierCurve</p><p>如果在 <span class="math inline">\(t\)</span>处进行分割，那么，选取de Casteljau算法构成的三角形，两边的顶点作为输出。</p><h2 id="lec03---matrix-representations.">Lec03 - Matrixrepresentations.</h2><p>Homogeneous Coordinates:</p><ol type="1"><li>Transformations -&gt; Affine Transform.</li></ol><h3 id="bezier-curves">Bezier Curves</h3><p>Cubic Bezier:</p><p><span class="math display">\[ f(t) = P_0 B_0 + P_1 B_1 + P_2 B_2 +P_3 B_3 \]</span></p><p>Matrix form:</p><p><span class="math display">\[ f(t) = \begin{bmatrix}t^3 &amp; t^2 &amp; t &amp; 1\end{bmatrix} \begin{vmatrix}-1 &amp; 3 &amp; -3 &amp; 1\\3 &amp; -6 &amp; 3 &amp; 0\\-3 &amp; 3 &amp; 0 &amp; 0\\1 &amp; 0 &amp; 0 &amp; 0\end{vmatrix} \begin{bmatrix}P_{0}\\ P_1 \\ P_{2} \\ P_{3}\end{bmatrix}\]</span></p><h2 id="differential-geometry">Differential Geometry</h2><h3 id="parametric-curves">Parametric Curves</h3><p>Parameterization of class <span class="math inline">\(C^k\)</span> ofa curve in <span class="math inline">\(\mathbb R^n\)</span> is a smoothstep <span class="math inline">\(c: I=[a,b]\to \mathbb{R}^n\)</span>where <span class="math inline">\(c\)</span> is <spanclass="math inline">\(C^k\)</span>.</p><p><strong>Velocity</strong> vector: <spanclass="math inline">\(c&#39;(t)\)</span></p><ul><li><span class="math inline">\(c&#39;\)</span>: Direction ofmovement.</li><li><span class="math inline">\(| c&#39; |\)</span>: Speed.</li></ul><p><strong>Regular Parameterization</strong>: 1. <spanclass="math inline">\(c&#39;(t) \ne 0\)</span> Forall <spanclass="math inline">\(t\)</span> 2. regular =&gt; Ordinary Point. 3.non-regular =&gt; Singular Point.</p><h3 id="change-of-parameterization">Change of Parameterization</h3><p><strong>Allowable change of param</strong>: any real smooth,differentiable function:</p><p><span class="math display">\[ f: I_1 \to I \quad f&#39;\ne 0 \text{on } I_1 \]</span></p><p>Parameter Transform: - 我们希望研究那些不变量</p><h3 id="geometric-observations.">Geometric Observations.</h3><p>Tangent vector: <span class="math display">\[ t = \frac{c&#39;}{|c&#39; |} \]</span></p><p>Normal Plane: <span class="math display">\[ (p - p_0) \cdot c_0&#39;= 0 \]</span></p><p>Osculating Plane: 密切平面</p><p><span class="math display">\[ (c_0&#39; \times c_0&#39;&#39;) \cdot(p - p_0) = 0 \]</span></p><p>Rectifying Plane: 从切平面</p><p><span class="math display">\[ (c&#39; \times (c&#39; \timesc&#39;&#39;)) \cdot (p-p_0) = 0 \]</span></p><p>Frenet Frame:</p><ul><li>Tangent: <span class="math inline">\(t = c&#39;/|c&#39;|\)</span></li><li>Binormal: $b = c’ c’’ / | c’ c’’| $</li><li>Principal normal: <span class="math inline">\(n = b \timest\)</span></li></ul><p><strong>Curvature</strong>:</p><ol type="1"><li>Measures bending of a curve.</li></ol><p><span class="math display">\[ \kappa = \frac{\| c&#39; \timesc&#39;&#39; \|}{\| c&#39; \|^3} \]</span></p><p>Example:</p><ol type="1"><li>circle: <span class="math inline">\(\kappa = 1/r\)</span></li><li>Helix: $= r / (r^2 + a^2) $</li></ol><p>Special case: Planar Curves</p><p><span class="math display">\[ \kappa = \frac{x&#39; y&#39;&#39; -x&#39;&#39;y&#39;}{(x&#39;^2 + y&#39;^2)^{3/2}} \]</span></p><p><strong>Torsion</strong>: How far is the curve is from being a planarcurve</p><p><span class="math display">\[ \tau = \frac{(c&#39; \timesc&#39;&#39;) \cdot c&#39;&#39;&#39;}{ \| c&#39; \times c&#39;&#39;\|^2 }\]</span></p><p>Measure length of curve – <strong>Arc Length</strong></p><p><span class="math display">\[ L = \int_a^b \| c&#39; \| \mathrm dt\]</span></p><h3 id="arc-length-parameterized-curves">Arc Length ParameterizedCurves</h3><p>Consider the portion of <span class="math inline">\(c(t)\)</span>,length <span class="math inline">\(s\)</span>.</p><p>Transform: <span class="math inline">\(s: c \to s\)</span></p><p>优点：</p><ul><li>Principal Normal:</li></ul><p><span class="math display">\[ n = c&#39;&#39; / \| c&#39;&#39;\|\]</span></p><h3 id="frenet-curves">Frenet Curves</h3><p><strong>Frenet curve</strong>: Arc-length Parameterized curve <spanclass="math inline">\(c\)</span>, in <span class="math inline">\(\mathbbR^n\)</span> s.t. <span class="math inline">\(c&#39;, c&#39;&#39;,...\)</span> are linear independent.</p><p>Gram-Schmidt Process -&gt; consturction of Ortho Basis.</p><p>Planar curves:</p><p><span class="math display">\[ (e_1, e_2)&#39; = \begin{vmatrix}    0 &amp; \kappa \\ -\kappa &amp; 0\end{vmatrix} (e_1, e_2) \]</span></p><h3 id="fundamantal-theorem">Fundamantal Theorem</h3><p>For every smooth function, there is a unique curve that has thisfunction as its curvature.</p><h3 id="arc-length-derivative">Arc-length derivative</h3><p><span class="math display">\[ f&#39;(s) = \frac{1}{\| c&#39; \|}f&#39;(t) \]</span></p><p>Computing the Frenet frame:</p><p><span class="math display">\[ e_1(t) = c&#39;(s) = c&#39;/\|c&#39;\|,\quad e_2 = \text{Rotate} e_1(t) \]</span></p><p><span class="math display">\[ \kappa = \langle e_1&#39;, e_2 \rangle\]</span></p><p>For 3d-space curves:</p><p><span class="math display">\[ E&#39; = \begin{vmatrix}0 &amp; \kappa &amp; 0\\-\kappa &amp; 0 &amp; \tau \\0 &amp; -\tau &amp; 0\end{vmatrix} E \]</span></p><p>General:</p><p><span class="math display">\[ E&#39; = \text{Skew-Matrix} E\]</span></p><p>Summary: for arclength:</p><ul><li>Tangent: <span class="math inline">\(t = c&#39;\)</span></li><li>Binormal: <span class="math inline">\(b = t \times n\)</span></li><li>Principal Normal: <span class="math inline">\(n =t&#39;/\|t&#39;\|\)</span></li><li>Curvature: <span class="math inline">\(\kappa = \|t&#39;\| =\|c&#39;&#39;\|\)</span></li><li>Curvature (Signed): <span class="math inline">\(\kappa = t&#39; =c&#39;&#39;\)</span></li><li>Torsion: <span class="math inline">\(\tau = - b&#39;\dotn\)</span></li></ul><p>Special: Planar Curves</p><p><span class="math display">\[ \kappa = \frac{x&#39;y&#39;&#39; -x&#39;&#39;y&#39;}{(x&#39;^2 + y&#39;^2)^{3/2}} \]</span></p><h2 id="bezier-spline.">Bezier Spline.</h2><p>Problem: 1. High Polynomial degree. 2. Non-locality. 3. NoInterpolation</p><h3 id="parametric-and-geometric-continuity">Parametric and GeometricContinuity</h3><p>Parametric continuity: <span class="math inline">\(C^0, C^1,C^2\)</span>. 1. Depends on Parameterization</p><p>Geometric continuity: <span class="math inline">\(G^0, G^1,G^2\)</span> 1. Independent of Parameterization</p><p>Relation: - <span class="math inline">\(G^0 = C^0\)</span> - <spanclass="math inline">\(C^1 \implies G^1\)</span>: Tangent Direction hascontinuity - <span class="math inline">\(C^2 \implies G^2\)</span>:curvature varies continuously</p><h3 id="parameterization">Parameterization</h3><p>Local and global param.</p><p>Input:</p><ol type="1"><li><span class="math inline">\(b_0, ..., b_n\)</span></li><li><span class="math inline">\(y(u)\)</span>: Curve on <spanclass="math inline">\([0, 1]\)</span></li><li><span class="math inline">\(x(t)\)</span>: Curve on <spanclass="math inline">\([t_i, t_{i+1}]\)</span></li></ol><p><span class="math inline">\(u\)</span>: change of param <spanclass="math inline">\(x(t) = y(u(t))\)</span></p><p><span class="math inline">\(n-th\)</span> curve for <spanclass="math inline">\(y\)</span>:</p><p><span class="math display">\[ f(0) = p_0, f(1) = p_1 \]</span></p><p><span class="math display">\[ f&#39;(0) = n (p_1 - p_0)\quadf&#39;(1) = n(p_n - p_{n-1}) \]</span></p><p><span class="math display">\[ f&#39;&#39;(0) = n(n-1)(p_2 - 2 p_1 +p_0)\quad f&#39;&#39;(1) = n(n-1)(p_n - 2p_{n-1} + p_{n-2})\]</span></p><p>General case: <strong>Joining bezier curves</strong></p><p><span class="math inline">\(C^1\)</span> Continuity:</p><p><span class="math display">\[ \frac{b_n - b_{n-1}}{t_j - t_{j-1}} =\frac{b_1 - b_0}{t_{j+1} - t_j} \]</span></p><p><span class="math inline">\(G^1\)</span> Continuity: <spanclass="math inline">\([b_{n-1} k_j b_1]\)</span> colinear.</p><h3 id="cubic-splines.">Cubic splines.</h3><p>We want <span class="math inline">\(C^0, C^1, C^2\)</span>continuity.</p><p><span class="math display">\[ C^1: \quad \frac{b_n^- - b_{n-1}^-}{t_j- t_{j-1}} = \frac{b_1^+ - b_0^+}{t_{j+1} - t_{j}} \]</span></p><p><span class="math display">\[ C^2: \quad \frac{b_n^- - 2b_{n-1}^- +b^-_{n-2}}{(t_j - t_{j-1})^2} = \frac{b_1^+ - 2b_0^+ + b_2^+}{(t_{j+1} -t_{j})^2} \]</span></p><p>Define:</p><p><span class="math display">\[ d^- = b_{n-1}^- + \Delta_j /\Delta_{j-1} (b_{n-1}^- - b_{n-2}^-) \]</span></p><p><span class="math display">\[ C^2 \iff C^1 + d^- = d^+ \]</span></p><p><span class="math inline">\(G^2\)</span></p><figure><img src="./CAGD//image-20231219111212763.png"alt="image-20231219111212763" /><figcaption aria-hidden="true">image-20231219111212763</figcaption></figure><h3 id="end-conditions">End conditions</h3><p>Bessel: Tangent vector in <span class="math inline">\(k_0\)</span> isequivalent to the tangent vector of parabola interpolating <spanclass="math inline">\(k_0, k_1, k_2\)</span></p><p>Natural: <span class="math inline">\(x&#39;&#39; = 0\)</span></p><h2 id="b-splines.">B-splines.</h2><p>Deboor Recursion (Uniform case):</p><p><span class="math display">\[ N_i^1 (t) = \delta(i \le t &lt; i+1)\]</span></p><p><span class="math display">\[ N_i^k(t) = \frac{t-i}{k - 1} N_i^{k-1}+ \frac{i+k-t}{k-1} N_{i+1}^{k-1} \]</span></p><p>Properties:</p><p>Partition of Unity, Convex Hull. - Local Support: <spanclass="math inline">\(N_{ik} &gt; 0\)</span> on <spanclass="math inline">\(t_i &lt; t &lt; t_{i+k}\)</span> - <spanclass="math inline">\(\sum N_{ik} = 1\)</span></p><p>Continuity: <span class="math inline">\(N_{ik} \inC^{k-2}\)</span></p><p><strong>Multiple weighted knot vectors</strong></p><figure><img src="./CAGD//image-20231219112732803.png"alt="image-20231219112732803" /><figcaption aria-hidden="true">image-20231219112732803</figcaption></figure><p>Properties:</p><p><span class="math display">\[ (t_0, ..., t_{2k-1}) = (0, ..., 0, 1,..., 1) \]</span></p><p>Fall back to Bernstein Polynomial.</p><ul><li>Endpoint interpolation.</li><li><span class="math inline">\(x&#39;(t_0) = (k-1)/(t_k - t_0) (d_1 -d_0)\)</span>.</li><li><span class="math inline">\(x(t)\)</span> consists of <spanclass="math inline">\(n-k+2\)</span> poly curve segments of degree <spanclass="math inline">\(k-1\)</span>.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deBoor</span>(<span class="params">X, T</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> [r-k+<span class="number">1</span>, r]:</span><br><span class="line">    d0[i] = X[i]</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">1</span>, k-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">for</span> i = [r-k+<span class="number">1</span>+j, r]:</span><br><span class="line">      alpha = (t-t[i])/(t[i+k-j]-t_i)</span><br><span class="line">      d[j][i] = (<span class="number">1</span>-alpha) * d[j-<span class="number">1</span>][i-<span class="number">1</span>] + alpah d[j-<span class="number">1</span>][i]</span><br><span class="line">  <span class="keyword">return</span> x(t) = d[k-<span class="number">1</span>][r]</span><br></pre></td></tr></table></figure><h3 id="interpolation">Interpolation</h3><p>Input: - <span class="math inline">\(n+1\)</span> cp <spanclass="math inline">\(k_0, ..., k_n\)</span> - <spanclass="math inline">\(s_0, ..., s_n\)</span></p><p>Output: Piecewise cubic interpolation b-spline <spanclass="math inline">\(x\)</span>.</p><p><span class="math display">\[ x(s_0) = k_0 = d_0 \]</span></p><p><span class="math display">\[ x(s_i) = k_i = N_{i, 4} (s_i) d_i +N_{i+1, 4} d_{i+1} + N_{i+2, 4} d_{i+2} \]</span></p><p><span class="math display">\[ x(s_n) = k_n = d_{n+2} \]</span></p><p>End condition:</p><p>Natural end condition: <span class="math inline">\(x&#39;&#39;(s_0) =x&#39;&#39;(s_n) = 0\)</span></p><h3 id="summary-of-bezier-and-b-spline-curves">Summary of Bezier andB-Spline curves</h3><ol type="1"><li>Bezier curve for <span class="math inline">\(n+1\)</span> cp:<ul><li>Polynomial curve of deg <span class="math inline">\(n\)</span></li><li>Uniquely defined by cp.</li><li>Endpoint interp, remaining points are approximated.</li><li>pseudo-local impact of CP.</li></ul></li><li>Interp cubic bezier spline curves by the control points <spanclass="math inline">\(k_0,...,k_n\)</span><ul><li>Consists of <span class="math inline">\(n\)</span> piecewise cubiccurve segments.</li><li><span class="math inline">\(C^2\)</span> continuity.</li><li>Uniquely defined by parameterization.</li><li>Interp all cp.</li><li>pseudo-local</li></ul></li><li>Piecewise cubic B-spline for cp. knotvector.<ul><li><span class="math inline">\(n-2\)</span> piecewise cubic curvesegments which are <span class="math inline">\(C^2\)</span>.</li><li>Uniquely defined by <span class="math inline">\(d_i\)</span> and<span class="math inline">\(T\)</span>.</li><li>Endpoint interp.</li><li>Local impact of the de Boor points</li></ul></li><li>Interpolating cubic B-spline.</li></ol><h3 id="exercises">Exercises</h3><p>For order 4 and knot seq.</p><p><span class="math display">\[ T = [t_0,...,t_7] \]</span></p><p>Evaluate</p><p><span class="math display">\[ N_{04}, N_{14}, N_{24}, N_{34}\]</span></p><p>de Boor Algorithm.</p><h2 id="blossoming-and-polar-forms">Blossoming and Polar forms</h2><p>Affine combinations.</p><p>Polar forms</p><ul><li><span class="math inline">\(1\to 1\)</span></li><li><span class="math inline">\(t \to t, 1 \to 1\)</span></li><li><span class="math inline">\(t^2 \to t_1 t_2, t \to \frac{1}{2} t_1 +t_2, 1\to 1\)</span></li><li>…</li></ul><p>Generalization.</p><ol type="1"><li>Blossom for Polynomial curves</li><li>Blossom with points as arguments.</li><li>Vector arguments.</li></ol><p>Derivatives:</p><p><span class="math display">\[\frac{d^k}{dt^k} F(t) = \frac{n!}{(n-k)!} f(t, ..., t, \hat1, ...,\hat1)\]</span></p><p>Continuity condition: TFAE.</p><ol type="1"><li><span class="math inline">\(F\)</span> and <spanclass="math inline">\(G\)</span> are C^k continuous at <spanclass="math inline">\(t\)</span></li><li><span class="math inline">\(\forall t_1, ..., t_k\)</span>, <spanclass="math inline">\(f(t, ..., t, t_1, ..., t_k) = g(t, ..., t_1, ...,t_k)\)</span>.</li><li><span class="math inline">\(f(t, ..., t, \hat 1,..., \hat 1) = g(t,..., t, \hat 1, ..., \hat 1)\)</span></li></ol><p>De Casteljau Algorithm</p><p><span class="math display">\[ b(000), b(001), b(011), b(111)\]</span></p>]]></content>
      
      
      
        <tags>
            
            <tag> Geometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-Spline Curve</title>
      <link href="/2023/11/09/geometry/b-spl/"/>
      <url>/2023/11/09/geometry/b-spl/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="b-spline-curve">B-Spline Curve</h2><h3 id="definition">Definition</h3><p>Use repleated linear interpolation. <span class="math display">\[N_i^1(t) = \begin{cases}    1 &amp; i \le t &lt; i + 1\\    0&amp; \text{otherwise}\end{cases}\]</span> and, <span class="math display">\[N_i^k(t) = \frac{t-i}{(i+k-1) -i} N_i^{k-1} (t) + \frac{(i+k) -t}{(i+k)- (i+1)}N_{i+1}^{k-1}(t)\]</span> Generalize: replace <span class="math inline">\(i\)</span>with <span class="math inline">\(t_i\)</span></p><p>Then, the curve is defined: Given <spanclass="math inline">\(n+1\)</span> control points <spanclass="math inline">\(\vec p_i\)</span>, Knot vector <spanclass="math inline">\(T = (t_0, …, t_{n+k})\)</span>: <spanclass="math display">\[\vec r(t) = \sum_{i = 0}^n \vec p_i N_{i}^k (t)\]</span></p><ul><li><span class="math inline">\(\vec p_i\)</span> is <strong>de Boorpoints</strong></li><li>Curve is defined on interval <span class="math inline">\([t_{k-1},t_{n+1}]\)</span></li></ul><h3 id="properties">Properties</h3><ol type="1"><li><p>Local support: For given <span class="math inline">\(i,k\)</span>, support is <span class="math inline">\((t_i,t_{i+k})\)</span></p></li><li><p>Non-negtivity</p></li><li><p>Unitary: <span class="math inline">\(\sum N_i (t) = 1\)</span>inside the domain of definition.</p><p>⇒ Convex</p></li><li><p>For <span class="math inline">\(t_i \le t_j \le t_{i+k}\)</span>,<span class="math inline">\(N\)</span> is <spanclass="math inline">\(C^{k-2}\)</span> at <spanclass="math inline">\(t_j\)</span></p></li><li><p>Repeat at <span class="math inline">\(t_i\)</span> for <spanclass="math inline">\(j\)</span> times, the continuity goes down <spanclass="math inline">\(j\)</span> order.</p></li></ol><h3 id="relation-to-bezier">Relation to Bezier</h3><p><span class="math display">\[T=(0, 0, ..., 0, 1, 1, ..., 1)\]</span></p><p><span class="math inline">\(k\)</span>-times on two ending ⇒Bernstein polynomial.</p><h2 id="b-spline">B-Spline</h2><h3 id="definition-1">Definition</h3><p>Given special knot vector: (Repaat at ends) <spanclass="math display">\[T = (t_0= t_1=\cdots= t_{k-1}, t_k, t_1, ..., t_n, t_{n+1} = \cdots =t_{n+k})\]</span></p><ul><li>de Boor polygon: <span class="math inline">\(d_0, …,d_n\)</span></li><li>also defined on <span class="math inline">\([t_{k-1},t_{n+1}]\)</span>, but endings are repeated.</li></ul><h3 id="properties-1">Properties</h3><ol type="1"><li>Endpoint interpolation</li><li>Tangent direction at <span class="math inline">\(d_0\)</span></li><li><span class="math inline">\(n-k+2\)</span> polynomial curve segmentsof degree <span class="math inline">\(k-1\)</span></li></ol><p>Multiple inner knots ⇒ Reduction of continuity of <spanclass="math inline">\(x(t)\)</span></p><ul><li><span class="math inline">\(l\)</span>-times ⇒ <spanclass="math inline">\(C^{k-l-1}\)</span> cont.</li></ul><p>Local impact, <span class="math inline">\(d_i\)</span> ⇒ impact <spanclass="math inline">\([t_i, t_{i+k}]\)</span></p><h3 id="evaluation-de-boor-algorithm">Evaluation: de Boor algorithm</h3><ol type="1"><li>evaluate B-Spline Functions</li><li>(or) de Boor algorithm</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deBoor</span>(<span class="params">d, T, t</span>):</span><br><span class="line">  r = t[r] &lt; t &lt; t[r+<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r-k+<span class="number">1</span>, r+<span class="number">1</span>):</span><br><span class="line">    d[<span class="number">0</span>][i] = d[i]</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>, ..., k-<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i = r-k+<span class="number">1</span>, ..., r:</span><br><span class="line">      d[j][i] = (<span class="number">1</span> - alpha) d[j-<span class="number">1</span>][i-<span class="number">1</span>] + alpha d[j-<span class="number">1</span>][i]</span><br><span class="line"><span class="keyword">return</span> d[k-<span class="number">1</span>][r]</span><br></pre></td></tr></table></figure><h3 id="interpolation-using-b-spline">Interpolation using b-spline</h3><p>Input:</p><ul><li>control points (not de boor points) <spanclass="math inline">\(k_0,...,k_n\)</span></li><li>knot vector <span class="math inline">\(s_0, … s_n\)</span></li></ul><p>Output: curve interpolates <span class="math inline">\(k_i\)</span>at <span class="math inline">\(s_i\)</span></p><p>Key: find deboor points <span class="math inline">\(d_0, …,d_{n+k-2}\)</span></p><ul><li>Domain: <span class="math inline">\(t_{k-1} \to t_{N+1}\)</span> has<span class="math inline">\(N-k+3\)</span> “points”</li><li>therefore <span class="math inline">\(N-k+3 = n+1 \implies N =n+k-2\)</span></li></ul><p>Formulation:</p><ol type="1"><li>Interpolation: <span class="math inline">\(x(s_i) =k_i\)</span></li><li>Ending condition</li></ol><h2 id="relationships">Relationships</h2><h3 id="bezier-b-spline">Bezier → B-Spline</h3><p>Input:</p><ul><li>control points of bezier curve</li><li>knot vector</li><li><span class="math inline">\(b_0, …, b_{3n}\)</span>, Bezier pointsinterpolating the curve.</li><li>ending conditions</li></ul><p>Output:</p><ul><li>curve in b-spline form</li></ul><p>Key:</p><ul><li>deboor points, and knot for b-spline</li></ul><p>Algorithm: <span class="math display">\[\begin{aligned}d_0 &amp;= b_0\quad d_1 = b_1 \\d_i &amp;= b_{3i-4} + \Delta_{i-1}/ \Delta_{i-2} (b_{3i-4}-b_{3i-5})\\d_{n+1} &amp;= b_{3n - 1}\quad d_{n} = b_{3n}\end{aligned}\]</span></p>]]></content>
      
      
      
        <tags>
            
            <tag> Geometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multigrid method</title>
      <link href="/2023/10/09/mg-zh/"/>
      <url>/2023/10/09/mg-zh/</url>
      
        <content type="html"><![CDATA[<!-- #! https://zhuanlan.zhihu.com/p/660685901--><ul><li>A translation to: <ahref="https://ocw.mit.edu/courses/18-086-mathematical-methods-for-engineers-ii-spring-2006/resources/am63/">Chapter7-3</a> of Strang, Gilbert. Computational Science and Engineering</li><li>Translator： Adversarr</li><li>Github：https://github.com/Adversarr/multigrid-zh</li></ul><h2 id="背景问题">背景问题</h2><p>考虑如下的两点边值问题： <span class="math display">\[\begin{cases}  - u&#39;&#39;(x) = f(x)\quad \forall x \in (0, 1) \\  u(0) = u(1) = 0\end{cases}\]</span> 我们使用有限差分法进行求解，对于空间采用<spanclass="math inline">\(N+1\)</span>点均匀划分： <spanclass="math display">\[x_0 = 0, ..., x_n = i / N, ..., x_N = 1\]</span> 二阶导数用如下的公式近似： <span class="math display">\[f(x_j) = u&#39;&#39;(x_j) \approx \frac{2u(x_{j}) - u(x_{j-1}) -u(x_{j+1})}{(1/N)^2}\]</span> 这转化为求解如下的线性方程组求解问题： <spanclass="math display">\[\frac{1}{h^2}  \begin{bmatrix}  2 &amp; -1 &amp; 0 &amp; 0&amp; \cdots &amp; 0\\  -1 &amp; 2 &amp; -1&amp; 0&amp; \cdots &amp; 0\\  0 &amp; -1 &amp; 2 &amp; -1&amp; \cdots&amp; 0\\  0 &amp;  0&amp; -1 &amp; 2&amp; \cdots&amp; 0\\  \vdots&amp; \vdots&amp;\vdots&amp;\vdots &amp; \ddots &amp; \vdots\\  0 &amp; 0 &amp; 0 &amp; 0&amp;\cdots &amp; 2\end{bmatrix} \begin{bmatrix}  u(x_1)\\u(x_2)\\u(x_3)\\  \vdots\\  u(x_{N-1})\end{bmatrix} = \begin{bmatrix}  f(x_1)\\f(x_2)\\f(x_3)\\  \vdots\\  f(x_{N-1})\end{bmatrix}\]</span> 我们将方程组的求解问题写成 <span class="math inline">\(Ax =b\)</span> 的形式。 <span class="math display">\[A = \frac{1}{h^2} \begin{bmatrix}  2 &amp; -1 &amp; 0 &amp; 0&amp; \cdots &amp; 0\\  -1 &amp; 2 &amp; -1&amp; 0&amp; \cdots &amp; 0\\  0 &amp; -1 &amp; 2 &amp; -1&amp; \cdots&amp; 0\\  0 &amp;  0&amp; -1 &amp; 2&amp; \cdots&amp; 0\\  \vdots&amp; \vdots&amp;\vdots&amp;\vdots &amp; \ddots &amp; \vdots\\  0 &amp; 0 &amp; 0 &amp; 0&amp;\cdots &amp; 2\end{bmatrix}\]</span>这是一个稀疏矩阵的求解问题，我们先不考虑使用直接求解器（三对角矩阵有很好的求解方法，但是对于2维的情况，构建出的矩阵不是三对角的），而使用迭代求解器进行求解。</p><blockquote><p>Note：这里使用有限差分法是可以收敛到精确解的，可以考虑在使用等距网格的情况下的有限元方法，它们诱导了相同的线性方程组求解问题。</p></blockquote><p>我们一般将这里的求解选取的 <span class="math inline">\(x_j, j = 0,..., N\)</span> 看作一个网格。等距网格的粗细指的是<spanclass="math inline">\(h=1/N\)</span>的大小。越小的<spanclass="math inline">\(h\)</span>能够得到越精确的结果，但求解点数的<spanclass="math inline">\(N\)</span>也会随之上升，计算量随之增大。</p><h2 id="引入">引入</h2><p>Jacobi 和 Gauss- Seidel 迭代都能够产生“光滑”的误差：误差向量 <spanclass="math inline">\(e\)</span>的高频分量在很少次的迭代后消失，但是低频分量很少衰减。迭代收敛需要<spanclass="math inline">\(O(N^2)\)</span>次，对于实际问题是不可接受的。</p><blockquote><p>Background：考虑线性方程组 <span class="math inline">\(A x =b\)</span> 的求解，使用迭代求解。</p><ul><li><span class="math inline">\(x_0\)</span> 为迭代初值；</li><li><span class="math inline">\(e_i = A^{-1}b -x_i\)</span>，表示当前解与真解的误差；</li><li><span class="math inline">\(r_i = Ae_i = b - A x_i\)</span>表示当前解表达方程组的误差</li></ul><p>MultiGrid方法最常见的可以用于求解Poisson问题的解。均匀网格下的有限差分法将这样的Poisson问题变成线性方程组的求解问题。</p></blockquote><p>多重网格法（MultiGrid）可以极大的解决迭代求解器的效率问题，其思想是将原本网格上的线性方程求解问题转化到一个更粗的网格上，在更粗的网格上施用迭代求解器（例如Jacobi/GS求解器），细网格上的低频分量转化为了粗网格上的高频分量，粗网格求解器消除的高频分量实则就是细网格上的低频分量。</p><blockquote><p>Recall：例如间隔为<span class="math inline">\(\Deltax\)</span>的网格上<span class="math inline">\(e^{i\omega \cdot n \Deltax}\)</span> 分量，在<span class="math inline">\(2 \Delta x\)</span>上对应<span class="math inline">\(e^{i 2 \omega \cdot n \Deltax}\)</span>，频率也提升了一倍。</p></blockquote><p>在粗网格上，原本的低频分量很快就被“干掉”了。而且，我们在粗网格上只需要很少次数的迭代，就能够使得这些分量消失。这样的性质使得多重网格法能够使用<strong>固定次数</strong>的迭代，就能较精确地求解现实中很多的稀疏方程组（这里的次数不随着矩阵规模而变大）。</p><p>多重网格法一般用于对称的矩阵求解问题。它的最核心要素是用两个矩阵<span class="math inline">\(R\)</span> 和 <spanclass="math inline">\(I\)</span> 来在不同的网格上进行切换。</p><ol type="1"><li><strong>限制矩阵</strong>（Restriction Matrix） <spanclass="math inline">\(R=R_{2h}^h\)</span>：把向量从细网格传到粗网格上；</li><li><strong>插值矩阵</strong>（Interpolation matrix）<spanclass="math inline">\(I=I_{2h}^h\)</span>：将粗网格上的结果传到细网格上</li><li>原始矩阵在粗网格上的近似 <spanclass="math inline">\(A_{2h}=RA_hI\)</span></li></ol><blockquote><p>Note：这里用 <span class="math inline">\(h, 2h\)</span>这样的记号是参考了有限差分求解的网格粗细记号，用来表征从一个粒度为 <spanclass="math inline">\(h\)</span> 的细网格，和另一个粒度为 <spanclass="math inline">\(2h\)</span> 的粗网格。</p></blockquote><p>我们先考虑这些矩阵的定义：假设粗网格上有 3 个点， <spanclass="math display">\[v = (v_1, v_2, v_3)^T\]</span>我们希望得到细网格上的数值，可以用线性插值得到，写成矩阵形式可以得到上面定义的<strong>插值矩阵</strong>如下。注意到<spanclass="math inline">\(u\)</span> 的2/4/6行恰好是 <spanclass="math inline">\(v_1, v_2, v_3\)</span>，而1/3/5/7行就是从<spanclass="math inline">\(0, v_1, v_2, v_3,0\)</span>进行的线性插值。另外我们观察<spanclass="math inline">\(I\)</span>矩阵，在奇数行的元素值为 <spanclass="math inline">\(1/2\)</span>，这样很容易计算，我们也几乎只用 <spanclass="math inline">\(h, 2h, 4h, …\)</span>这样的网格。使用别的插值方法也是可行的，但是线性插值易于实现。 <spanclass="math display">\[\underbrace{\frac{1}{2} \begin{bmatrix}  1 &amp; &amp; \\  2 &amp; &amp; \\  1 &amp; 1 &amp; \\    &amp; 2 &amp; \\    &amp; 1 &amp; 1\\    &amp;   &amp; 2\\    &amp;   &amp; 1\end{bmatrix}}_{I = I_{2h}^h}\begin{bmatrix}v_1\\v_2\\v_3\end{bmatrix} = \begin{bmatrix}  0/2 + v_1 / 2\\  v_1\\  v_1/2 + v_2 / 2\\  v_2\\  v_2/2 + v_3 / 2\\  v_3\\  v_3/2 + 0 / 2\end{bmatrix} = \begin{bmatrix}  u_1\\  u_2\\  u_3\\  u_4\\  u_5\\  u_6\\  u_7\\\end{bmatrix}\]</span></p><blockquote><p>Note：利用两点边值问题的边界条件。</p></blockquote><p>考虑 <span class="math inline">\(v\)</span>是粗网格上的一个谐波，尽管<spanclass="math inline">\(v\)</span>可能是粗网格上的高频分量，但它对应了细网格上的低频分量，我们的插值操作能够将它很好地反映在细网格上。</p><blockquote><p>Note：这一段说的有点奇怪，简而言之就是，在细网格上的任何一个<strong>低频误差分量</strong>都能在粗网格上有一一的体现。（Recall：高频误差分量都能够被迭代求解器很好的处理）</p></blockquote><p>反过来，我们可以从细网格限制到粗网格上（类似于一个“平均”）。它将<spanclass="math inline">\(u\)</span>从一个细网格传递到粗网格上。一种可能的是直接令<span class="math inline">\(v_i=u_{2i+1}\)</span>，这样就忽略了<spanclass="math inline">\(u_{2i}\)</span>的影响。我们可以用一种加权平均的方法，下面的公式说明了这个方法（Fullweighting operator）。 <span class="math display">\[\begin{bmatrix}v_1\\v_2\\v_3\end{bmatrix} =\underbrace{\frac14\begin{bmatrix}  1 &amp; 2 &amp; 1 &amp;\\  &amp;&amp;1 &amp; 2 &amp; 1\\  &amp;&amp;&amp;&amp; 1 &amp; 2 &amp; 1\end{bmatrix}}_{R_h^{2h} = \frac{1}{2} (I_{2h}^h)^T} \begin{bmatrix}  u_1\\  u_2\\  u_3\\  u_4\\  u_5\\  u_6\\  u_7\\\end{bmatrix}\]</span>限制矩阵将细网格的低频分量的频率翻倍传递到粗网格上，画出图像更好理解这个过程：</p><figure><img src="image-20231009193402907.png" alt="限制矩阵的系数" /><figcaption aria-hidden="true">限制矩阵的系数</figcaption></figure><h2 id="二维空间中的插值和限制矩阵">二维空间中的插值和限制矩阵</h2><p>二维空间中，粗网格到细网格的插值是通过双线性插值得到。双线性插值可以通过<spanclass="math inline">\(x, y\)</span>两个方向上分别进行线性插值得到。</p><p><strong>水平方向的插值</strong>： - <spanclass="math inline">\(u_{2i, 2j} = v_{i, j}\)</span> - <spanclass="math inline">\(u_{2i, 2j + 1} = \frac 1 2 (v_{i, j} + v_{i,j+1})\)</span></p><p><strong>竖直方向的插值</strong>： - <span class="math inline">\(u_{2i+1, 2j} = (v_{i, j} + v_{i+1, j}) / 2\)</span> - <spanclass="math inline">\(u_{2i +1, 2j+1} = (v_{i, j} + v_{i+1, j} + v_{i,j+1} + v_{i+1, j+1}) / 4\)</span></p><p>我们不给出插值算子 <span class="math inline">\(I2D\)</span>的矩阵形式。</p><blockquote><p>Recall：有限维线性空间到有限维线性空间的线性映射，选取一个合适的基的情况下可以表达为一个矩阵。</p></blockquote><p>反过来，从细网格到粗网格的算子 <span class="math inline">\(R2D =\frac{1}{4} I2D^T\)</span>（<spanclass="math inline">\(1/4\)</span>的常数使得<spanclass="math inline">\(1 \rightarrow 1\)</span>）。这个矩阵的稀疏由 <spanclass="math inline">\(\frac{1}{4} ,\frac{1}{8},\frac{1}{16}\)</span>组成，每一个粗网格点都是对于细网格的9点加权平均：</p><p>![<a href="image-20231009201927906.png">二维Restriction</a></p><p>其实你不难发现这些稀疏的由来，原本一维情况下加权平均系数是<spanclass="math inline">\((\frac14, \frac12, \frac14)\)</span>。<spanclass="math inline">\(R2D\)</span>在这一个局部上的系数正是这个小的向量的外积。而<spanclass="math inline">\(R2D\)</span>正是<spanclass="math inline">\(R\)</span>与自身的Kronecker Product。</p><blockquote><p>Note：考虑 3x3 的网格和，标号为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure> 它拍平后为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure> Kronecker积恰好对应了这样的变换。简单验证下，<spanclass="math inline">\(R\)</span>为3x7的矩阵，<spanclass="math inline">\(R2D\)</span> 是 9x49的矩阵，维数也是相对应的。</p></blockquote><blockquote><p>Recall：矩阵的 Kronecker 积对应了 Tensor Product</p></blockquote><p>现在，我们能够在网格之间相互传递向量，这就是几何理解的多重网格法，我们能在网格基于间距h，2h和4h的情况下进行计算。这个想法可以延伸到三角形元素（每个三角形自然地分成四个三角形）。实际计算的几何形状可以比我们在一个正方形网格考虑的模型更加复杂。</p><p>当几何上的多重网格变得较为复杂，或者我们只是获得了一个矩阵，而没有相应的“网格”概念，这是我们可以使用Algebraicmultigrid（AMG）。它也是基于多尺度求解的思想，可以直接应用在<spanclass="math inline">\(Ax = b\)</span>问题上，而不依赖于具体的网格。</p><h2 id="两个网格的-v-cyclev-cycle">两个网格的 V-Cycle（v-cycle）</h2><blockquote><p>Jacobi Iteration: <span class="math display">\[x_{n+1} =  D^{-1}(b - R x_n)\quad \text{where}\quad A = D + R\]</span></p></blockquote><p>我们先考虑只使用两个网格进行求解的过程。在每个网格内的迭代，我们考虑使用Jacobi格式或者GS格式求解。我们前面多次指出，对于一个较大规模的问题，在细网格上的迭代法对于低频误差去除得很慢（也就是原文说的“对于精确解的低频分量收敛很慢”）。多重网格法将细网格的残差<spanclass="math inline">\(r_h = b - A u_h\)</span>传到粗网格上<spanclass="math inline">\(r_{2h}\)</span>；然后在粗<spanclass="math inline">\(2h\)</span>网格上求解<spanclass="math inline">\(A_{2h} E_{2h} = r_{2h}\)</span>；然后将<spanclass="math inline">\(E_{2h}\)</span>传到细网格上为 <spanclass="math inline">\(E_h\)</span>，并且修正 <spanclass="math inline">\(u&#39;_h = u_h +E_h\)</span>，然后再次执行这个流程。</p><p>这样的循环就是一个两网格的 V-cycle。我们将其称之为一个v-cycle（小v），以下是它的步骤（残差是指 <spanclass="math inline">\(r_h=A_h (u - u_h) = b_h - A_h u_h\)</span>）：</p><ol type="1"><li><strong>Iterate</strong>（迭代）：在细网格上迭代，求解 <spanclass="math inline">\(A_h u_h =b_h\)</span>（例如使用3次的Jacobi或GS迭代）</li><li><strong>Restrict</strong>（限制）：将残差传递到粗网格上，<spanclass="math inline">\(r_{2h} = R_h^{2h} r_h\)</span></li><li><strong>Solve</strong>（求解）：在粗网格上迭代，求解修正项 <spanclass="math inline">\(A_{2h} E_{2h} = r_{2h}\)</span>（例如，从<spanclass="math inline">\(E=0\)</span>开始3次迭代，在更进一步的方法中，这个方程的求解方法是任意的）</li><li><strong>Interpolate</strong>（插值）：修正项从粗网格上传到细网格上，<spanclass="math inline">\(E_h = I_{2h}^h E_{2h}\)</span>，将 <spanclass="math inline">\(E_h\)</span> 加到 <spanclass="math inline">\(u_h\)</span> 上</li><li><strong>Iterate</strong>（迭代）：以 <span class="math inline">\(u_h+ E_h\)</span>（消除了部分低频分量）为初值迭代，类似第一步的过程</li></ol><blockquote><p>Note：</p><ul><li>残差<spanclass="math inline">\(r\)</span>是指模型观测值与真实值的误差，模型观测值指的是<span class="math inline">\(Ax\)</span>，真实值就是 <spanclass="math inline">\(b\)</span>，<span class="math inline">\(r = b -Ax\)</span></li><li>误差<spanclass="math inline">\(e\)</span>是指当前解和真实解的误差，<spanclass="math inline">\(e = A^{-1} b - x\)</span></li><li>误差和残差相比，要求知道真实解的值（知道真解的值时，已经解决了矩阵求解问题）但残差只需要计算<spanclass="math inline">\(b-Ax\)</span>，这里面每一项都是已知的。</li></ul><p>我们希望修正项 <span class="math inline">\(E_h = I_{2h}^hE_{2h}\)</span> 能够尽可能好的表达 <spanclass="math inline">\(e_h\)</span>，即 <span class="math inline">\(E_h\approx e_h\)</span>，这样：</p><p><span class="math display">\[\begin{aligned}  &amp;u_h +  I_{2h}^h E_{2h} \approx u_h + e_h = A^{-1}b\\  \implies &amp; A_hI_{2h}^{h} E_{2h}\approx b - A_hu_h = r_h\\  \implies &amp; \underbrace{R_{h}^{2h} A_h I_{2h}^h}_{A_{2h}} E_{2h}\approx R_{h}^{2h} r_h\end{aligned}\]</span></p><p>上面的最后一步给出了多重网格第三步的解释。</p></blockquote><p>2-3-4 步给出的 <strong>限制-粗解-插值</strong>过程是多重网格法的核心。回忆我们定义的三个矩阵： <spanclass="math display">\[\begin{aligned}  A &amp;= A_{h} = \text{original matrix}\\  R &amp;= R_{h}^{2h} = \text{restriction matrix}\\   I &amp;= I_{2h}^h = \text{interpolation matrix}\\\end{aligned}\]</span></p><p>第三步需要第四个矩阵<spanclass="math inline">\(A_{2h}\)</span>，可以从上面的式子中定义（如下）。<span class="math inline">\(A_{2h}\)</span>是一个比原本的<spanclass="math inline">\(A_h\)</span>更小的方阵。换言之，我们希望将更大的矩阵<span class="math inline">\(A_h\)</span><strong>投影</strong>到一个粗网格上。这样的投影由一个相当自然的选择，变分正确（VariationallyCorrect，不知道翻译的对不对）的 <spanclass="math inline">\(A_{2h}\)</span> 可以从 <spanclass="math inline">\(R,A,I\)</span> 直接得到：</p><p><span class="math display">\[A_{2h} = R A I\]</span></p><p>例如，细网格上有7个数据点，粗网格有3个数据点，我们求得的矩阵恰好是<spanclass="math inline">\(3\times 3\)</span>的。</p><h3 id="例子">例子</h3><p>在一维情况下，<span class="math inline">\(A = A_h\)</span>可能是一个二阶差分矩阵 <spanclass="math inline">\(K/h^2\)</span>。我们之前的例子中，<spanclass="math inline">\(h=\frac18\)</span>，现在为了方便起见，我们考虑<span class="math inline">\(h = \frac16\)</span>的情况，这样多重网格法实现在5点和2点的粗细网格上的插值和限制（<spanclass="math inline">\(I \in \mathbb R^{5\times 2}\)</span>，<spanclass="math inline">\(R\in \mathbb R^{2 \times 5}\)</span>）。将<spanclass="math inline">\(K_5/h^2\)</span>代入<spanclass="math inline">\(RA_h\)</span>中可得： <spanclass="math display">\[\begin{aligned}RA &amp;= \frac 1 4 \begin{bmatrix}  1 &amp; 2 &amp; 1 \\    &amp;   &amp; 1 &amp; 2 &amp; 1\end{bmatrix}\frac {1} {h^2}\begin{bmatrix}  2 &amp; -1 \\  -1 &amp; 2 &amp; -1 \\  &amp; -1 &amp; 2 &amp; -1\\  &amp;&amp; -1 &amp; 2 &amp; -1\\  &amp;&amp;&amp; -1 &amp; 2\end{bmatrix}\\&amp;=\frac{1}{(2h)^2} \begin{bmatrix}  0&amp; 2 &amp; 0 &amp; -1 &amp; 0\\  0&amp; -1 &amp; 0 &amp; 2 &amp; 0\\\end{bmatrix}\end{aligned}\]</span></p><p>对于<spanclass="math inline">\(A_{2h}\)</span>的一个自然的选择是（直接用前文中的插值矩阵<spanclass="math inline">\(I_{2h}^h\)</span> 代入也是相同的结果）： <spanclass="math display">\[A_{2h} = RAI = \frac{1}{(2h)^2} \begin{bmatrix}  2 &amp; -1\\  -1&amp;  2\end{bmatrix}\]</span> 不难看出，这恰好是<spanclass="math inline">\(2h\)</span>的网格上的二阶差分矩阵（因为网格为<spanclass="math inline">\(2h\)</span>宽，分母自动放大）。</p><blockquote><p>Note：差分算子K$的定义从两点边值问题的矩阵求解形式中得到。</p><p>Recall：之前定义的两点边值问题，Poisson方程（微分方程）被转化为线性方程组（差分方程）。写出网格<spanclass="math inline">\(h = 1/3\)</span>的矩阵，恰好是这里的<spanclass="math inline">\(A_{2h}\)</span>。</p><p>Note：我的理解是，用相同的数值方法，但用不同的网格密度求解同一个方程，粗网格的解<spanclass="math inline">\(u_{2h}\)</span>插值到细网格上，应该“接近”细网格的解<spanclass="math inline">\(u_h\)</span>。</p></blockquote><p>我们选取的<span class="math inline">\(R = \frac{1}{2}I^T\)</span>还有一个很好的性质：<strong>如果原先的矩阵 <spanclass="math inline">\(A\)</span> 是对称、正定的，那么<spanclass="math inline">\(RAI = \frac{1}{2} I^T A I\)</span>也是对称正定的。</strong></p><blockquote><p>读者自证不难。</p></blockquote><p><spanclass="math inline">\(A\)</span>的正定性通常由数值方法的推导得到，特别是Galerkin方法中非常常见（有限元法是Galerkin法的代表）。</p><blockquote><p>Note：对于Poisson 问题的有限元法，</p><ul><li>除去纯Neumann边值问题，其他的情况下由双线性形式诱导的矩阵都是正定的；</li><li>纯Neumann边值问题添加<span class="math inline">\(\int_{\Omega} u\mathrm d x = 0\)</span> 的条件后，诱导的矩阵也是正定的；</li></ul></blockquote><p>尽管第一步和第五部不是多重网格法的核心，但第一步和第五步是必要的：第一步（smoother）将原本误差中的高频分量消除，而第五步（post-smoother）将粗网格插值引入的一小部分高频误差消除。在实现上，各种Jacobi和GS求解器都是可行的。</p><blockquote><p>Note：这里杂糅了一些自己的理解，原文为</p><p>Steps 1 and 5 are necessary, but they are really outside theessential multigrid idea. The <strong>smoother</strong> is step 1, thepost-smoother is step 5. Those are normal iterations for which weightedJacobi or Gauss-Seidel is satisfactory.</p></blockquote><h2 id="误差分析">误差分析</h2><p>假设在第三步我们精确地求出了粗网格上的误差方程。多重网格误差修正项<spanclass="math inline">\(E_h\)</span>是否能等于 <spanclass="math inline">\(e_h = u -u_h\)</span>呢？这种期望显然是不切实际的！毕竟我们只是在一个粗网格上求解了这个问题，并不是整个问题。但是，在多重网格法中，<spanclass="math inline">\(E_h\)</span> 和 <spanclass="math inline">\(e_h\)</span> 之间的联系是最关键的。对 <spanclass="math inline">\(E_h\)</span> 和<spanclass="math inline">\(e_h\)</span>的分析过程很简单，我们一步一步的来看。</p><blockquote><p>Note：看之前的步骤部分后面给的一段分析。</p><p>在这里，方便起见，在不引起歧义的情况下省略了一部分上下标（公式打得我好累）</p></blockquote><p><em>作用在<span class="math inline">\(e\)</span>上的四个矩阵</em>： -第二步，残差计算涉及了<span class="math inline">\(e\)</span>：<spanclass="math inline">\(r_h = b- A_h u_h = Ae\)</span>； -第二步，传到粗网格时，限制矩阵作用在其上：<spanclass="math inline">\(r_{2h} = RA_he\)</span> -第三步，假设精确地求解<spanclass="math inline">\(2h\)</span>上的方程：<spanclass="math inline">\(E_{2h} = A_{2h}^{-1}r_{2h} = (RAI)^{-1}R A_he\)</span> - 第四步，传回细网格，插值矩阵作用在其上，最终形式如下</p><p><span class="math display">\[E = (I A_{2h}^{-1} R A_h) e =: S e\]</span></p><blockquote><p>Note：不能将<spanclass="math inline">\(A_{2h}^{-1}=(RAI)^{-1}\)</span>拆开，这应该很显然。</p></blockquote><p>当 <span class="math inline">\(I \in \mathbb R^{5\times2}\)</span>，<span class="math inline">\(R\in \mathbb R^{2 \times5}\)</span>时，等式右侧的<spanclass="math inline">\(S\)</span>依然是<spanclass="math inline">\(5\times 5\)</span>的矩阵。<spanclass="math inline">\(S\)</span> 不可能是单位阵/恒等矩阵（IdentityMatrix），这是因为<span class="math inline">\(RAI\)</span>是<spanclass="math inline">\(2\times2\)</span>的矩阵（<spanclass="math inline">\(\mathrm{rank}=2\)</span>）。但<spanclass="math inline">\(S\)</span>具有性质 <span class="math inline">\(S^2= S\)</span>，<strong>这说明<spanclass="math inline">\(S\)</span>限制在其列空间（ColumnSpace）上是恒等矩阵</strong>。与此同时，在它的零空间（右零空间）上是零矩阵。<spanclass="math inline">\(S^2 = S\)</span>是容易验证的：</p><p><span class="math display">\[S^2 = (I (RAI)^{-1} RA)(I (RAI)^{-1} RA) = I (RAI)^{-1} RA = S\]</span></p><blockquote><p>Note：列空间上恒等的说明。<spanclass="math inline">\(S\)</span>的列空间是说 ${ Su: u R^n}，在列空间中的任一向量 <spanclass="math inline">\(Su\)</span>，因为<spanclass="math inline">\(S\)</span>幂等，所以 <span class="math display">\[  S(Su) = S^2 u = Su\]</span> 这就说明<spanclass="math inline">\(S\)</span>在列空间上的矩阵是恒等矩阵。</p></blockquote><blockquote><p>Note：其实有一个挺常见的结论，矩阵若满足幂等条件 <spanclass="math inline">\(S^2 = S\)</span>，那么<spanclass="math inline">\(S\)</span>是投影矩阵。（并不是正交投影）</p></blockquote><p>因此，多重网格法求出的的修正项 <span class="math inline">\(E =Se\)</span> 并不是整个误差 <spanclass="math inline">\(e\)</span>，而是<spanclass="math inline">\(e\)</span>在<spanclass="math inline">\(S\)</span>的列空间上的投影，修正项和误差之间的差为<span class="math inline">\(e - E = (I - S)e\)</span>。我们将矩阵<spanclass="math inline">\(I- S\)</span>定义为网格算子（原文为Two-GridOperator，我的翻译水平实在是太烂了）。在分析步骤1、5时，矩阵<spanclass="math inline">\(M = I -P^{-1}A\)</span>起到了重要的作用，而在分析和描述多重网格的步骤2-4时，<spanclass="math inline">\(I-S\)</span>起到了举足轻重的作用。</p><p><span class="math display">\[\begin{aligned}  \text{v-cycle matrix} &amp;= I - S\\\text{iteration matrix} &amp;= I - P^{-1}A\end{aligned}\]</span></p><blockquote><p>Note:第一步和第五步分析实际上是指对于Jacobi、GS格式的分析，迭代法的误差通常都能写成<span class="math display">\[  e_{n+1} = e_n - P^{-1} A e_n\]</span> 的形式，例如 Jacobi 迭代（<span class="math inline">\(D =\mathrm{diag} A\)</span>）： <span class="math display">\[  x_{n+1} =  D^{-1}(b - R x_n)\quad \text{where}\quad A = D + R\]</span> “简单”计算可得： <span class="math display">\[  e_{n+1} = (I - D^{-1} A) e_n\]</span></p></blockquote><h3 id="例子续">例子（续）</h3><p>我们直接给出之前例子的<spanclass="math inline">\(S\)</span>矩阵如下：</p><p><span class="math display">\[S = \begin{bmatrix}   0 &amp; 1/2 &amp; 0 &amp; 0 &amp; 0\\   0 &amp;   1 &amp; 0 &amp; 0 &amp; 0\\   0 &amp; 1/2 &amp; 0 &amp; 1/2 &amp; 0\\   0 &amp;  0 &amp; 0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 0 &amp; 1/2&amp;0\end{bmatrix}\]</span></p><p>该矩阵的特征值是 <span class="math inline">\(1, 1,0,0,0\)</span>，也很容易验证<span class="math inline">\(S^2=S\)</span>。<span class="math inline">\(S\)</span>有三列为<spanclass="math inline">\(0\)</span>，这说明<spanclass="math inline">\(S\)</span>的零空间包含了具有形式<spanclass="math inline">\((e_1, 0, e_3, 0 ,e_5)\)</span>的细网格向量。这些向量不会出现在粗网格上。如果误差<spanclass="math inline">\(e\)</span>有这种形式，那么<spanclass="math inline">\(E = Se =0\)</span>，即多重网格法不能消除这样的误差。但是这样的误差实际上是高频的，它很容易在细网格上使用迭代求解器消除。</p><blockquote><p>Note：这里的“这样的向量不会出现在粗网格上”原文为 “Those are vectorsthat don’t appear on the coarse grid.”</p><p>作者表达的意思并不是说这些误差向量不会体现到粗网格上，而是说粗网格是无法消除这些误差向量。这听起来很奇怪是吧？</p></blockquote><p><span class="math inline">\(S\)</span> 的列空间由<spanclass="math inline">\(S\)</span>的第二、四列的向量张成，即<spanclass="math inline">\((1/2, 1, 1/2, 0, 0)\)</span>和<spanclass="math inline">\((0, 0, 1/2, 1,1/2)\)</span>。它们是“混合频率”的分量，这些分量在第一步（SmoothStep，即细网格上的迭代求解步）不能很好的从误差中消除，从而会在<spanclass="math inline">\(e\)</span>中出现。但这些向量被<spanclass="math inline">\(E = Se =e\)</span>“捕捉”到，在第四步更新解后被消除。</p><h2 id="多重网格对高低频分量的影响">多重网格对高/低频分量的影响</h2><p>我们换一种说法来表述这个过程。因为 <span class="math inline">\(S^2 =S\)</span>，因此特征值只有<span class="math inline">\(\lambda = 0,\lambda=1\)</span>。我们的例子中，<span class="math inline">\(\lambda =1, 1, 0, 0, 0\)</span>，而<span class="math inline">\(I-S\)</span>的特征值为 <span class="math inline">\(0, 0, 1, 1, 1\)</span>（<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(I-S\)</span>有相同的特征向量）下面讨论多重网格法对某个特征向量<spanclass="math inline">\(e\)</span>的操作。</p><blockquote><p>Note：特征向量组就是原本空间的一组基，误差可以在这组基下分解，然后考虑各个分量在多重网格法下如何变化。</p></blockquote><p><strong>对于 <span class="math inline">\(E = Se = 0\)</span>的特征向量</strong>：多重网格法并不能解决误差中的这些分量。这些误差分量对应的修正项<spanclass="math inline">\(E\)</span>为零。在上面的例子中，对应了 <spanclass="math inline">\(e = (e_1, 0, e_3, 0,e_5)\)</span>的情况，多重网格计算的修正项<spanclass="math inline">\(E=0\)</span>，也就是无法修正这些误差分量。</p><p><strong>对于 <span class="math inline">\(E = Se = e\)</span>的特征向量</strong>：多重网格法对于这种向量能够“完美地”消除。在算法的第四步中<spanclass="math inline">\(E = e\)</span> 添加到 <spanclass="math inline">\(u_h\)</span>上，这些误差被完全消除了！在我们的例子中，这对应了<spanclass="math inline">\(e = (1, 2, 2, 2, 1)\)</span> 和 <spanclass="math inline">\(1 2 0 -2 1\)</span>。这些都具有较大的低频的分量，只上下“摆动”一两次。它们位于<spanclass="math inline">\(I_{2h}^h\)</span>的列空间中。它们不完全是低频率的正弦函数（不单纯是一个谐波），但作为低频误差的一个重要部分，被捕获并消除。</p><p><span class="math inline">\(Se =e\)</span>的解空间维数是粗网格点的数量（在这里为2）。它表征了第三步求解的<spanclass="math inline">\(A_{2h}\)</span>（的规模）。它是 <spanclass="math inline">\(S\)</span> 的秩，也是<spanclass="math inline">\(I_{2h}^h\)</span>的秩。其他 <spanclass="math inline">\(5 − 2\)</span> 个网格点组成了 <spanclass="math inline">\(S\)</span> 的零空间， 如上文分析的，<spanclass="math inline">\(E = Se = 0\)</span>表明多重网格并不消除这些分量，即对这些误差分量没有改进（改进解的精确程度）。</p><blockquote><p>放下原文体会一下： The other <span class="math inline">\(5-2\)</span>grid points account for the nullspace of <spanclass="math inline">\(S\)</span>, where <span class="math inline">\(E =Se = 0\)</span> means no improvement from multigrid.</p></blockquote><p>备注：满足<span class="math inline">\(Su =0\)</span>的“高频分量”<span class="math inline">\((u_1, 0, u_3, 0,u_5)\)</span>并不是三个离散正弦序列（这在后面的Fourier分析会考虑）。严谨的说法是，<spanclass="math inline">\(I_{2h}^h\)</span> 的列空间等于 <spanclass="math inline">\(S\)</span>的列空间，而<spanclass="math inline">\(S\)</span>的零空间是<spanclass="math inline">\(RA\)</span>的零空间。尽管我们分析的向量是混合频率的，但这并不影响多重网格法核心出发点：<strong>用迭代器求解消除高频分量，用多重网格法消除低频分量。</strong></p><blockquote><p>Recall：多重网格法将低频分量转化为粗网格上的高频分量，再迭代求解器消除。</p></blockquote><p>如果我们的迭代求解器能够完美地消除误差的高频分量，而多重网格能够消除剩下的低频分量，那么一个v-cycle就会求出精确解！但这再现实中显然是不可能的。幸运的是如果我们仔细分析可以发现，一次v-cycle能够将误差固定地缩小一个常数倍，并且这个常数是<strong>与网格密度<spanclass="math inline">\(h\)</span>无关的</strong>：</p><p><span class="math display">\[\| e&#39; \| \le \rho \| e \| \quad \rho &lt; 1\]</span></p><p>通常这里的 <span class="math inline">\(\rho =0.1\)</span>（类似数量级），相比的Jacobi迭代只能做到<spanclass="math inline">\(\rho = 0.99\)</span>。这简直是数值分析的峰顶（HolyGrail of numerical analysis）！多重网格法方法的收敛因子<spanclass="math inline">\(\rho\)</span>与 <spanclass="math inline">\(h\)</span>的选取无关，这说明它不会像别的方法一样有 <spanclass="math inline">\(\rho \rightarrow 1, (h \rightarrow0)\)</span>。我们可以在固定次数的循环后，就能达到给定的相对误差（事先估计）。因为每一步都只需要<spanclass="math inline">\(O(n)\)</span>次数的迭代（，因此它总体是<spanclass="math inline">\(O(n)\)</span>复杂度的，它并不直接随着<em>矩阵维数</em>的上升而上升。</p><blockquote><p>收敛因子：迭代矩阵的谱半径（a spectral radius of the overalliteration matrix）</p><p>Note：不管是插值、限制，还是Jacobi迭代、GS的迭代的一步，都是<spanclass="math inline">\(O(n)\)</span>的，这里的<spanclass="math inline">\(n\)</span>说的是稀疏系统的规模，例如非零元素个数。</p><p>Note：网格点数为<spanclass="math inline">\(n\)</span>的情况下，矩阵规模是<spanclass="math inline">\(n \times n\)</span>的（有<spanclass="math inline">\(n^2\)</span>个自由度，这里的矩阵维数说的是<spanclass="math inline">\(n^2\)</span>），但实际上非零元素的个数是<spanclass="math inline">\(O(n)\)</span>的（不管是有限元还是有限差分法都是）</p><p>Recall：Jacobi迭代对于<span class="math inline">\(n\timesn\)</span>矩阵是需要<spanclass="math inline">\(O(n^2)\)</span>次收敛。</p></blockquote><p>关于迭代次数和精度的关系还有一点可以补充。用户可能希望数值解的误差和方程离散引入的误差相同。之前的例子中，我们的二阶差分是2阶精度的，因此希望<spanclass="math inline">\(e = O(h^2) =O(N^{-2})\)</span>。这意味着我们多次（而非固定次数）的v-cycle来达到精度要求。为了达到<span class="math inline">\(\rho^{k} = O(N^{-2})\)</span>的精度，通常需要 <span class="math inline">\(k = O(\log N)\)</span>次循环（执行 <span class="math inline">\(k\)</span> 次v-cycle，总复杂度为<span class="math inline">\(O(N \logN)\)</span>）。多重网格法也能很好地处理这个问题。</p><p>除了多次执行v-cycle，或者将他们嵌套在一起称为 V-Cycle 或W-Cycle，一种更好的方案是使用<strong>全多重网格</strong>（FullMultigrid, i.e. FMG）。这些循环都在下一章中介绍。对于我们需要的<spanclass="math inline">\(O(h^2)\)</span>精度，FMG方法的复杂度是<spanclass="math inline">\(O(n)\)</span>的。</p><h2 id="v-cyclesw-cyclesfmg">V-Cycles/W-Cycles/FMG</h2><p>我们之前对于第三步的求解方法不加以限制。显而易见的是我们可以在原本的v-cycle第三步也执行类似的多重网格法。举个栗子，我们在第三步仅仅使用了Jacobi迭代，原本的最低频分量的频率（尽管频率提升了一倍）还是低的。但如果不断地进行v-cycle，那么这些分量能在<spanclass="math inline">\(4h\)</span>、<spanclass="math inline">\(8h\)</span>等等，以至于非常粗的网格上得到消除（例如<spanclass="math inline">\(512h\)</span>）。</p><p>我们有一个很自然的选择，将多层网格划分为多层的（例如3层，左下图），它先不断加粗网格到<spanclass="math inline">\((2h, 4h, 8h)\)</span>上，然后直接逐层返回到<spanclass="math inline">\((4h, 2h, h)\)</span>上。这个嵌套的 v-cycle序列就是一个V-cycle（大写V）。需要注意的是，在<strong>更粗的网格上的矩阵求解是更快的</strong>。一些分析指出，我们可以花费稍多一点的时间在粗网格上是值得的。我们构造了如下中图的W-cycle，它能够消除更多的低频分量，通常相较于V-cycle有更好的结果。</p><figure><img src="image-20231010132617154.png" alt="各类方法的递归过程" /><figcaption aria-hidden="true">各类方法的递归过程</figcaption></figure><p>FMG方法“渐进”地优于的V/W-cycle，如右上图所示。它<strong>从最粗的网格出发</strong>，先算出<spanclass="math inline">\(8h\)</span>上的解， 然后插值到<spanclass="math inline">\(4h\)</span>上，来获得<spanclass="math inline">\(4h\)</span>上的一个求解初值，这个初值应当接近于<span class="math inline">\(4h\)</span> 的解。然后执行一次<spanclass="math inline">\(4h\)</span>和<spanclass="math inline">\(8h\)</span>的v-cycle，来提升<spanclass="math inline">\(4h\)</span>网格上解的精确性。然后再将<spanclass="math inline">\(4h\)</span>的解插值到<spanclass="math inline">\(2h\)</span>上，进行相同的过程，直到得到我们所需要的解。我们得到了<spanclass="math inline">\(h\)</span>的求解初值后，只需要执行一次V-cycle，这是因为FMG的前序计算给了它一个很好的初值。</p><blockquote><p>Note：联系微分方程的数值解，粗网格上的解为细网格上的求解提供了良好的初值。</p><p>Note：从FMG计算的流程不难推断，其为<spanclass="math inline">\(h\)</span>网格提供的初值，相应的低频误差很“少”。</p></blockquote><p>尽管V-cycle（或其他的两个算法，但我们只分析V-cycle）总操作数多于v-cycle，但它们只相差一个常数倍。这是因为每当我们切换到更粗一倍的网格的时候，我们求解的规模也随之降低一半。对于一个维度为<spanclass="math inline">\(d\)</span>的微分方程，粗网格上的问题规模是细网格的<spanclass="math inline">\(1/2^d\)</span>。下面的公式大致估计了V-cycle的复杂度：<span class="math display">\[V &lt; (1 + \frac{1}{2^d} + \left(\frac{1}{2^d}\right)^2 + \cdots )v&lt; \frac{2^d}{2^d - 1} v\]</span> 其中的<spanclass="math inline">\(V\)</span>表示V-cycle的操作数，<spanclass="math inline">\(v\)</span>表示v-cycle的操作数。使用类似的记号，用<spanclass="math inline">\(F\)</span>表示FMG的操作数，类似的有： <spanclass="math display">\[F &lt; \frac{2^d}{2^d - 1} V &lt; \left(\frac{2^d}{2^d - 1}\right)^2 v\]</span>顺便一提的是，FMG方法在实际应用的多，但需要你有比较好的编程能力。</p><h2 id="多重网格法的矩阵">多重网格法的矩阵</h2><p>原本一次v-cycle的我们给出了矩阵<spanclass="math inline">\(S\)</span>来刻画误差的变化，对于一个三层的V-cycle，我们也希望有一个相应的矩阵<spanclass="math inline">\(S_3\)</span>来刻画误差的变化。在这里分析时，我们不考虑平滑（Smoothing）的影响。<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(S_3\)</span>只是将原本的问题投影到更粗的网格上而已。就其本身而言，如果没有平滑步的情况下<spanclass="math inline">\(S_3\)</span>并不是一个好的求解器。</p><blockquote><p>Note：解释一下这里的平滑（Smoothing）的含义。考虑一个三层的V-Cycle：1. <span class="math inline">\(h\)</span>-Iterate 2. <spanclass="math inline">\(h\rightarrow 2h\)</span>-Restrict: 3. <spanclass="math inline">\(2h\)</span>-Solve(also a v-cycle): 1. <spanclass="math inline">\(2h\)</span>-Iterate <strong>Smoothing</strong> 2.<span class="math inline">\(2h\rightarrow 4h\)</span>-Restrict 3. <spanclass="math inline">\(4h\)</span> Solve 4. <spanclass="math inline">\(4h \rightarrow 2h\)</span>-Interpolate 5. <spanclass="math inline">\(2h\)</span>-Iterate <strong>Smoothing</strong> 4.<span class="math inline">\(2h\rightarrow h\)</span>-Interpolate 5.<span class="math inline">\(h\)</span>-Iterate</p><p>我们在分析的时候，为了方便起见，认为误差并没有经过<spanclass="math inline">\(2h\)</span>-Iterate的两步，否则整个分析过程会变的相当复杂。与此同时，如果我们考虑的是那些非常低频的分量（因为只有这些分量会被更粗的网格解决），<spanclass="math inline">\(2h\)</span>-Iterate也几乎不对这些分量产生影响。</p></blockquote><p>在最外层的第三步求解的问题实际上是<spanclass="math inline">\(A_{2h}E_{2h}=r_{2h}\)</span>，我们只需要重新利用<spanclass="math inline">\(A_{2h}^h= RA_hI\)</span>这样的公式就能得到：</p><p><span class="math display">\[A_{4h} = R_{2h}^{4h} A_{2h} I_{4h}^{2h}\]</span></p><p>其中的<span class="math inline">\(R_{2h}^{4h}\)</span>将<spanclass="math inline">\(2h\)</span>网格点限制到<spanclass="math inline">\(4h\)</span>上，反过来，<spanclass="math inline">\(I_{4h}^{2h}\)</span>将<spanclass="math inline">\(4h\)</span>网格点插值到<spanclass="math inline">\(2h\)</span>上。如果我们选择的网格密度为<spanclass="math inline">\(h=1/16\)</span>，那么这个矩阵乘法是 <spanclass="math inline">\((3\times 7) (7\times 7)(7\times3)\)</span>的。在<spanclass="math inline">\(4h\)</span>的网格上，求解规模为<spanclass="math inline">\(3\times3\)</span>的问题<spanclass="math inline">\(A_{4h} E_{4h} =r_4h\)</span>。然后再进行插值回到<span class="math inline">\(2h,h\)</span>的网格上。这一整套的<em>两次限制、求解、两次插值</em>用矩阵<spanclass="math inline">\(S_3 = S_3^2\)</span>表示（引入的修正项为<spanclass="math inline">\(E_{4h} = S_3 e_h\)</span>）。</p><p><span class="math display">\[S_3 = I_{2h}^{h}I_{4h}^{2h} A_{4h}^{-1} R_{2h}^{4h}R_{h}^{2h}A\]</span></p><p>和之前相同的分析，在一次不考虑平滑过程的V-cycle下，误差为<spanclass="math inline">\((I-S_3) e\)</span>。在<spanclass="math inline">\(h=1/16\)</span>的网格上，一共有15个不同的频率分量，只有最低的3个被<spanclass="math inline">\(S_3e\)</span>（大致上）消除。我们现在仅仅是求解了一个<spanclass="math inline">\(3\times3\)</span>的问题，考虑到在<spanclass="math inline">\(h\)</span>网格和<spanclass="math inline">\(2h\)</span>网格上的迭代步（Iterate），高频的和中间频率的误差分量都被这些迭代求解器消除了。</p><blockquote><p>TODO: 这里省去了原文的“数值试验”这一小节。</p></blockquote><h2 id="特征值分析">特征值分析</h2><p>读者可能已经意识到，一个矩阵（例如v-cycle的<spanclass="math inline">\(I-S\)</span>）就足以描述多重网格法中的一个步骤。而对于FMG方法，尽管我们希望能得到它的特征值和特征向量，但它们通常实在是难以求出。先前的数值试验的结果让我们对多重网格法充满信心。计算和实验给我们一种分析、改进（Diagnostic）的手段，来发现在哪里收敛得慢，需要作出一些改变（通常在边界条件上需要特殊处理）。我们也需要一个先验的预测工具，最好的就是模态分析（ModalAnalysis）。</p><p>本文分析的核心是观察 Fourier谐波在多重网格求解时的变化。在我们的例子中，考虑到零编制条件，我们选取离散的正弦波来分析。我们一直使用Poisson方程导出的问题（ModelProblem），来观察多重网格法矩阵<spanclass="math inline">\(I-S\)</span>对这些正弦波进行了如何的作用。这一小节的最终结果（从数学上）说明了为何多重网格法是有效的，也说明了两种频率分量是如何被混合的。即<spanclass="math inline">\(I-S\)</span>的特征向量是由两个谐波混合而来。</p><blockquote><p>Note: 频率为<span class="math inline">\(k\)</span>的正弦波是指：<span class="math display">\[  y(i) = \sin 2 \pi \frac{ik}{N}\]</span> 它能满足我们的零边值条件</p></blockquote><p>我们直接指出，混合在一起的分量是频率为<spanclass="math inline">\(k\)</span>和<spanclass="math inline">\(N-k\)</span>的（我们只考虑<spanclass="math inline">\(k \le N-k\)</span>的情况，这样<spanclass="math inline">\(k\)</span>始终是频率更低的）。写出两个频率的正弦波</p><p><span class="math display">\[\begin{aligned}  y_k &amp; = \left( \sin \frac{k\pi}{N}, \sin \frac{2k\pi}{N}, \cdots\right)\\  Y_k &amp; = \left( \sin \frac{(N-k)\pi}{N}, \sin \frac{2(N-k)\pi}{N},\cdots \right)\end{aligned}\]</span></p><p>其中 <span class="math inline">\(y_k\)</span> 在<spanclass="math inline">\(0,...,N\)</span>中经历了<spanclass="math inline">\(k\)</span>个周期，而 <spanclass="math inline">\(Y_k\)</span> 经历了<spanclass="math inline">\(N+1-k\)</span>个周期。列出这些值后，你不难发现一些有趣的现象（Thereis something neat you have to see）。<spanclass="math inline">\(Y_k\)</span>和<spanclass="math inline">\(y_k\)</span>的数字是相等的，不过是相差了一个符号：</p><p><span class="math display">\[\begin{aligned}Y_k &amp;= \left( \sin \left(\pi -\frac{-k\pi}{N}\right), \sin2\left(2\pi -\frac{-k\pi}{N}\right), \cdots \right)\\&amp;= \left(\sin \frac{k\pi}{N}, -\sin \frac{2k\pi}{N}, \cdots\right)\end{aligned}\]</span></p><p>对于我们的问题（二阶差分算子矩阵求解），我们可以观察它们乘以<spanclass="math inline">\(S =I(RAI)^{-1}RA\)</span>后的情况。但事实上，多重网格法对应的矩阵实际上是<spanclass="math inline">\((I-S)\)</span>，它给出了经过234步后误差和修正项之间的差<spanclass="math inline">\(e - E = (I-S)e\)</span>。所以我们直接观察<spanclass="math inline">\(I-S\)</span>的在低频正弦波<spanclass="math inline">\(y_k\)</span>和高频正弦波<spanclass="math inline">\(Y_k\)</span>上的作用：</p><p><span class="math display">\[\begin{aligned}  (I-S) y_k &amp;= \frac 1 2 \left(1- \cos \frac{k\pi}{N}\right) (y_k +Y_k)\\  (I-S) Y_k &amp;= \frac 1 2 \left(1+ \cos \frac{k\pi}{N}\right) (y_k +Y_k)\\\end{aligned}\]</span></p><p>对于v-cycle，我们能直接分析得到这个美妙的结果（Beautifulformula），但在更复杂的问题中是很难直接分析得到的。在此我们指出多重网格法的四个关键点：</p><ol type="1"><li><strong>误差的低频分量被多重网格很好地去除</strong>（例子中<spanclass="math inline">\(k=1,2,3\)</span>）：在上面的公式中，<spanclass="math inline">\(\cos\)</span>项是很接近<spanclass="math inline">\(1\)</span>的（因为低频分量<spanclass="math inline">\(k\ll N\)</span>），它大致是<spanclass="math inline">\(O((k/N)^2)\)</span>的。这说明多重网格法几乎消除了误差中所有的低频分量。这些分量就是在细网格上Jacobi/GS迭代器难以去除的部分。</li><li><strong>一对正弦波被多重网格法混叠</strong>：混叠是由<spanclass="math inline">\(R, I\)</span>矩阵带来的。它们不像<spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(A\)</span>是方阵（SquareMatrix），它能够将不同的频率分量分开（因为正弦波就是二阶差分算子的特征向量，就如正弦波是二阶导数算子的特征值一样）。对于一般的矩阵，会将不同的分量混叠在一起。</li><li><strong>两个频率混合得到的<span class="math inline">\(e = y_k +Y_k\)</span>是<spanclass="math inline">\(I-S\)</span>的特征向量，对应的特征值为<spanclass="math inline">\(1\)</span></strong>：我们将上面的式子直接相加就能得到这个结果。因为<spanclass="math inline">\(Y_k\)</span>和<spanclass="math inline">\(y_k\)</span>的唯一区别就是符号，那么<spanclass="math inline">\(y_k + Y_k\)</span>有<spanclass="math inline">\((e_1, 0, e_3, 0,...)\)</span>这样的形式。它们正是我们在之前找到的<spanclass="math inline">\(S\)</span>的零空间中的向量。因为<spanclass="math inline">\(Se = 0\)</span>，这些分量不被多重网格法解决。</li><li><strong><spanclass="math inline">\(I-S\)</span>的其他的特征向量是<spanclass="math inline">\(S y_k\)</span>，对应特征值为<spanclass="math inline">\(0\)</span></strong>：之前我们指出<spanclass="math inline">\(S^2 = S\)</span>，因此有<spanclass="math inline">\((I-S) Sy_k =0\)</span>。在我们的例子中，我们显式地求出了<spanclass="math inline">\(Sy_1\)</span>和<spanclass="math inline">\(Sy_2\)</span>，它们分别是<spanclass="math inline">\((1, 2, 2, 2, 1)\)</span>和<spanclass="math inline">\((1, 2, 0, -2,1)\)</span>的倍数。它们大多是一些低频分量，并且多重网格法将这些分量从误差中去除。</li></ol><p>根据这个公式，我们还能得到<span class="math inline">\(Sy_k\)</span>不过是<span class="math inline">\(y_k\)</span>和<spanclass="math inline">\(Y_k\)</span>的组合。为了找到更好的组合<spanclass="math inline">\(e ^ *\)</span>（这个<spanclass="math inline">\(e^*\)</span>被多重网格法完全消除）我们将这两个式子两边分别乘以<spanclass="math inline">\((1+\cos\frac{k\pi}{N})\)</span>和<spanclass="math inline">\((1-\cos\frac{k\pi}{N})\)</span>后相减，得到<spanclass="math inline">\(\boldsymbol{Se^* = e^*}\)</span></p><p><span class="math display">\[(I-S) e^* = (I-S) \left[ \left( 1+\cos \frac{k\pi}{N} \right) y_k -\left( 1- \cos \frac{k\pi}{N}\right)Y_k \right]=0\]</span></p><p>这个混合频率分量<spanclass="math inline">\(e^*\)</span>被多重网格法完全消除了（这对于所有的<spanclass="math inline">\(k \le N-k\)</span>都成立）。</p><p>总的来说，由第一步计算后得到的<em>光滑的</em>误差向量<spanclass="math inline">\(e_h\)</span>在<span class="math inline">\(y_k +Y_k\)</span>这个方向上只有一些很小的分量（因为细网格上的Jacobi迭代能够有效得消除误差的高频分量）。多重网格法并不会改变这个（小的）分量。更大的分量是沿着<spanclass="math inline">\(e^*\)</span>的，这些分量能被多重网格法完全消除。</p><blockquote><p>Note：为何在<span class="math inline">\(y_k +Y_k\)</span>上只有很小的分量，而沿着<spanclass="math inline">\(e^{*}\)</span>由更大的分量？</p><p>需要注意<span class="math inline">\(e^{*}\)</span>的表达式中，<spanclass="math inline">\(y_k\)</span>和<spanclass="math inline">\(Y_k\)</span>的系数。当<spanclass="math inline">\(k \ll N\)</span>时，有<spanclass="math inline">\(\cos \approx 1\)</span>，那么这个<spanclass="math inline">\(e^* \approx 2y_k\)</span>。如果考虑误差向量<spanclass="math inline">\(y=\lambda_1 y_k + \lambda_2 Y_k\)</span>用<spanclass="math inline">\(y_k+Y_k, e^*\)</span>表示，那么 <spanclass="math inline">\(y \approx  \frac12 (\lambda_1 -\lambda_2) e^{*} +\lambda_2（y_k+Y_k)\)</span>，于此同时，我们知道误差中的高频分量少，即<spanclass="math inline">\(\lambda_2\)</span>是很小的，这就能够印证上面的说法。</p></blockquote><h2 id="限制矩阵导致混叠">限制矩阵导致混叠</h2><p>为了让以上的分析更加完整，我们下面来看看一对频率分量是如何被混叠在一起的。这样的混叠现象产生于限制矩阵<span class="math inline">\(R=R_h\)</span>，它将<spanclass="math inline">\(y_k^h\)</span>和<spanclass="math inline">\(Y_k^h\)</span>映射到“相同”的向量（两向量是线性相关的）。</p><p><span class="math display">\[\begin{aligned}R y_k^h = \left( \frac{1}{2} - \frac{1}{2} \cos \frac{k\pi}{N}\right)y_k^{2h}\\R Y_k^h = \left( -\frac{1}{2} - \frac{1}{2} \cos \frac{k\pi}{N} \right)y_k^{2h}\end{aligned}\]</span></p><blockquote><p>Note：这里的上标表示的是不同网格下的正弦波。</p></blockquote><p>上面的公式直接指出了<spanclass="math inline">\(R\)</span>对不同频率的混叠。我们无法仅仅从输出中分析原本输入的向量是<spanclass="math inline">\(y_k\)</span>还是<spanclass="math inline">\(Y_k\)</span>（方程组欠定）。另一方面，如果我们直接观察<spanclass="math inline">\(R\)</span>的行、列数，这样的“欠定现象”对于一个矮、胖的矩阵是再常见不过的。在粗网格上的不同频率分量数目大致上只有细网格的一半。</p><blockquote><p>Note：这里说的不同频率分量的数目也就是其线性空间的维数。</p></blockquote><p>反过来，<span class="math inline">\(R^T\)</span>对输入的向量有与<spanclass="math inline">\(R\)</span>相反的作用。当<spanclass="math inline">\(R\)</span>将两个分量混合为一个的时候，插值矩阵以（混合后的）这一个频率分量作为输入，输出两个频率分量：</p><p><span class="math display">\[2 I_{2h}^h y_k^{2h} = \left(1+\cos \frac{k\pi}{N}\right)y_k^h -\left(1-\cos \frac{k\pi}{N}\right)Y_k^h\]</span></p><p>从这个公式中我们还能够看出，对一个粗网格上的一个向量插值会额外产生一个细网格上的高频分量。但是这个高频分量的振幅很小，因为<spanclass="math inline">\(\cos k\pi / N\approx 1\)</span>。</p><blockquote><p>Recall：这说明为何算法的第五步是必要的，为消除低频误差而采用的多重网格法（第2-4步）还会额外引入一个很小的高频分量，第五步就能够将这些分量再去除掉。下面对例子的分析也说明了这一点。</p></blockquote><h3 id="例子续-1">例子（续）</h3><p>我们直接指出，如果我们没有第1、5步的光滑过程，而反复执行第2-4步是没有任何作用的！考虑<spanclass="math inline">\(e = y_k + Y_k\)</span>误差，<spanclass="math inline">\((I-S)e = e\)</span>说明了它在整个2-4步的迭代后没有产生任何变化。只有在1、5步的光滑作用（SmoothingMatrix，即前文提到的<span class="math inline">\(M = I -P^{-1}A\)</span>）能够很好的将这些高频误差分量消除。</p><p>假设在第1、5步采用（单步的）加<span class="math inline">\(w =\frac{2}{3}\)</span>权的Jacobi迭代，即<span class="math inline">\(M = I- \frac{1}{3} A\)</span>，那么整个1-5步对应的矩阵为 <spanclass="math inline">\(M (I-S)M\)</span>，这个矩阵的特征值会决定了整个多重网格法的好坏。出乎意料的是（当然也是情理之中的），原本的例子中的<spanclass="math inline">\(5\times5\)</span>矩阵 <spanclass="math inline">\(M (I-S)M\)</span> 有三个特征值为<spanclass="math inline">\(1/9\)</span>！</p><blockquote><p>Note：矩阵特征值绝对值的最大值决定了其最多能将向量放大多少倍，也能说明至少缩小多少倍。</p><p>Recall： 矩阵的谱半径</p><p>Note：<spanclass="math inline">\((I-S)\)</span>的秩仅仅为3，所以剩下的特征值为0，整个矩阵的谱半径就是<spanclass="math inline">\(1/9\)</span>。</p><p>Note： 这里的矩阵<spanclass="math inline">\(M(I-S)M\)</span>是作用在误差上的，即经过完整的1-5步后，误差<spanclass="math inline">\(e\)</span>降低为<spanclass="math inline">\(M(I-S)Me\)</span>。</p></blockquote><p>这说明，原本<span class="math inline">\(I-S\)</span>矩阵<spanclass="math inline">\(\lambda = 1\)</span>的三个特征方向对应了<spanclass="math inline">\(M(I-S)M\)</span>矩阵的<spanclass="math inline">\(\lambda = 1/9\)</span>的特征方向。</p><p>如果我们不用多重网格法，<spanclass="math inline">\(M\)</span>的最大特征值（谱半径）为<spanclass="math inline">\(0.91\)</span>。这还只是在第1、5步只进行了一次光滑的效果（只进行了一次Jacobi迭代），采用更多次的光滑会带来更好的效果。</p><h2 id="fourier-模态分析">Fourier 模态分析</h2><p>这一节的分析，我们忽略零边界条件，而考虑更一般的情况。与此同时，我们考虑一个无穷大的网格。之前的问题中，零边界条件让我们只考虑了正弦波，而当边界条件消失，研究对象从原本的有限长的正弦波<spanclass="math inline">\(y_k\)</span>向量，变为无限长、任意频率的简谐波向量<spanclass="math inline">\(y_\omega\)</span>。通常用连续频率<spanclass="math inline">\(\omega\)</span>的复指数函数来表示（连续频率是指<spanclass="math inline">\(\omega\)</span>不必再是整的或是有理的）：</p><p><span class="math display">\[y_\omega = (\dots, e^{-2 i \omega}, e^{-i\omega}, 1, e^{i \omega}, e^{2i\omega}, \dots)\]</span></p><p>我们需要一个“无穷维的矩阵”<spanclass="math inline">\(K_\infty\)</span>来作用在这些无穷维的向量上。二阶差分格式<span class="math inline">\(-1, 2,-1\)</span><strong>永远会出现在每一行上</strong>。我们分析的关键是这样一个<spanclass="math inline">\(K_\infty矩阵的\)</span>的特征向量就是 <spanclass="math inline">\(y_\omega\)</span>，而与之对应的特征值是 <spanclass="math inline">\(\lambda = 2 - 2 \cos \omega\)</span>:</p><p><span class="math display">\[K_\infty y_\omega = (2 - 2 \cos \omega)y_\Omega\]</span></p><p>对于<spanclass="math inline">\(K_\infty\)</span>的作用的分析为我们提供了<spanclass="math inline">\(A_h\)</span>的作用的信息。同时，当我们切换到粗网格上，<spanclass="math inline">\(K_\infty\)</span>也告诉我们<spanclass="math inline">\(A_{2h}\)</span>的信息。</p><p>（在这种更广义的情况下）限制矩阵<spanclass="math inline">\(R\)</span>也会产生频率混叠，不同的是，现在混合的频率分量是<spanclass="math inline">\(\Omega\)</span>和<spanclass="math inline">\(\Omega +\pi\)</span>。这两个频率分量之间仅仅相差了一个符号，即<spanclass="math inline">\(e^{i\pi n} = (-1)^n\)</span>。这与我们之前对<spanclass="math inline">\(y_k, Y_k\)</span>的分析是一致的。</p><p>本节采用的Fourier分析自始至终都会对无穷序列<spanclass="math inline">\((I-S)y_\omega\)</span>和<spanclass="math inline">\((I-S)y_{\omega +\pi}\)</span>进行分析，整个过程在有穷维的情况是相仿的。对于有穷维情况的分析说明了为何多重网格法是有效的，这些推导过程对于无穷维的情况也是成立的。</p><p>你可能觉得这一节是不重要的，因为实际求解过程中不可能出现无穷维、没有边界的情况。但为何纯模态分析依然是重要的？这是因为这样的分析中，我们包含了所有的Fourier序列（原文：Itallows Fourier to work freely）！Poisson方程<spanclass="math inline">\(\mathrm{div}(c \cdot  \nabla u) =f\)</span>（例如守恒型方程的微分形式）在更一般的区域上是相当复杂的。但如果我们将<spanclass="math inline">\(c\)</span>限制维一个常数并且忽略所有的边界条件，这些“内部的特征向量”（InteriorEigenvectors）就是这些<span class="math inline">\(y_\omega, y_{\omega +\pi}\)</span>的组合。Fourier方法并不擅长求解带边值条件的问题，这为我们也留下了一个难题，即如何正确地处理边界。</p><h2 id="amg方法">AMG方法</h2><p>作为本章节（也是本文）的结尾，我们花一小部分介绍下代数多重网格法（AlgebraicMultigrid,AMG）。先前我们从一个实际的Poisson问题出发，研究了如何对于二阶差分方程采用多重网格进行求解。更一般的<spanclass="math inline">\(Au =b\)</span>问题中并不涉及“网格”的概念（There isno grid in thebackground）。原本多重网格法的一些重要概念需要在一般的问题中被定义出：<em>光滑向量、节点的邻接关系、粗网格</em>。前两个概念是显而易见的，但是由于我们没有网格，从<spanclass="math inline">\(A_h\)</span>得到<spanclass="math inline">\(A_{2h}\)</span>的方法是比较模糊的。</p><blockquote><p>Note：看作图的邻接矩阵，每一个非零的<span class="math inline">\(i,j\)</span>元素一定程度上表明节点<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>的“亲密程度”或是“流量”。</p></blockquote><ol type="1"><li><p><strong>光滑向量</strong>（Smooth vectors）：是指那些<spanclass="math inline">\(\| u \|\)</span>和<span class="math inline">\(\|Au\|\)</span>是同数量级（comparable）的向量。<spanclass="math inline">\(u\)</span>中的高频分量会被<spanclass="math inline">\(A\)</span>放大，就如同二阶微分/差分算子对于<spanclass="math inline">\(\sin k t\)</span>放大了<spanclass="math inline">\(k^2\)</span>倍那样。</p></li><li><p><strong>节点的邻接关系</strong>（Connectednodes）：在网格上，节点的邻接关系是由<spanclass="math inline">\(A\)</span>的非零元描述的。如果没有网格，我们直接观察矩阵，那些有较大影响的（significant）元素告诉我们<span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 之间是“邻接”的（例如 <spanclass="math inline">\(|A_{ij}|&gt; |A_{ii}|/10\)</span>）</p></li><li><p><strong>粗网格</strong>（Coarse subset of nodes <spanclass="math inline">\(C\)</span>）：每一个有较大影响的<spanclass="math inline">\(A_ij\)</span>都说明了<spanclass="math inline">\(u_j\)</span>对于<spanclass="math inline">\(u_i\)</span>有较大的影响。这意味着，<spanclass="math inline">\(e_j\)</span>和<spanclass="math inline">\(e_i\)</span>有很大概率是可比的的（comparable，同数量级的含义）。因此，对于<spanclass="math inline">\(e_i\)</span>和<spanclass="math inline">\(e_j\)</span>而言，我们不需要它们都出现在粗网格上。假设在细网格上两个点是邻接的，那么它们很可能不会都在出现在粗网格<spanclass="math inline">\(C\)</span>中。</p><p>例如，如果节点<span class="math inline">\(i\)</span>不在粗网格<spanclass="math inline">\(C\)</span>中，那么每一个、或至少一个对<spanclass="math inline">\(i\)</span>有很强影响的节点<spanclass="math inline">\(j\)</span>都应当在粗网格中。有一系列的启发式的规则、算法来选择粗网格中包含的节点。但总体上说，使用包含较多节点的粗网格通常优于包含较少节点的粗网格。</p></li></ol><p>书（W. SIAML. , 2000Briggs. , V. E. Henson, and S. F. McCormick. AMultigrid Tutorial.）中还给出了AMG方法的插值函数。它从在<spanclass="math inline">\(C\)</span>中的节点<spanclass="math inline">\(j\)</span>的误差<spanclass="math inline">\(E_j\)</span>开始分析，并使它们保持不变。如果<spanclass="math inline">\(i\)</span>不在 <spanclass="math inline">\(C\)</span>中，则多重网格法第二步插值时将会从对其有很大影响的节点<spanclass="math inline">\(j\)</span>处的<spanclass="math inline">\(E_j\)</span>加权组合获得。在我们的Poisson问题中，这样的加权组合就是节点两个邻居的平均值。这是因为我们的问题是有网格的！</p><p>对<spanclass="math inline">\(e_j\)</span>的插值组合方法会将最大的权重赋予对<spanclass="math inline">\(i\)</span>有最大影响的<spanclass="math inline">\(j\)</span>。但较小的那些元素也不能被完全忽略。换言之，最终采用插值的方法并不是简单的平均。这也说明AMG方法在计算成本比一般的多重网格法上是更加昂贵，但它能够适合更一般的稀疏矩阵求解（并且有软件可以控制AMG的行为，不需要我们烦心）。我们仍然希望“光滑+多重网格”的强强联手能够让AMG方法在<spanclass="math inline">\(O(n)\)</span>内收敛到<spanclass="math inline">\(Au = b\)</span>的精确解。</p><p>在此说一些题外话，对于固体力学和流体力学的计算之间有一个显著的差异：对于固体，原本的有限元网格相对而言是较粗的，通常我们寻求的是“工程上的精确”（EngineeringAccuracy），并没有很细节上的运动现象需要考虑。对结构问题而言，多重网格法并不是一个常用的方法（消元法更简单）。但流体力学不一样，流体通常有很多细小的运动（例如高雷诺数情况下的湍流）。不仅是从数值方法上还是物理含义上，多重网格法都成为了一个自然的选择。尽管由于对流项的存在、有限元方法的“迎风修正”（Upwindadjustment），一般的流体并不产生一个对称的矩阵。特别是当我们应用多尺度方法的时候，多重网格法的收敛分析随之变得更为复杂。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Numeric Methods </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
