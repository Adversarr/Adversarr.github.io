<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title> Calculus</title>
      <link href="//post/calculus-hs2st.html"/>
      <url>//post/calculus-hs2st.html</url>
      
        <content type="html"><![CDATA[<h1 id="calculus">00. Calculus</h1><h2 id="gauss-green-theorem">Gauss-Green Theorem</h2><h3 id="divergence-theorem">Divergence Theorem</h3><p>Suppose <span class="math inline">\(u \in C^1\)</span>,</p><p><span class="math display">\[\int_{U}^{}u_{x_{i}}\mathrm{d}x=\int_{\partial U}^{}u\nu^{i}\mathrm{d}S\]</span></p><p>where <span class="math inline">\(\nu\)</span> is the normal vectorof <span class="math inline">\(\partial U\)</span>. Therefore, wehave<strong>​ (Divergence Theorem)</strong></p><p><span class="math display">\[\int_U \mathrm{div}\mathbf u \mathrm dx = \int_{\partial U} \mathbf u\cdot \nu \mathrm dS\]</span></p><p>for each vector field.</p><h3 id="integration-by-parts">Integration by parts</h3><p>Let <span class="math inline">\(u, v\in C^1\)</span>, then</p><p><span class="math display">\[\int_{U}^{}u_{x_i} vdx = - \int_U u v_{x_i} dx + \int_{\partial U} u v\nu ^i dS\]</span></p><blockquote><p>Apply Divergence Theorem.</p></blockquote><h3 id="greens-formulas">Green’s Formulas</h3><p>Let <span class="math inline">\(u, v\in C^2\)</span>, then</p><p><span class="math display">\[\begin{cases}\int_{U}^{_{}}\Delta udx=\int_{\partial U}^{}\frac{\partialu}{\partial\nu}dS\\ \int_{U}^{}Dv\cdot Du\\mathrm{d}x=-\int_{U}^{}u\Delta vdx+\int_{\partial U}^{}\frac{\partialv}{\partial\nu}udS\\ \int_{U}^{}u\Delta v-v\Delta udx=\int_{\partialU}^{}u\cdot\frac{\partial v}{\partial\nu}-v\cdot\frac{\partialu}{\partial\nu}dS\end{cases}\]</span></p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>过一遍USTC-CG-2020 ppt</title>
      <link href="/2023/09/06/after-the-usstccg2020-ppt-csjjr/"/>
      <url>/2023/09/06/after-the-usstccg2020-ppt-csjjr/</url>
      
        <content type="html"><![CDATA[<h1 id="过一遍ustc-cg-2020-ppt">过一遍USTC-CG-2020 ppt</h1><h2 id="d图形光栅化">2d图形光栅化</h2><h3 id="d图像和光栅化显示器">2d图像和光栅化显示器</h3><p>图像是什么：rgb[][]</p><p>像素：图像的基本单元；</p><p>光栅：像素阵列；</p><p>像素构成的矩阵：</p><ul><li>每个元素就是片元（Frag）可能包含很多信息</li><li>片元被赋予了颜色，称为像素</li></ul><p>图像放缩的问题：插值、误差、SuperResolution</p><h3 id="d图形">2d图形</h3><p>有哪些呢：点、线、离散曲线、多边形区域</p><p>问题：如何光栅化几何图形？</p><h3 id="光栅化2d图形">光栅化2d图形</h3><h4 id="线段光栅化">线段光栅化</h4><p>主要是：</p><ol type="1"><li>dda算法：对于每个x画出最接近的y</li><li>bresenham：从一个像素，找出下一个可能的像素</li></ol><h4 id="多边形区域的光栅化">多边形区域的光栅化</h4><p>一个问题是：如何决定封闭多边形的内外？</p><ol type="1"><li>奇偶检测法，也就是射线法；</li><li>扫描线法</li></ol><p>​<img src="assets/image-20230906192323-r2ftj62.png" alt="image" />​</p><h4 id="光滑曲线光栅化">光滑曲线光栅化</h4><p>最简单的：圆的光栅化</p><p>具有八分对称性，因此只需要画出1/8的圆，然后镜像；</p><ul><li>中点法、Bresenham算法</li><li>正负判定法 → 判断<span class="math inline">\(F (x,y)\)</span>和0的大小关系，决定往哪个方向走</li></ul><p>一般曲线呢？分段线性逼近</p><p>隐函数呢？Hard！</p><h3 id="反走样-aa">反走样 aa</h3><p>走样 ⇒ 采样不足</p><p>Blur before sampling</p><p>使用低通滤波去除掉高频的信息</p><h3 id="图形v.s.图像">图形v.s.图像</h3><h2 id="数据拟合">数据拟合</h2><h3 id="拟合问题">拟合问题</h3><p>输入：观察数据点</p><p>输出：泛影这些数据的函数</p><p>两个方法：逼近、插值</p><p>如何求解：</p><ol type="1"><li><p>用什么函数？（完备的函数空间）</p></li><li><p>最小二乘拟合：L2、l2？选择什么函数空间？</p><ol type="1"><li>RBF（径向基函数）</li></ol></li><li><p>Lagrange 插值函数</p></li><li><p>Overfitting问题？</p></li></ol><p>联系Machine Learning：</p><ol type="1"><li>岭回归</li><li>稀疏学习 - 冗余的基函数</li><li>压缩感知</li></ol><h2 id="重心坐标">重心坐标</h2><h2 id="采样和网格划分">采样和网格划分</h2><p>1d 曲线采样：分段线性逼近</p><p>2d 曲面：分片线性</p><p>平面区域：</p><ol type="1"><li>规则采样：网格</li><li>不规则采样：三角化</li></ol><h3 id="d-delaunay-triangulation">2d delaunay triangulation</h3><p>Voronoi图</p><p>DT 的性质：</p><ol type="1"><li>最大化最小角</li><li>凸包</li><li>最小化图拉普拉斯矩阵的谱范数</li></ol><h3 id="mesh-generation">Mesh Generation</h3><p>如何采样？</p><p>CVT方法：centroidal voronoi tesselation</p><h2 id="meshes-ds-programming">Meshes: DS &amp; Programming</h2><h3 id="三维曲面">三维曲面</h3><h4 id="数学表达">数学表达</h4><ol type="1"><li>函数表达</li><li>参数表达</li></ol><p>如何画出曲面：离散化</p><p>多面体网格模型 - 每个面都是平面多边形</p><p>正多面体</p><h4 id="euler-公式">Euler 公式</h4><p><span class="math display">\[V + F - E = 2\]</span></p><h4 id="三角网格">三角网格</h4><p>基本元素：点、线、面</p><p>存储方法：Obj file</p><h4 id="topology">Topology</h4><p>洞 ⇒ 建立连续可逆的映射？</p><h3 id="mesh-ds">Mesh DS</h3><p>渲染：Triangle List, Trip, Fan …</p><p>几何：常见操作是加一个顶点、边，分裂顶点等</p><ol type="1"><li><p>存储上很难高效存储；</p></li><li><p>时间上呢？</p><ol type="1"><li>构建</li><li>查询：点相关的边、边相关的点……</li><li>更新</li></ol></li></ol><p>如何定义一个Mesh？</p><ul><li>Edge []</li><li>Vertex - Edge Relation</li><li>Vertex - Face Relation</li><li>Combined…</li></ul><h4 id="half-edge">Half edge</h4><p>半边数据结构的核心思想：用两个有向半边来取代原先的边。</p><h4 id="list-of-faces">List of faces</h4><p>好处：</p><ol type="1"><li>内存开销小</li><li>可以表示非流形的网格</li></ol><p>缺点：过于简陋，对于vf的操作复杂度高</p><h4 id="邻接矩阵">邻接矩阵</h4><p>直接用图论的方法</p><ol type="1"><li>查找顶点相关的边：O(1)</li><li>两个顶点是否相邻：O(1)</li><li>哪些面和顶点相邻：遍历所有的面</li></ol><p>缺点：面只和顶点保存联系，但与边不保存。</p><h4 id="dcel">DCEL</h4><p>本质上是HalfEdge DS</p><h2 id="discrete-differential-coordinates">Discrete DifferentialCoordinates</h2><p>Laplacian Coordinates</p><h3 id="mesh-surface">Mesh Surface</h3><p>本质上就是2d区域在三维中的“嵌入”</p><h4 id="cardinal-coordinates">Cardinal Coordinates</h4><p>欧式坐标，类似obj文件中的<code>v</code>​部分</p><h4 id="laplace-coord">Laplace Coord</h4><p>Detail = Surface - SmoothedSurface</p><p>= 自己的坐标 - 1ring neighbour的加权平均</p><p>几种可能：</p><ol type="1"><li>Uniform weight：所有1ring的权重相同，这个不考虑几何信息</li><li>Cotangent weight：考虑了几何信息</li></ol><p>为什么Laplace Coordinate重要：保持了变化率信息！</p><p>联想Poisson Image Editing。</p><p><span class="math display">\[L = I - D^{-1} A\]</span></p><p>​<img src="assets/image-20230908100237-zm1uiip.png" alt="image" />​</p><p>重建：从相对坐标重建绝对坐标。</p><p>本质是什么：好的<spanclass="math inline">\(w\)</span>能算出平均曲率！</p><p>​<img src="assets/image-20230908101238-erhx5pm.png" alt="image" />​</p><p>注意下面那个公式左边就直接取到<span class="math inline">\(\delta_i\)</span>​</p><p><span class="math display">\[\frac{1}{d}\sum_{v\in N}^{}\left(v_{i}-v\right)\approxH\left(v_{i}\right)n_{i}\]</span></p><h3 id="极小曲面">极小曲面</h3><p>平均曲率处处为0</p><p>如何生成？</p><h2 id="曲面参数化">曲面参数化</h2><p>问题是什么？给定3d中的曲面，嵌入到2d中</p><p>应用落地：纹理映射</p><blockquote><p>TODO</p></blockquote><h2 id="几何建模与处理">几何建模与处理</h2><p>几个需求：</p><ol type="1"><li>几何建模</li><li>曲面重建</li><li>曲面光顺</li><li>曲面简化</li><li>曲面编辑</li><li>曲面动画插值</li><li>……</li></ol><p>我看crj的课件里面似乎没有这些东西，但还是记录一下</p><h3 id="曲面重建">曲面重建</h3><p>输入：电晕</p><p>输出：2d manifold</p><p>主要两种方法：</p><ol type="1"><li><p>Explicit - 直接构建三角网格</p><ol type="1"><li>voronoi diagram</li><li>delaunay trianglation</li></ol></li><li><p>Implicit - 找某个函数的等值面，例如</p><ol type="1"><li>sdf、rbf重建</li><li>Poisson重建</li></ol></li></ol><p>隐式函数拟合方法 - 联系marching cube</p><h3 id="曲面光顺">曲面光顺</h3><p>从三维重建的物体通常是Noisy的 – 去除高频分量</p><p>Laplace Operator：1ring 的 Uniform weight</p><p>​<img src="assets/image-20230908104738-237suzq.png" alt="image" />​</p><p>Laplacian Smoothing Flow：</p><p><span class="math display">\[P_{new}\leftarrow P_{old}+\lambda L\left(P_{old}\right)\]</span></p><ul><li>相当于Box Filter，（信号处理领域）</li><li>应用到所有顶点上</li><li>重复多次</li><li>可以被描述为Energy Minimization</li></ul><p>当然，也可以用Mean Curvature做Flow</p><p>​<img src="assets/image-20230908105331-rju2yfm.png" alt="image" /></p><h3 id="网格简化">网格简化</h3><p>策略：删掉不重要的点、面、边，比如曲率的顶点等</p><h3 id="曲面编辑">曲面编辑</h3><p>如何生成满足用户交互的形变？</p><h4 id="free-form-deformation">Free-Form Deformation</h4><p>把物体嵌入到更加容易参数化的一个空间里面，然后对空间做形变</p><p>​<img src="assets/image-20230908105713-t1xzina.png" alt="image" />​</p><h4 id="axial-deformation">Axial Deformation</h4><p>沿着某个轴做形变</p><h4 id="detail-preserving">Detail Preserving</h4><p>几何细节是什么：Laplacian Coordinates</p><ol type="1"><li>Laplacian Mesh Editing：<span class="math inline">\(L x = \delta,x_j = c_j\)</span>​</li><li>Poisson Mesh Editing</li><li>Linear Rotation-Invariant Coordinates</li></ol><h3 id="mesh-morphing">Mesh Morphing</h3><p>生成动画，没咋讲啊。。</p><h2 id="计算机动画">计算机动画</h2><p>关键帧动画 - Morphing</p><p>两个子问题：</p><ol type="1"><li><p>匹配：两个关键帧之间的曲面如何相互映射？</p><ol type="1"><li>vertex matching</li><li>component matching</li></ol></li><li><p>插值：如何建立动画</p><ol type="1"><li>线性插值？</li><li>非线性- 小波插值？</li></ol></li></ol><h2 id="仿真算法">仿真算法</h2><p>太熟悉了，果断不看，列个提纲：</p><ol type="1"><li>牛顿第二定律</li><li>柔性物体：自身如何仿真、交互如何仿真，种类（布料、流体、刚体、弹性体……）</li><li>弹簧质点模型和隐式积分、Local-Global</li><li>FEM：这玩意就看着很复杂，直接套公式代码还是简单的</li><li>流体：FVM还是主流、还有SPH</li><li>IK、骨骼动画、数据驱动</li></ol><h2 id="渲染">渲染</h2><h3 id="三维物体的显示">三维物体的显示</h3><p>Render = 渲染和绘制</p><p>区分：光栅化图像、矢量图形</p><p>三维物体渲染？</p><p>成像原理：</p><ol type="1"><li>小孔成像</li><li>相机离散均匀采样</li></ol><p>像平面实际上没必要是真实的相机平面，可以虚拟到对称的平面上</p><h4 id="相机的指定">相机的指定</h4><p>外部参数：位置、旋转（6Dof刚体）</p><p>内部参数：焦距、胶卷尺寸</p><p>确定好参数后，可以定义一个透视投影，进行3d物体可视化</p><h4 id="d物体渲染">3d物体渲染</h4><p>基本的操作流程：</p><ul><li>输入：顶点</li><li>变换 T：顶点</li><li>光栅化：像素</li></ul><p>计算某个点到成像平面的位置</p><p>​<img src="assets/image-20230908112645-7eyqiw4.png" alt="image" />​</p><p>涉及到不同的坐标系，相互之间如何转化？</p><p>矩阵 + 齐次坐标</p><h2 id="渲染管线">渲染管线</h2><p>CPU - GPU - Framebuffer</p><p>两个最重要的阶段：</p><ol type="1"><li><p>几何</p><ol type="1"><li>3d模型投影变换到图像平面上</li><li>决定可见的图元</li></ol></li><li><p>光栅化</p><ol type="1"><li>决定可见的片元</li><li>决定片元的颜色，就是像素</li></ol></li></ol><p>基本的图元：点、线、三角（3d）</p><p>渲染管线：渲染的流水线</p><p>​<img src="assets/image-20230908113151-p4x8a9r.png" alt="image" />​</p><p>Vertex Shader - 顶点变换</p><p>Fragment Shader - 片元处理</p><p>​​<img src="assets/image-20230908113418-znadcmf.png" alt="image" />​</p><p>MVP变换分别：</p><ol type="1"><li>MV：Object → Eye</li><li>P：Eye → NDC</li></ol><p>并不是每一个都单独做的。</p><h3 id="顶点处理">顶点处理</h3><p>3d → 2d</p><p>拿opengl举例子，输出的是一个<code>gl_Position</code>​，但是vec4</p><ul><li>前俩坐标是 xy，基本就对应了2d的坐标</li><li>第三个坐标是z，表示深度坐标 - zbuffer</li><li>第四个坐标是齐次的系数，目的是用来处理透视投影的</li></ul><p>需要做什么的裁剪？</p><ol type="1"><li>视锥体裁剪</li><li>窗口裁剪</li><li>隐藏面消除</li></ol><p>屏幕空间变换：NDC到Screen，这个是机器自己做</p><h3 id="光栅化">光栅化</h3><p>逐顶点计算屏幕坐标：</p><ul><li>模型 → 图元 → 片元</li></ul><p>真正的“着色”器开始发挥作用，计算光照等信息</p><h3 id="着色">着色</h3><p>信息从顶点插值。</p><ol type="1"><li>Flat shading - 对每个三角形着色</li><li>Gourand Shading - 对每个 vertex 着色</li><li>Phong Shading - 对每个Fragment着色</li></ol><p>其实也可以在Vertex Shader中做着色，本质上是算出了每一个Vertex的颜色。</p><h2 id="opengl">Opengl</h2><p>两种管线：可编程、不可编程</p><p>这个图的2和3步是不是反掉了，</p><blockquote><p>​<imgsrc="https://www.khronos.org/opengl/wiki_opengl/images/RenderingPipeline.png"alt="Rendering Pipeline Flowchart" /></p><p><ahref="https://www.khronos.org/opengl/wiki/File:RenderingPipeline.png">https://www.khronos.org/opengl/wiki/File:RenderingPipeline.png</a></p></blockquote><p>​<img src="assets/image-20230908140825-xihblgg.png" alt="image" />​</p><p>需要注意看清楚各个阶段都是啥。</p><ol type="1"><li><p>buffer：position、attributes</p><ol type="1"><li>也有 uniform buffer：存储全局数据</li></ol></li><li><p>vertex shader：投影计算，法向量变换、归一化、逐顶点的光照</p><p>按照Opengl的流水线，后面还有两个可能的，可编程的着色器：</p><ol type="1"><li>Tessellation：曲面细分</li><li>Geometry Shader：输出更多图元</li></ol></li><li><p>图元装配：之前的计算都只是对于顶点操作的，不设计到点之间的拓扑关系</p><blockquote><p>其实OpenGL 网站上写的很清楚：Primitive assembly takes the vertexstream and converts it into a sequence of primitives, in accord with the<a href="https://www.khronos.org/opengl/wiki/Primitive"title="Primitive">Primitive</a> type specified in the rendering command.Primitives can also be discarded at this point, to allow transformfeedback without rendering anything.</p></blockquote><ol type="1"><li>生成图元，点、线、三角面都在这里生成</li><li>面剔除在这个阶段发生</li><li>其实OpenGL的Culling是分阶段的，现在是认为装配后再进行culling，这里的culling主要是上面提到的面剔除和这里的视锥体对应的剔除</li><li>Viewport Transform：ndc ⇒viewport，这个是通过<code>glViewport</code>​指定的</li><li>Perspective Divide：透视除法</li></ol></li><li><p>光栅化（Rasterization）没啥好说的，这个是硬件实现的，它的英文也很简单易懂</p><p>所有的数值都是线性插值出来的</p><p>输入是图元，输出是片元</p><p><strong>Rasterization</strong> is the process whereby each individual****​<strong>​ is broken down into discrete elements called</strong> <ahref="https://www.khronos.org/opengl/wiki/Fragment"title="Fragment">Fragments</a>, based on the sample coverage of theprimitive.</p></li><li><p>片元着色器，从片元输出颜色</p><p>它的输出不是直接的像素，因为一个像素可能会有多个fragment决定（Blending）</p></li><li><p>Framebuffer，也就是OpenGL的Per-Sample Processing：</p><p>这里实际上就直接要从片元数据决定像素了</p><p>这里也进行纹理映射 – sampler，纹理坐标是从buffer中一路传过来的</p><ol type="1"><li><a href="https://www.khronos.org/opengl/wiki/Scissor_Test"title="Scissor Test">Scissor Test</a></li><li><a href="https://www.khronos.org/opengl/wiki/Stencil_Test"title="Stencil Test">Stencil Test</a></li><li><a href="https://www.khronos.org/opengl/wiki/Depth_Test"title="Depth Test">Depth Test</a></li><li><a href="https://www.khronos.org/opengl/wiki/Blending"title="Blending">Blending</a></li><li><a href="https://www.khronos.org/opengl/wiki/Logical_Operation"title="Logical Operation">Logical Operation</a></li><li><a href="https://www.khronos.org/opengl/wiki/Write_Mask"title="Write Mask">Write Mask</a></li></ol></li></ol><p>其实也没有很复杂对吧！但你要注意每个阶段的输入输出是啥，例如像素是在最后阶段才被决定的，并不是从fragmentshader出来就是像素。</p><p>其实这里ppt讲的就不太对了，后面的混合啥的都是不可编程的阶段，和FS无关了。</p><p>逐片元操作的一些应用：</p><ol type="1"><li>隐藏面消除、阴影绘制</li><li>模版缓存 - multipass</li><li>混合 – 透明物体</li><li>多重采样、MSAA之类的</li></ol><p>下面我们主要讲一下光照模型</p><h2 id="光照">光照</h2><p>其实就是fragment shader怎么写</p><p>Phong 模型：三部分，其中前两个还需要注意距离光源远近</p><ol type="1"><li>diffuse：漫反射只需要考虑这个物体接受了光源多少光，所以是<spanclass="math inline">\(\langle l, n\rangle\)</span></li><li>specular：高光是和<span class="math inline">\(\langle reflect(l,n),v\rangle\)</span>相关的，通常还需要变成<spanclass="math inline">\(\alpha\)</span>次方的操作；</li><li>ambient：没啥好说的，固定值 * 材质</li></ol><p>看下答案：</p><p><span class="math display">\[\begin{cases}I_{d}=kI_{l}\langle l,n\rangle\\ I_{s}=k_{s}I_{l}\langler,n\rangle\\ I_{a}=k_{a}I_{a}\end{cases}\]</span></p><p>​<img src="assets/image-20230908150342-c71tr0z.png" alt="image" />​</p><p>Blinn-Phong：其中比较难算的是<spanclass="math inline">\(r\)</span>向量，可以用</p><p><span class="math display">\[n \cdot h \approx v\cdot r,\quad h = \mathrm{norm}(l+v)\]</span></p><p>来近似。</p><p>不难观察出<span class="math inline">\(r\cdotv\)</span>得到的角和<span class="math inline">\(n \cdoth\)</span>得到的角是两倍的关系。</p><h2 id="纹理映射">纹理映射</h2><p>三种映射方法：</p><ol type="1"><li>纹理映射</li><li>环境贴图</li><li>凹凸贴图</li></ol><p>参数坐标-纹理坐标-世界坐标-屏幕坐标</p><p>​<img src="assets/image-20230908151612-wofd1fq.png" alt="image" />​</p><p>基本问题：如何定义映射</p><h3 id="mipmap">MipMap</h3><p>产生摩尔纹：</p><ul><li>远处的一个像素覆盖纹理上的一个很大的区域，不能直接采样一个点的颜色。</li><li>近处呢？</li></ul><h3 id="opengl中的纹理">OpenGL中的纹理</h3><p>三个步骤：</p><ol type="1"><li>指定纹理</li><li>每个顶点赋予纹理坐标</li><li>纹理参数</li></ol><p>gl自带了mipmap的生成。</p><h3 id="环境映射">环境映射</h3><p>球面映射、立方体映射</p><h3 id="凹凸贴图">凹凸贴图</h3><p>​<img src="assets/image-20230908153320-pcftm3n.png" alt="image" />​</p><h2 id="真实感渲染">真实感渲染</h2><p>终于到RayTracing了。</p><h3 id="复习local-shading-model">复习：Local Shading Model</h3><p>不足：</p><ol type="1"><li>过于简化的反射模型 – 复杂材质怎么办？</li><li>间接反射光？</li><li>阴影？</li></ol><h3 id="全局光照">全局光照</h3><h4 id="brdf">BRDF</h4><p>几个参数？3+2+2</p><p>描述了啥？某个位置上，从入射方向打来光，对给定方向射出多少</p><h4 id="radiance---辐射率">Radiance - 辐射率</h4><p>5d函数，描述了物体<span class="math inline">\(x\)</span>位置，向<spanclass="math inline">\(w\)</span>射出的能量</p><h4 id="渲染方程">渲染方程</h4><p>Out = Emit + Reflect</p><p><span class="math display">\[L(x, w) = L_e(x, w)+\int_{w_i} L_i (x, w_i) f(x, w_i \to w)\langle n_x,w_i \rangle dw_i\]</span></p><p>Really Important!</p><h3 id="求解渲染方程">求解渲染方程</h3><p>递归过程！</p><h2 id="ray-tracing">Ray Tracing</h2><p>反向追踪：从像素透射出光线</p><h3 id="ray-casting">Ray casting</h3><p>假设光线只反弹一次。</p><p>打出去一条线，找chit，然后看是否被遮挡。</p><p>这个只能处理阴影！</p><h3 id="whitted-styleray-tracing">（Whitted-Style）Ray Tracing</h3><p>这个是递归的，打到的时候做两件事：</p><ol type="1"><li>看光源，如果不被遮挡就做Shading</li><li>在镜面反射方向继续打出一条光，递归该过程</li></ol><p>终止条件：</p><ol type="1"><li>rmiss → 背景光强</li><li>递归步数限制</li></ol><p>来默写一下这个算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rtrace</span>(<span class="params">ray, step</span>):</span><br><span class="line">  <span class="keyword">if</span> step &gt; max_step:</span><br><span class="line">    <span class="keyword">return</span> zero</span><br><span class="line">  r = scene.query(ray)</span><br><span class="line">  <span class="keyword">if</span> rmiss:</span><br><span class="line">    <span class="keyword">return</span> bg_color</span><br><span class="line">  <span class="keyword">elif</span> light:</span><br><span class="line">    <span class="keyword">return</span> light_color</span><br><span class="line">  <span class="keyword">else</span>: <span class="comment"># chit</span></span><br><span class="line">    local = phong_model()</span><br><span class="line">    reflect = trace(reflect_ray, step + <span class="number">1</span>)</span><br><span class="line">    transmit = trace(transmit_ray, step + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> local + reflect + transmit</span><br></pre></td></tr></table></figure><p>效率：</p><ol type="1"><li>求交 - 空间数据结构加速</li></ol><h2 id="path-tracing">Path Tracing</h2><p>上面并没有求解渲染方程。</p><ol type="1"><li>只算了至多三条光路：直接到光源的、镜面反射、折射</li><li>就算考虑多条光路呢？没用，phong模型要换</li></ol><p>如何求，直接给出最终算法！</p><p>Path Tracing：蒙特卡洛积分！</p><ul><li>一个像素 → N个光线</li><li>每个光线生成1条光路，着色</li><li>N条平均</li></ul><p>像是光的粒子性，我们考虑一个光的粒子是如何来到眼睛里的。它撞到表面上就会随机得向一个方向反射。</p><p>蒙特卡洛积分的原理是：设计一个随机变量<spanclass="math inline">\(X\)</span>，概率密度为<spanclass="math inline">\(p\)</span>：</p><p><span class="math display">\[E[I] = E[f/p] = \int f/p \cdot pdx=I\]</span></p><h3 id="pt-的具体算法">PT 的具体算法</h3><p>先把这个算法简单实现一下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shade</span>(<span class="params">p, wo</span>):</span><br><span class="line">  direction = random_direction(wi_PDF)</span><br><span class="line">  trace(p, direction)</span><br><span class="line">  <span class="keyword">if</span> light:</span><br><span class="line">    <span class="keyword">return</span> L_i * fr * cosine / pdf(wi)</span><br><span class="line">  <span class="keyword">elif</span> chit:</span><br><span class="line">    <span class="keyword">return</span> shade(hit, -wi) * f_r * cos / pdf(wi)</span><br></pre></td></tr></table></figure><p>never stop？</p><ol type="1"><li>RR，注意添加存活概率为<spanclass="math inline">\(p\)</span>的RR后，要让输出都除以<spanclass="math inline">\(p\)</span>，保持期望不变</li><li>添加最大递归次数</li></ol><p>最后一个问题！直接采样效率太低了，光源要单独拿出来采样。</p><p>分开直接光照和间接光照，直接光照不用递归。</p><p>本质上<code>shade(p, wo)</code>​只是在求解给定点<code>p</code>​对方向<code>wo</code>​的出射光的密度</p><p>关键是，这里需要在光源x’采样和球面x采样上做一个转换：</p><p><span class="math display">\[\cos\theta\mathrm{d}A=\|x-x^{\prime}\|^2dw\]</span></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">light_sample</span>(<span class="params">p, wo</span>):</span><br><span class="line">  Uniformly sample the light, pdf = <span class="number">1</span>/A</span><br><span class="line">  L_dir = L_i * f_r * cos theta cos theta2 / |x - p|**<span class="number">2</span> / pdf_light</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">p, wo</span>):</span><br><span class="line">  RR()</span><br><span class="line">  L = light_sample(p, wo)</span><br><span class="line">  ray = random(pdf)</span><br><span class="line">  query(ray)</span><br><span class="line">  <span class="keyword">if</span> rhit:</span><br><span class="line">    L += shade(q, -wi) * f_r * cos / pdf(wi) / P_RR</span><br><span class="line">  <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><h2 id="radiosity-辐射度渲染法">Radiosity 辐射度渲染法</h2><p>假设大家都是理想的漫反射表面，Render Eq：</p><p><span class="math display">\[L = L_e + K L\]</span></p><p>K是一个积分算子，线性，那么就是稀疏矩阵</p><p><span class="math display">\[(I-K)L=L_e \implies L = (I-K)^{-1}L_e =(I + K + K^2+ \cdots) L_e\]</span></p><p>好处：快</p><p>缺点：不是漫反射咋办。</p><h2 id="real-time-rendering">Real time Rendering</h2><p>主要都是些前沿的技术了</p><ol type="1"><li>光照贴图</li><li>阴影贴图</li><li>预计算</li></ol><p>原理上都是以存代算</p><h2 id="变换">变换</h2><p>没啥好说的，道理我都懂，但是我选择背书。</p><h2 id="cagd">CAGD</h2><p>Nurbs</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>共轭空间</title>
      <link href="/2023/08/23/common-space-z1vqyye/"/>
      <url>/2023/08/23/common-space-z1vqyye/</url>
      
        <content type="html"><![CDATA[<h1 id="共轭空间">共轭空间</h1><h2 id="共轭空间的表示和应用">共轭空间的表示和应用</h2><h3 id="共轭空间-1">共轭空间</h3><ul><li>定义：连续线性泛函全体，按照算子范数构成B空间；</li><li>Note：不要求原本的空间是B空间，仅仅是B*空间</li></ul><p>例如：</p><ol type="1"><li><span class="math inline">\(L^p\)</span>的共轭空间是<spanclass="math inline">\(L^q\)</span>：首先因为Holder不等式成立，因此可以定义积分变换为连续线性泛函，另外，这样的变换构成了连续线性泛函全体；</li><li><span class="math inline">\(C[ 0, 1]\)</span>的共轭空间<spanclass="math inline">\(BV[0,1]\)</span>（有界变差函数）</li></ol><p>回顾Riesz定理，有更加一般的情况：</p><p>Theorem（Riesz表示定理）：设<spanclass="math inline">\(M\)</span>是一个Hausdorff紧空间，则<spanclass="math inline">\(\forall f \inC(M)^*\)</span>，存在唯一的复值Baire测度（即一个完全可加的集函数）<spanclass="math inline">\(\mu\)</span>，满足<spanclass="math inline">\(\mu(M)&lt; \infty\)</span>，并</p><p><span class="math display">\[\langle f, \varphi \rangle = \int_M \varphi(m) d\mu\]</span></p><p>作为Riesz定理和Theorem（Hahn-Banach）的应用：</p><p>Theorem（Runge）：设<spanclass="math inline">\(K\)</span>是复平面上的一个紧子集，令<spanclass="math inline">\(C_\infty = C \cup \{ \infty \}\)</span>，并且<spanclass="math inline">\(E\)</span>是<span class="math inline">\(C_\infty\backslash K\)</span>中的一个子集，它与<spanclass="math inline">\(C_\infty \backslashK\)</span>中的每一个分量都相交，如果<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(K\)</span>的一个邻域内的任意解析函数，则一定存在有理函数列<spanclass="math inline">\(f_n\)</span>，其极点都在<spanclass="math inline">\(E\)</span>内，并且<spanclass="math inline">\(f_n\)</span>在<spanclass="math inline">\(K\)</span>上一致收敛到<spanclass="math inline">\(f\)</span>.</p><h3 id="第二共轭空间自反空间">第二共轭空间、自反空间</h3><p>因为B*空间的共轭空间是B空间，我们考虑共轭空间的共轭空间，即<spanclass="math inline">\(X^{ ** }\)</span>。对于任意的<spanclass="math inline">\(x\in X\)</span>定义：</p><p><span class="math display">\[X(f) = \langle f, x\rangle\]</span></p><p>不难验证 <span class="math inline">\(X\)</span> 是<spanclass="math inline">\(X^*\)</span>上的连续线性泛函，这是因为 <spanclass="math inline">\(|X(f)|=|f(x)|\le \| f\| \cdot \| x\|\)</span>​</p><p>令这样的从<span class="math inline">\(X\)</span>到<spanclass="math inline">\(X^{**}\)</span>的映射为<strong>自然映射</strong>​<spanclass="math inline">\(T\)</span>，它是从<spanclass="math inline">\(X\)</span>到<spanclass="math inline">\(X^{**}\)</span>的连续嵌入，并且这个映射是一个线性同构。</p><p>应用Theorem（Hahn-Banach），存在<span class="math inline">\(f\inX^*\)</span>使得<span class="math inline">\(\| f \| = 1\)</span>且<spanclass="math inline">\(\langle f, x\rangle = \| x \|\)</span>，因此</p><p><span class="math display">\[X(f) = \|x \|\]</span></p><p>从而<span class="math inline">\(\| X \| =\|x\|\)</span>，这表明了<spanclass="math inline">\(T\)</span>还是等距的。</p><p>Theorem：B*空间<spanclass="math inline">\(X\)</span>与它的第二共轭空间的一个子空间等距线性同构。</p><blockquote><p>因此，有时我们不区分<span class="math inline">\(x\)</span>和<spanclass="math inline">\(X\)</span>，并简单写成<spanclass="math inline">\(X \subset X^{**}\)</span>​</p></blockquote><p>Definition（自反空间）：如果<spanclass="math inline">\(X\)</span>到<spanclass="math inline">\(X^{**}\)</span>的自然映射是满的</p><h2 id="共轭算子">共轭算子</h2><blockquote><p>共轭算子的概念可以看作有穷维空间中，转置矩阵的推广。</p></blockquote><p>这要利用：</p><p><span class="math display">\[\langle y, Ax \rangle = \langle A ^ * y, x\rangle\]</span></p><p>我们用共轭空间来定义共轭算子。</p><ul><li><p>定义：对于B*空间<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>以及算子<span class="math inline">\(T :X \to Y\)</span>，共轭算子定义为<span class="math inline">\(T^*: Y ^ *\to X ^ *\)</span>：</p><p><span class="math display">\[f(Tx) = (T^*f)(x)\]</span></p></li><li><p>这样：<span class="math inline">\(\langle f , Tx \rangle =\langleT^* f, x\rangle\)</span></p></li><li><p>这样的共轭运算<span class="math inline">\(T \rightarrowtailT^*\)</span>是一个等距同构；</p></li></ul><p>对于这样的共轭，我们参考前一节，再考察<spanclass="math inline">\(T^{**}\)</span>：（假设自然映射<spanclass="math inline">\(U:X \to X^{**}\)</span>，以及<spanclass="math inline">\(V : Y \to Y^{**}\)</span>）</p><p><span class="math display">\[\langle T^{**} U x, f\rangle = \langle U x, T^* f\rangle =\langle T^* f,x\rangle = \langle f, Tx\rangle = \langle V Tx, f\rangle\]</span></p><p>因此 <span class="math inline">\(T ^ {**} U = VT\)</span>，即<spanclass="math inline">\(T ^ {**}\)</span>是<spanclass="math inline">\(T\)</span>在<span class="math inline">\(X^{**}\)</span>上的扩张。</p><p>Theorem：设<span class="math inline">\(X, Y\)</span>是B*空间，<spanclass="math inline">\(T\)</span>是连续线性算子，那么<spanclass="math inline">\(T^ { * *}\)</span>是<spanclass="math inline">\(T\)</span>在<spanclass="math inline">\(X^{**}\)</span>上的咽唾，并满足<spanclass="math inline">\(\| T^{**} \| = \| T \|\)</span></p><blockquote><p>例如，我们考虑卷积算子以及它的共轭算子：</p><ul><li><span class="math inline">\((K * f)(x) = \int _{-\infty}^{\infty}K(x - y) f(y ) dy\)</span></li><li>首先<span class="math inline">\(K ^*\)</span>是<spanclass="math inline">\(L^p\)</span>到自身的游街线性算子；</li><li>令 <span class="math inline">\(\hat K (x) =K(-x)\)</span>，由Fubini定理，<spanclass="math inline">\(T=K*\)</span>的共轭算子是<spanclass="math inline">\(T^* = \hat K *\)</span>​</li></ul></blockquote><h2 id="弱收敛和弱收敛">弱收敛和弱*收敛</h2><p>有穷维和无穷维的B空间的根本区别之一是：</p><ul><li>有穷维B空间中的任意有界点列一定存在收敛子列，</li><li>无穷维则不一定</li></ul><p>我们可以考虑弱收敛和弱*收敛，作为这条定理的推广</p><h3 id="弱收敛">弱收敛</h3><ul><li>定义：弱收敛<span class="math inline">\(x_{n}\rightharpoonupx\)</span>是指，对于任意的<spanclass="math inline">\(f\)</span>，都有<span class="math inline">\(\lim_{n \to \infty} f(x_n) = f(x)\)</span>成立</li><li>Prop：如果弱极限存在，那么弱极限是唯一的，强极限如果存在，那么弱极限存在且就是强极限</li></ul><p>Theorem（Mazur）设<spanclass="math inline">\(X\)</span>是一个B*空间，并且<spanclass="math inline">\(x_n\)</span>弱收敛到<spanclass="math inline">\(x\)</span>，那么</p><p><span class="math display">\[\forall\varepsilon&gt;0,\exists\lambda_{i}\ge0,\sum_{i}\lambda_{i}=1,s.t.\left\|x_0-\sum_{i}\lambda_{i}x_{i}\right\|\le\varepsilon\]</span></p><blockquote><p>若不然，那么<span class="math inline">\(x_0\)</span>不属于<spanclass="math inline">\(x_i\)</span>构成的凸包的闭包。考虑Ascoli定理可知，<span class="math inline">\(\exists f,\alpha, f(x)&lt;\alpha&lt; f(x _ 0), \forall x\)</span>，即与弱收敛矛盾。</p></blockquote><p>既然X*也是B空间，那么X*上自然也有两种收敛性。所谓的弱收敛<spanclass="math inline">\(f_n \rightharpoonup f\)</span>是指，</p><p><span class="math display">\[\forall x^{**} \in X^{**}\quad x^{**} (f_n)\rightharpoonup x^{**}(f)\]</span></p><p>为了避免讨论<spanclass="math inline">\(X^{**}\)</span>定义**弱*收敛**为：</p><ul><li>定义：设<span class="math inline">\(X\)</span>是B*空间，<spanclass="math inline">\(f_n , f \in X^*\)</span>，称<spanclass="math inline">\(f_n\)</span>弱*收敛到<spanclass="math inline">\(f\)</span>记作<span class="math inline">\(w ^ * -\lim_{n\to \infty} f_n = f\)</span>，是指对于所有的<spanclass="math inline">\(f \in X\)</span>，<spanclass="math inline">\(\lim_{n \to \infty} f_n(x) =f(x)\)</span>，称<span class="math inline">\(f\)</span>是泛函序列<spanclass="math inline">\(\{ f_n \}\)</span>的弱*极限。</li><li>如果X是一个自反空间，那么弱*收敛和弱收敛是等价的</li></ul><p>Theorem：设<span class="math inline">\(X\)</span>是B*空间，设<spanclass="math inline">\(x_n, x\in X\)</span>，那么<spanclass="math inline">\(x_{n}\rightharpoonup x\)</span>，当且仅当</p><ol type="1"><li><span class="math inline">\(\| x_n \|\)</span>有界；</li><li>对<span class="math inline">\(X^*\)</span>中的一个稠密子集<spanclass="math inline">\(M^*\)</span>上的一切泛函<spanclass="math inline">\(f\)</span>都有<span class="math inline">\(\lim_{n\to \infty} f(x_n) = f(x)\)</span>​</li></ol><blockquote><p>应用Theorem（Banach-Steinhaus定理）将<spanclass="math inline">\(x_n\)</span>看作<spanclass="math inline">\(X^*\)</span>上的连续线性泛函。</p></blockquote><p>Theorem：设<spanclass="math inline">\(X\)</span>是一个B空间，以及<spanclass="math inline">\(f_n, f\in X^*\)</span>，为了<spanclass="math inline">\(f_n\)</span>弱*收敛到<spanclass="math inline">\(f\)</span>，当且仅当</p><ol type="1"><li><span class="math inline">\(\| f_ n\|\)</span>有界；</li><li>对<span class="math inline">\(X\)</span>中的某个稠密子集<spanclass="math inline">\(M\)</span>上的一切<spanclass="math inline">\(x\)</span>，都有<span class="math inline">\(f_n(x)\to f(x)\)</span>​</li></ol><p>此外，类似于连续线性泛函序列，对于连续线性算子序列，我们也考虑各种收敛性：</p><p>定义：设<span class="math inline">\(X,Y\)</span>是B*空间，以及其上的<span class="math inline">\(f_n, f \inL(X, Y)\)</span></p><ol type="1"><li>一致收敛是指<span class="math inline">\(\| T_n - T\| \rightarrow0\)</span>（考虑算子范数的定义）</li><li>强收敛是指<span class="math inline">\(\| (T_n - T)x\| \to 0, \forallx\in X\)</span>（对于每一个<spanclass="math inline">\(x\)</span>，点点收敛）</li><li>弱收敛是指<span class="math inline">\(\forall x \inX\)</span>，以及<span class="math inline">\(\forall f \inY^*\)</span>都有 <span class="math inline">\(f(T_n x) \tof(Tx)\)</span>​</li></ol><p>显然的是 一致收敛 ⇒ 强收敛 ⇒弱收敛，下面的例子说明了反过来的箭头是错误的：</p><ul><li>考察<span class="math inline">\(l^2\)</span>上的左移动算子<spanclass="math inline">\(T\)</span>，定义<span class="math inline">\(T_n =T^n\)</span>，是有界线性算子，其强收敛到<spanclass="math inline">\(0\)</span>，但并不一致收敛到<spanclass="math inline">\(0\)</span>​</li><li>考察<span class="math inline">\(l^2\)</span>上的右移动算子<spanclass="math inline">\(T\)</span>，定义<span class="math inline">\(T_n =T^n\)</span>，是有界线性算子，其弱收敛到<spanclass="math inline">\(0\)</span>，但不强收敛到<spanclass="math inline">\(0\)</span>​</li></ul><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hahn-Banach定理</title>
      <link href="//post/hahnbanach-theorem-1gjror.html"/>
      <url>//post/hahnbanach-theorem-1gjror.html</url>
      
        <content type="html"><![CDATA[<p>给定无穷维的线性赋范空间，问：</p><ul><li>是否存在不恒等于0的连续线性泛函？</li><li>是否这样的连续线性泛函是足够多的？（能够用于区分每一个元素）</li></ul><h2 id="线性泛函的延拓定理">线性泛函的延拓定理</h2><p>我们考虑均衡吸收的凸集，由它可以决定一个空间上的半模<spanclass="math inline">\(p\)</span>，我们试图从<spanclass="math inline">\(p\)</span>来产生<spanclass="math inline">\(X\)</span>上的非零连续线性泛函：</p><p><span class="math display">\[X_0 = \{ \lambda x_0 : \lambda \in K\}, f_0(\lambda x_0) = \lambdap(x_0)\]</span></p><p>那么，<span class="math inline">\(f_0\)</span>是<spanclass="math inline">\(X_0\)</span>上的连续线性泛函，并且满足有界性条件</p><p><span class="math display">\[| f(x_0) | \le | \lambda p(x_0)| = p(\lambda x_0)\]</span></p><p><strong>Theorem（实数域上的Hahn-Banach定理）</strong>设<spanclass="math inline">\(X\)</span>是实线性空间，<spanclass="math inline">\(p\)</span>是定义在<spanclass="math inline">\(X\)</span>上的线性泛函，<spanclass="math inline">\(X_0\)</span>是<spanclass="math inline">\(X\)</span>的实线性子空间，<spanclass="math inline">\(f_0\)</span>是<spanclass="math inline">\(X_0\)</span>上的实线性泛函，并满足<spanclass="math inline">\(f_0 &lt; p\forall x \in X_0\)</span>，那么<spanclass="math inline">\(X\)</span>上一定有一个实线性泛函<spanclass="math inline">\(f\)</span>满足：</p><ol type="1"><li>受<span class="math inline">\(p\)</span>控制：<spanclass="math inline">\(f(x) \le p(x) \forall x\in X\)</span>​</li><li>延拓条件：<span class="math inline">\(f|_{X_0} = f_0\)</span></li></ol><p><strong>Theorem（复数域上的Hahn-Banach定理）</strong>设<spanclass="math inline">\(X\)</span>是复线性空间，<spanclass="math inline">\(p\)</span>是定义在<spanclass="math inline">\(X\)</span>上的半模，<spanclass="math inline">\(X_0\)</span>是<spanclass="math inline">\(X\)</span>的线性子空间，<spanclass="math inline">\(f_0\)</span>是<spanclass="math inline">\(X_0\)</span>上的线性泛函，并满足<spanclass="math inline">\(|f_0| &lt; p\forall x \in X_0\)</span>，那么<spanclass="math inline">\(X\)</span>上一定有一个实线性泛函<spanclass="math inline">\(f\)</span>满足：</p><ol type="1"><li>受<span class="math inline">\(p\)</span>控制：<spanclass="math inline">\(|f(x)| \le p(x) \forall x\in X\)</span></li><li>延拓条件：<span class="math inline">\(f|_{X_0} = f_0\)</span></li></ol><p>从这两个定理可以得到：</p><ul><li>为了复线性空间上至少有一个非零的线性泛函，只要<spanclass="math inline">\(X\)</span>中有一个均衡、吸收的凸集</li></ul><p>在B*空间上，可以更进一步：</p><p><strong>Theorem（Hahn-Banach）</strong>设<spanclass="math inline">\(X\)</span>是B*空间，<spanclass="math inline">\(X_0\)</span>是<spanclass="math inline">\(X\)</span>的线性子空间，<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(X_0\)</span>上的有界线性泛函，则在<spanclass="math inline">\(X\)</span>上有<spanclass="math inline">\(f\)</span>的保范延拓。</p><p>推论：</p><ol type="1"><li>每个B*空间都有足够多的连续线性泛函；</li><li>对于B*空间，对于一切非零元<spanclass="math inline">\(x\)</span>一定存在函数<spanclass="math inline">\(f\in X ^ *\)</span>，使得<spanclass="math inline">\(f(x_0) = \| x _ 0 \|\)</span> 且 <spanclass="math inline">\(\| f \| = 1\)</span>​</li></ol><p>回顾Hilbert空间，对于任意的连续线性泛函，有Riesz表示定理成立。现在我们考虑是否可能可以扩展到B*空间上：</p><p><strong>Theorem</strong>：设<spanclass="math inline">\(X\)</span>是B*空间，<spanclass="math inline">\(M\)</span>是<spanclass="math inline">\(X\)</span>的线性子空间，若<spanclass="math inline">\(x_0 \in X\)</span>，且<spanclass="math inline">\(d = \rho (x_0 ,M ) &gt;0\)</span>，则存在<spanclass="math inline">\(f \in X ^ *\)</span>适合：</p><ol type="1"><li><span class="math inline">\(f(x) = 0 \forall x \in M\)</span>​</li><li><span class="math inline">\(f(x_0) = d\)</span>​</li><li><span class="math inline">\(\| f\| = 1\)</span>​</li></ol><p>推论为：设<spanclass="math inline">\(M\)</span>是B*空间的一个子集，设<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(X\)</span>中的任一个非零元素，那么<spanclass="math inline">\(x_0 \in \overline{spanM}\)</span>当且仅当<spanclass="math inline">\(\forall f \in X^ * ,f(x) = 0(\forall x\inM)\)</span>蕴含了<span class="math inline">\(f(x_0) = 0\)</span></p><h2 id="几何形式-凸集分离定理">几何形式 —— 凸集分离定理</h2><p>在<spanclass="math inline">\(R^n\)</span>中，有凸集分离定理显然成立。</p><p>对应于<span class="math inline">\(n-1\)</span>维超平面的概念：</p><h3id="极大线性子空间极大线性流形超平面">极大线性子空间、极大线性流形、超平面</h3><ul><li>定义：以<spanclass="math inline">\(M\)</span>为真子集的线性子空间只有<spanclass="math inline">\(X\)</span>​</li><li>充要条件：<spanclass="math inline">\(M\)</span>是线性真子空间，并且对于任意的<spanclass="math inline">\(x_0\in X \backslash M\)</span>有<spanclass="math inline">\(X=\{\lambda x_0\|\lambda\in R^1\}\oplusM\)</span>​</li></ul><p>Note：超平面是平面上一般直线的推广：直线可以由一个线性函数<spanclass="math inline">\(a x + by =c\)</span>表示，超平面可以由线性泛函<span class="math inline">\(f(x) =r\)</span>来表示。</p><p><strong>Theorem</strong>：为了<spanclass="math inline">\(L\)</span>是线性空间上的一个闭超平面，必须其仅须存在非零的线性泛函<spanclass="math inline">\(f\)</span>和<span class="math inline">\(r \inR\)</span>，使得<span class="math inline">\(L = H_f^r = \{ f(x) = r\}\)</span>.</p><h3 id="超平面分离定理">超平面分离定理</h3><ul><li><p>超平面分离的定义？<span class="math inline">\(f(E) \le r \lef(F)\)</span></p></li><li><p>思路：先考虑可以分离凸集和空间中的一固定点<spanclass="math inline">\(x_0\)</span></p><ul><li>若<span class="math inline">\(E\)</span>是<spanclass="math inline">\(X\)</span>中以<spanclass="math inline">\(\theta\)</span>为内点的真凸子集，那么其Minkowski泛函<spanclass="math inline">\(p(x)\)</span>是一个非零的连续次线性泛函</li><li>空间中不在凸集内的点都满足<span class="math inline">\(p(x) \ge1\)</span>，因此在一维线性空间<span class="math inline">\(\{ \lambda x_0\}\)</span>上定义连续线性泛函<span class="math inline">\(f_0 (\lambdax_0 ) = \lambdap(x_0)\)</span>，根据Theorem（Hahn-Banach）可知，存在<spanclass="math inline">\(X\)</span>上的连续线性泛函，使得<spanclass="math inline">\(f(x_0) = f_0(x_0) = p(x_0) \ge 1, f(x) \lep(x)\)</span>​</li></ul></li></ul><p><strong>Theorem（Hahn-Banach定理-几何形式）</strong>：设<spanclass="math inline">\(E\)</span>是实B*空间上以<spanclass="math inline">\(\theta\)</span>为内点的真凸子集，设<spanclass="math inline">\(x_0 \bar \in E\)</span>那么存在超平面<spanclass="math inline">\(H _ f ^r\)</span>分离<spanclass="math inline">\(x_0\)</span>和<spanclass="math inline">\(E\)</span>​</p><p><strong>Theorem（凸集分离定理）</strong>：设<spanclass="math inline">\(E_1,E_2\)</span>为B*空间中互不相交的非空凸集，其中 <spanclass="math inline">\(E_1\)</span> 有内点，则存在超平面<spanclass="math inline">\(H_f ^ s\)</span>分离<spanclass="math inline">\(E_1, E_2\)</span>.</p><p>该定理有一系列推论：</p><ol type="1"><li>Ascoli 定理：设<spanclass="math inline">\(E\)</span>是实B*空间中的一个闭凸集，<spanclass="math inline">\(\forall x \in X \backslash E\)</span>存在<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(a\)</span>适合<span class="math inline">\(f(x)&lt; a &lt; f(x_0) \quad \forall x \in E\)</span>​</li><li>Mazur 定理：设<span class="math inline">\(E\)</span>是B*空间<spanclass="math inline">\(X\)</span>上的一个有内点的闭凸集，<spanclass="math inline">\(F\)</span>是<spanclass="math inline">\(X\)</span>上的一个线性流形，设<spanclass="math inline">\(\r{E}\capF=\emptyset\)</span>，那么存在一个包含<spanclass="math inline">\(F\)</span> 的闭超平面，使得<spanclass="math inline">\(E\)</span>在<spanclass="math inline">\(L\)</span>的一侧</li></ol><h2 id="应用">应用</h2><h3 id="抽象可微函数的中值定理">抽象可微函数的中值定理</h3><p>微商</p><ul><li>定义：<spanclass="math inline">\(\lim_{\delta\to0}\left(\frac{f\left(t+\delta\right)-f\left(t\right)}{\delta}\right)\)</span></li></ul><p><strong>Theorem：</strong>抽象函数<spanclass="math inline">\(f\)</span>若在<span class="math inline">\((a,b)\)</span>内可微，那么对于任意的<span class="math inline">\(t_1, t_2\in (a, b)\)</span>存在<span class="math inline">\(0 &lt; \theta &lt;1\)</span>使得中值定理成立：</p><p><span class="math display">\[\| f(t_2) - f(t_1) \|\le \| f&#39;(\theta t_2 + (1-\theta) t_1 )\| | t_2- t_1|\]</span></p><h3 id="凸优化问题的lagrange乘子">凸优化问题的Lagrange乘子</h3><p><strong>Theorem（Kuhn-Tuncker）</strong>：设<spanclass="math inline">\(X\)</span>是一个线性空间，<spanclass="math inline">\(C\)</span>是<spanclass="math inline">\(X\)</span>的一个凸子集，<spanclass="math inline">\(f, g_1, g_2, ..., g_n\)</span>是<spanclass="math inline">\(C\)</span>上的凸泛函，若<spanclass="math inline">\(x_0\)</span>是问题：</p><p><span class="math display">\[\min f(x)\quad s.t.\ g_i (x) \le 0\]</span></p><p>的解，那么一定存在非负实数<span class="math inline">\(\lambda_1, ...,\lambda _n\)</span>：</p><p><span class="math display">\[f(x_0)=\min\left\lbracef\left(x\right)+\sum_{i=1}^{n}\lambda_{i}g_{i}\left(x\right), x\inC\right\rbrace\quad \lambda_i g_i(x_0) = 0\]</span></p><h3 id="section"></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>纲和开映像定理</title>
      <link href="/2023/08/20/ganghe-enhancement-theorem-z1qvaow/"/>
      <url>/2023/08/20/ganghe-enhancement-theorem-z1qvaow/</url>
      
        <content type="html"><![CDATA[<h1 id="纲和开映像定理">纲和开映像定理</h1><h2 id="纲和开映像定理-1">纲和开映像定理</h2><p>有一大类方程求解问题，从泛函分析上看是，对于给定的 <spanclass="math inline">\(T\)</span> 算子，求得：</p><p><span class="math display">\[Tx = y\]</span></p><p>那么：</p><ol type="1"><li>解的存在性等同于算子存在右逆；</li><li>解的唯一性等同于算子存在左逆；</li></ol><blockquote><p>如果存在右逆：<span class="math inline">\(T(T_r^{-1} y)=y\)</span>那么 <span class="math inline">\(T_r^{-1} y\)</span> 是一个解</p><p>如果存在左逆：<span class="math inline">\(T_l^{-1}T(x-z)=0\impliesx=z\)</span>，那么解是唯一的</p></blockquote><p>在都存在的情况下，我们一般还需要考虑解的稳定性：</p><blockquote><p>稳定性：在定解条件作微小的变动时，相应的定解问题也只作微小的变动</p></blockquote><p>也就是 <span class="math inline">\(T^{-1}\)</span> 是连续的。<spanclass="math inline">\(T\)</span> ​将开集映射为开集。</p><h3 id="纲和纲推理">纲和纲推理</h3><p>和稠密子集、完备化空间的定义相联系，引入：</p><h4 id="疏集第一纲第二纲">疏集、第一纲、第二纲</h4><ul><li><p>定义：</p><ul><li><span class="math inline">\(E \subset X, \bar{E}\)</span>的内点是空的</li><li>第一纲：疏集的至多可数并</li><li>第二纲：其他</li></ul></li><li><p>例如：</p><ul><li>有穷点集是疏集</li><li>Cantor 集是疏集</li></ul></li><li><p>Prop：设有度量空间，为了 <span class="math inline">\(E\)</span>是疏集，当且仅当，<span class="math inline">\(\forall B(x_0, r_0),\exists B(x_1, r_1) \subset B(x_0, r_0),\bar E \cap \bar B (x_1, r_1) =\emptyset\)</span>​</p></li></ul><p>Theorem（Baire）：完备度量空间是第二纲的</p><ul><li>应用：在 <span class="math inline">\(C[0, 1]\)</span>中处处不可微的函数集合 <span class="math inline">\(E\)</span>是非空的，并且 <span class="math inline">\(E\)</span>的补集是第一纲的。</li></ul><h3 id="开映像定理">开映像定理</h3><p>假设有 B 空间 <span class="math inline">\(X, Y\)</span>，并且 <spanclass="math inline">\(T\in L(X,Y)\)</span>，T 可能满足一些性质：</p><ol type="1"><li>单射</li><li>满射</li><li>一一映射</li></ol><p>在是一一映射的情况下，我们自然要问 <spanclass="math inline">\(T^{-1}\)</span> 是否是有界线性算子。</p><p>Theorem：</p><ol type="1"><li><p>Banach 逆算子定理：设 <span class="math inline">\(X,Y\)</span> 是B 空间，并且存在<strong>一一的有界线性算子</strong> <spanclass="math inline">\(T\)</span>，那么 <spanclass="math inline">\(T^{-1}\)</span> 也是有界线性算子；</p></li><li><p>（更一般的结论是）</p><p>开映像定理：设 <span class="math inline">\(X, Y\)</span> 是 B空间，若<strong>有界线性算子</strong> <spanclass="math inline">\(T\)</span> 是满射，那么 <spanclass="math inline">\(T\)</span> 是开映像（将开集映射为开集）</p></li></ol><p>考虑第二个定理的证明方法：</p><ol type="1"><li><p>开映射 &lt;=&gt; 对于开球 <spanclass="math inline">\(B\)</span>，存在 <spanclass="math inline">\(\delta &gt; 0\)</span>，使得 <spanclass="math inline">\(U(\theta, \delta) \subset TB(\theta,1)\)</span></p><p>（Proof is easy，转化为只要证明，若 <spanclass="math inline">\(T\)</span> 是满射，那么 <spanclass="math inline">\(\theta\)</span> 在 TB 中是内点）</p></li><li><p>证明：<span class="math inline">\(\exists \delta &gt; 0,\overline{TB}\supset U(\theta, 3\delta)\)</span></p><ol type="1"><li><span class="math inline">\(Y\)</span> 是完备的，因此至少有一个<span class="math inline">\(n\in \mathbb N\)</span> 使得 <spanclass="math inline">\(TB\)</span> 非疏（<spanclass="math inline">\(TB\)</span> 存在内点）</li><li>记内点以及闭球为 <span class="math inline">\(U(y_0,r)\)</span>，由于 <span class="math inline">\(T\)</span> 线性，因此<span class="math inline">\(U(-y_0, r) \subset TB\)</span></li><li>因此 <span class="math inline">\(U(\theta , r) \subsetTB\)</span>​</li></ol></li><li><p>证明，<span class="math inline">\(TB(\theta, 1) \supset U(\theta,\delta)\)</span></p></li></ol><p>分析该证明过程，不难发现，线性算子的连续性可以减弱为</p><h4 id="闭算子">闭算子</h4><ul><li>定义：对于定义域中的<span class="math inline">\(\{ x_n\}\)</span>，<span class="math inline">\(x_n \in x\)</span>（<spanclass="math inline">\(x\)</span>可以不在定义域中）以及<spanclass="math inline">\(T x _ n \rightarrow y\)</span>，可以得到<spanclass="math inline">\(y = Tx, x\in D\)</span>​</li><li>Theorem：假设<span class="math inline">\(X, Y\)</span>是B空间，<spanclass="math inline">\(T\)</span>是一个闭线性算子，<spanclass="math inline">\(R(T)\)</span>是<spanclass="math inline">\(Y\)</span>中的第二纲集，那么：<spanclass="math inline">\(R(T) = Y\)</span>并且<spanclass="math inline">\(\forall \epsilon &gt; 0, \exists \delta = \delta (\epsilon ) &gt; 0\)</span>使得<span class="math inline">\(\forall y \inY, \| y \| &lt; \delta\)</span>，必有<span class="math inline">\(x \inD(T)\)</span>，适合<span class="math inline">\(\| x \| &lt;\epsilon\)</span>且<span class="math inline">\(y = Tx\)</span>​</li></ul><h3 id="闭图像定理">闭图像定理</h3><p>对于线性算子而言，我们观察其连续性和闭算子之间的关系：</p><blockquote><p>一个有界线性算子 <span class="math inline">\(T:D\rightarrowY\)</span>总能延拓到<span class="math inline">\(\bar D\)</span>上</p></blockquote><p>Theorem（B. L. T）：设<spanclass="math inline">\(T\)</span>是B*空间<spanclass="math inline">\(X\)</span>到B空间<spanclass="math inline">\(Y\)</span>的连续线性算子，那么<spanclass="math inline">\(T\)</span>能够唯一的延拓到<spanclass="math inline">\(\barD(T)\)</span>上，成为连续线性算子，并且保持其算子范数；</p><ul><li>Proof is eazy</li><li>意义：可以认为，每一个连续线性算子都有闭的定义域。因此，可以认为，一切连续线性算子都是闭算子。</li></ul><p>以下是一些推论：</p><ol type="1"><li><p>等价范数定理：假设线性空间上有两个范数，<spanclass="math inline">\(\| \cdot \| _1\)</span>和<spanclass="math inline">\(\| \cdot \|_2\)</span>，在这两个范数意义下都构成B空间，并且1比2强，那么1和2等价</p><ul><li>Proof：考虑恒等映射</li></ul></li><li><p>闭图像定理：设<span class="math inline">\(X,Y\)</span>是B空间，若<spanclass="math inline">\(T\)</span>是一个闭线性算子，并且<spanclass="math inline">\(D(T)\)</span>是闭的，那么<spanclass="math inline">\(T\)</span>是连续的；</p><ul><li>集合<spanclass="math inline">\(G\left(T\right)=\left\lbrace\left(x,Tx\right)\vertx\in D(T)\right\rbrace\)</span>称为算子<spanclass="math inline">\(T\)</span>的图像，因此<spanclass="math inline">\(\| \cdot\|_G\)</span>被称为图模，算子是闭的，实际上就是<spanclass="math inline">\(G(T)\)</span>按图模是闭的</li></ul></li></ol><h3 id="共鸣定理">共鸣定理</h3><p>Theorem（共鸣定理、一致有界定理）：设<spanclass="math inline">\(X\)</span>是B空间，<spanclass="math inline">\(Y\)</span>是B*空间，若：</p><p><span class="math display">\[W\subset L(X, Y)\quad s.t.\ \sup_{A \in W}\| Ax\|&lt; \infty (\forallx\in X)\]</span></p><p>那么存在常数<span class="math inline">\(M\)</span>使得<spanclass="math inline">\(\| A \| \le M, \forall A \in W\)</span>.</p><ul><li>注意区分条件和结论中的有界性；</li><li>反过来：<span class="math inline">\(\sup _{A \in W} \| A \| = \infty\implies \exists x_0 \in X, \sup \| A x _ 0 \| =\infty\)</span>（“共鸣”的由来）</li><li>定理给出条件，算子族<spanclass="math inline">\(W\)</span>如果对于<spanclass="math inline">\(x\)</span>点点有界，那么<spanclass="math inline">\(W\)</span>一致有界；</li></ul><p>另外：</p><p><strong>Theorem（Banach-Steinhaus定理）</strong>：设<spanclass="math inline">\(X\)</span>是B空间，<spanclass="math inline">\(Y\)</span>是B*空间，<spanclass="math inline">\(M\)</span>是<spanclass="math inline">\(X\)</span>的某个稠密子集，若<spanclass="math inline">\(A_n,A\)</span>是有界线性算子，则对于任意的<spanclass="math inline">\(x \in X\)</span>都有，<spanclass="math inline">\(\lim A_n x = Ax\)</span>，的充要条件是：</p><ol type="1"><li><span class="math inline">\(\| A_n \|\)</span>有界</li><li><span class="math inline">\(\lim A_n x = Ax\)</span>对每一个<spanclass="math inline">\(x\in M\)</span>都成立</li></ol><h3 id="应用">应用</h3><h4 id="lax-milgram定理">Lax-Milgram定理</h4><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Riesz定理及其应用</title>
      <link href="/2023/08/20/riesz-theorem-and-its-application-z2szy0r/"/>
      <url>/2023/08/20/riesz-theorem-and-its-application-z2szy0r/</url>
      
        <content type="html"><![CDATA[<h1 id="riesz定理及其应用">Riesz定理及其应用</h1><h2 id="riesz定理">Riesz定理</h2><p>对于Hilbert 空间 <spanclass="math inline">\(X\)</span>，定义线性算子：</p><p><span class="math display">\[f_{y}:x\rightarrowtail\left(x,y\right)\]</span></p><p>那么<span class="math inline">\(f_y \inX^*\)</span>，并且是有界的（CauchySchwartz不等式）。这个结论反过来也是对的：</p><p><strong>Theorem（Riesz）</strong>：设<spanclass="math inline">\(f\)</span>是Hilbert空间<spanclass="math inline">\(X\)</span>上的一个连续线性泛函，则必存在唯一的<spanclass="math inline">\(y_f \in X\)</span>使得</p><p><span class="math display">\[f(x) = (x, y_f)\]</span></p><blockquote><ol type="1"><li>几何意义：Hilbert空间中的连续线性泛函的等值面都是相互平行的超平面</li><li><span class="math inline">\(\|f\|=\|y_f\|\)</span>​</li></ol></blockquote><p><strong>Theorem: ​</strong>设<spanclass="math inline">\(X\)</span>是Hilbert空间，<spanclass="math inline">\(a(x, y)\)</span>是X上的共轭双线性函数，并且<spanclass="math inline">\(\exists M &gt; 0\)</span>使得</p><p><span class="math display">\[|a(x, y) | \le M \| x \| \| y\|\]</span></p><p>则存在唯一的<span class="math inline">\(A \in L(X)\)</span>使得</p><p><span class="math display">\[a(x, y) = (x, Ay)\]</span></p><p>并且</p><p><span class="math display">\[\|A\|=\sup_{(x,y)\in X\times X,x,y\ne\theta}\frac{|a|}{\|x\|\|y\|}\]</span></p><h2 id="应用">应用</h2><h3 id="laplace-方程的dirichlet边值问题的弱解">Laplace方程的Dirichlet边值问题的弱解</h3><p>对于Laplace方程的D边值问题：</p><p><span class="math display">\[\begin{cases}-\Delta u=f\\ u\left|_{\partial\Omega}\right.=0\end{cases}\]</span></p><p>弱解是指：</p><p><span class="math display">\[-\int_{\Omega}\nabla u\cdot\nabla vdx=\int_{\Omega}^{}fvdx\quad \forallv\in H_0^1(\Omega)\]</span></p><p><strong>Theorem:​</strong>对于任意的L2可积函数，该问题的弱解存在且唯一。</p><ul><li>Idea：定义<span class="math inline">\((u, v) = \int_\Omega \nabla u\cdot \nabla v dx\)</span> 为Hilbert空间上的内积</li></ul><h3 id="变分不等式">变分不等式</h3><p><strong>Theorem：</strong>设<spanclass="math inline">\(C\)</span>是<spanclass="math inline">\(H_0^1\)</span>中的闭凸子集，若<spanclass="math inline">\(f\inL^2(\Omega)\)</span>，则下面的不等式存在唯一解：</p><p><span class="math display">\[\int_{\Omega}^{}\nablau_0^{\ast}\cdot\nabla\left(v-u_0^{\ast}\right)\mathrm{d}x\ge\int_{\Omega}f\cdot\left(v-u_0^{\ast}\right)\mathrm{d}x\]</span></p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性算子和线性泛函</title>
      <link href="/2023/08/18/linear-operator-and-linear-general-w8ece/"/>
      <url>/2023/08/18/linear-operator-and-linear-general-w8ece/</url>
      
        <content type="html"><![CDATA[<h2 id="线性算子的概念">线性算子的概念</h2><p>线性算子和线性泛函的定义</p><ul><li>线性算子：两个线性空间中的线性映射</li><li>线性泛函：值域包含于<span class="math inline">\(\mathbbR\)</span>或<span class="math inline">\(\mathbb C\)</span>​</li></ul><p>例子：</p><ol type="1"><li>矩阵对向量的乘法</li><li>微分、积分运算</li></ol><h3 id="线性算子的连续性和有界性">线性算子的连续性和有界性</h3><p>连续性：</p><ol type="1"><li>定义：普通的映射的有界性</li><li>Prop：对于线性算子，任意点（即算子本身的）连续性等价于算子在<spanclass="math inline">\(\theta\)</span>处具有连续性</li></ol><p>有界性：</p><ol type="1"><li>定义：<span class="math inline">\(\exists C\forall x, \| T x \| \leC \| x \|\)</span></li><li>Prop：B*空间中的线性算子，连续性和有界性等价</li></ol><p>有界线性算子 <span class="math inline">\(L(X,Y)\)</span>、算子范数</p><ul><li>定义：<span class="math inline">\(\sup _ {x \in X - \theta} \| Tx \|/ \| x \|\)</span>​</li><li>Theorem：假设<span class="math inline">\(X\)</span>是B*空间，<spanclass="math inline">\(Y\)</span>是B空间，若在<spanclass="math inline">\(L\)</span>上定义了线性运算，那么<spanclass="math inline">\(L\)</span>按照算子范数构成Banach空间</li></ul><p>例子：</p><ol type="1"><li>有穷维B*空间，<span class="math inline">\(X\toY\)</span>的线性映射都是连续的。（因为都可以表示成矩阵，从而有界）</li><li>Hilbert空间上的正交投影算子是有界线性算子，算子范数为 1.</li></ol><p>‍</p><p>‍</p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>度量空间、压缩映射、列紧集</title>
      <link href="/2023/08/18/merture-space-compression-mapping-tight-set-11pknm/"/>
      <url>/2023/08/18/merture-space-compression-mapping-tight-set-11pknm/</url>
      
        <content type="html"><![CDATA[<h2 id="压缩映像原理">压缩映像原理</h2><p><strong>距离</strong></p><ul><li>定义：<strong>三个条件</strong></li><li>例：<span class="math inline">\(C([a, b])\)</span>，按照 <spanclass="math inline">\(\max |x - y|\)</span></li><li>目的：引入“收敛”</li></ul><p><strong>收敛、闭集、基本列、完备空间</strong></p><ul><li><span class="math inline">\(R^n,||_2\)</span> 是完备的；</li><li><span class="math inline">\(C([a, b])\)</span>，按照 <spanclass="math inline">\(\max |x - y|\)</span> 是完备的；</li></ul><p><strong>连续映射、压缩映射、不动点</strong></p><ul><li>定义：<spanclass="math inline">\(T:(X,\rho)\to\left(X,\rho\right)\quad\rho\left(Tx,Ty\right)\le\alpha\rho\left(x,y\right),0&lt;\alpha&lt;1\)</span></li></ul><p><strong>Banach 不动点定理、压缩映射原理</strong></p><ul><li>完备距离空间到自身的压缩映射的不动点存在且唯一</li><li>应用：隐函数存在定理</li></ul><blockquote><p>ODE 的初值问题</p><p><span class="math display">\[\begin{cases}\dot{x}=F\left(t,x\right)\\ x\left(0\right)=\xi\end{cases}\]</span></p><p>等价于求解积分方程问题：</p><p><span class="math display">\[x(t)=\xi+\int_0^{t}F\left(\tau,x\left(\tau\right)\right)\mathrm{d}\tau\]</span></p><p>定义映射：</p><p><span class="math display">\[(Tx)(t)=\xi+\int_0^{t}F\left(\tau,x\left(\tau\right)\right)\mathrm{d}\tau\]</span></p><p>考虑如何使得 <span class="math inline">\(T\)</span>为压缩映射？（距离定义为 <spanclass="math inline">\(\max|x-y|\)</span>）</p><p>假设 <span class="math inline">\(F\)</span> 对 <spanclass="math inline">\(x\)</span> 关于 <spanclass="math inline">\(t\)</span> 一致满足局部 L 条件即可。</p></blockquote><p>Theorem：假设函数 <span class="math inline">\(F\)</span> 在 <spanclass="math inline">\([-h, h]\times [\xi - \delta, \xi +\delta]\)</span> 上有定义、连续、满足条件</p><p><span class="math display">\[|F(t, x_1) - F(t, x_2)| \le L|x_1 - x_2|\]</span></p><p>则当 <spanclass="math inline">\(h&lt;\min\left\lbrace\frac{\delta}{M},\frac{1}{L}\right\rbrace\)</span>时，初值问题在 <span class="math inline">\([-h, h]\)</span>上存在唯一解。</p><h2 id="完备化">完备化</h2><p>一般而言，距离空间是不完备的。例如全体有理数组成的空间，或 <spanclass="math inline">\(C[a,b]\)</span> 对 <spanclass="math inline">\(L_1\)</span> 范数。</p><p><strong>等距同构、等距同构映射、嵌入</strong></p><ul><li>定义？</li><li>目的：存在等距同构的空间的性质都是一样的，不加以区分</li></ul><p><strong>稠密子集、完备化空间</strong></p><ul><li>Theorem：每个空间都有其完备化空间</li><li>例如：<span class="math inline">\(P[a,b]\)</span> 在 <spanclass="math inline">\(C[a, b]\)</span> 内稠密，以 <spanclass="math inline">\(C[a,b]\)</span> 为其完备化空间</li></ul><h2 id="列紧集">列紧集</h2><blockquote><p><strong>Compactness</strong> is a <ahref="https://brilliant.org/wiki/topology/"title="topological">topological</a> property that is fundamental in <ahref="https://brilliant.org/wiki/real-analysis/"title="real analysis">real analysis</a>, <ahref="https://brilliant.org/wiki/algebraic-geometry/"title="algebraic geometry">algebraic geometry</a>, and many othermathematical fields. In ��<strong>R</strong>n (with the standardtopology), the compact sets are precisely the sets which are <ahref="https://brilliant.org/wiki/closed-sets/" title="closed">closed</a>and bounded. Compactness can be thought of a generalization of theseproperties to more abstract topological spaces.</p><p>Compact sets are well-behaved with respect to <ahref="https://brilliant.org/wiki/continuous-functions/"title="continuous functions">continuous functions</a>; in particular,the continuous image of a compact function is compact, so a continuousfunction from a compact set to �<strong>R</strong> must have a finiteminimum and maximum, and must attain each of these at some point in thedomain (the <a href="https://brilliant.org/wiki/extreme-value-theorem/"title="extreme value theorem">extreme value theorem</a>). This is quiteuseful in applications to <ahref="https://brilliant.org/wiki/optimization-problems/"title="optimization">optimization</a> and other related areas.</p></blockquote><p><strong>有界：</strong></p><ul><li>在 Rn 中，有界无穷集中可以找到收敛子列</li><li>一般的距离空间不满足</li></ul><p><strong>列紧、自列紧、列紧空间</strong></p><ul><li>定义：任意点列都有一个收敛子列；进一步，收敛到原本空间中的点；进一步，自身是列紧的</li><li>例如：Rn 中的有界集合是列紧的、有界闭集是自列紧的</li><li>列紧空间的任意的子集都是列紧的、任意闭子集都是自列紧的；（反证法）</li><li>列紧空间是完备的</li></ul><p><span class="math inline">\(\epsilon\)</span>**<strong>网、有穷</strong> **** <strong>网、完全有界、Hausdorff定理</strong></p><ul><li>定义？</li><li>Hausdorff：<br />为了距离空间中的集合是列紧的，必须要求其是完全有界的；<br />为了完备距离空间中的集合是列紧的，必须且仅须其是完全有界的；</li></ul><p><strong>可分</strong></p><ul><li>定义？</li><li>Theorem：完全有界的距离空间是可分的.</li></ul><p><strong>紧集</strong></p><ul><li><strong>Z</strong> is compact if every open cover has a finitesubcover.</li><li>Theorem：距离空间中的紧集，当且仅当其是自列紧的</li></ul><p>​<img src="assets/image-20230816114201-eupnfg5.png" alt="image" />​</p><blockquote><p><ahref="https://www.zhihu.com/question/58904993">怎么通俗的理解有界闭集，紧集，列紧集？- 知乎 (zhihu.com)</a></p></blockquote><p>考察紧的距离空间 <spanclass="math inline">\(M\)</span>，和其上的连续映射全体 <spanclass="math inline">\(C(M)\)</span>，定义：</p><p><span class="math display">\[d(u, v) = \max_{x\in M} |u - v|\]</span></p><ul><li><p><span class="math inline">\(C, d\)</span>是距离空间、完备</p></li><li><p>一致有界、等度连续、Arzela-Ascoli：为了 <spanclass="math inline">\(F \subset C(M)\)</span> 列紧，当且仅当，<spanclass="math inline">\(F\)</span> 一致有界且等度连续.</p><ul><li>刻画了连续函数空间上的列紧集</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内积空间</title>
      <link href="/2023/08/17/inner-accumulation-1pn6jt/"/>
      <url>/2023/08/17/inner-accumulation-1pn6jt/</url>
      
        <content type="html"><![CDATA[<h2 id="内积空间">内积空间</h2><h3 id="基本定义和性质">基本定义和性质</h3><h4 id="共轭双线性函数内积内积空间">共轭双线性函数、内积、内积空间</h4><ul><li><p>定义：共轭对称、正定的共轭双线性函数</p></li><li><p>例：</p><ul><li><span class="math inline">\(l^2\)</span> 空间 <spanclass="math inline">\(L^2\)</span> 空间</li><li><span class="math inline">\(C^k(\bar \Omega)\)</span> 中，按照 <spanclass="math inline">\((u,v)=\sum_{\left|\alpha\right|\lek}^{}\int_{\Omega}^{}\partial^{\alpha}u\overline{\partial^{\alpha}v}dx\)</span>是内积空间</li></ul></li><li><p>Cauchy-Schwarz 不等式：<span class="math inline">\(|(x, y) | \le\| x \| \|y\|\)</span>，等号成立当且仅当 <span class="math inline">\(x,y\)</span> 线性相关</p></li></ul><p>内积空间按照 <span class="math inline">\(\|x\|=(x, x)\)</span>定义范数，构成 B*空间：</p><ul><li>内积 <span class="math inline">\((\cdot, \cdot)\)</span> 是关于<span class="math inline">\(\|\cdot \|\)</span> 的连续函数</li><li>内积空间是严格凸的 B*空间</li></ul><p>反过来，一个 <span class="math inline">\(\|\cdot \|\)</span>也有可能构成一个内积空间：</p><ul><li><p>如果 <span class="math inline">\(\|\cdot \|\)</span>满足平行四边形等式：</p><p><span class="math display">\[\|x-y\|^2+\|x+y\|^2=2\left(\|x\|+\|y\|\right)\]</span></p></li></ul><h4 id="hilbert-空间">Hilbert 空间</h4><ul><li>完备的内积空间</li></ul><blockquote><p>在 PDE 中，常用的一个 Hilbert 空间是 <spanclass="math inline">\(H^m_0\)</span>，</p><p>设 <span class="math inline">\(C_0^m\)</span> 是有界开区域上一切<span class="math inline">\(m\)</span> 次连续可微、在边界的某个邻域内为0 的函数集合，那么：</p><p><span class="math display">\[\forall u\inC_{0^{}}^{m},\sum_{\left|\alpha\right|&lt;m}^{}\int_{\Omega}^{}\left|\partial^{\alpha}u\left(x\right)\right|^2dx\leC\sum_{\left|\alpha\right|=m}^{}\int_\Omega\left|\partial^{\alpha}u(x)\right|^2dx\]</span></p><p>‍</p><p>从而，在 <span class="math inline">\(C^m_0\)</span> 上引入范数：</p><p><span class="math display">\[\|u\|_{m}=\left(\sum_{\alpha=m}^{}\int_{\Omega}^{}\left|\partial^{\alpha}u\left(x\right)\right|^2dx\right)^{\frac12}\]</span></p><p>完备化后得到 <span class="math inline">\(H^m_0\)</span>，它是 <spanclass="math inline">\(H^m\)</span> 的一个闭子空间</p></blockquote><h3 id="正交和正交基">正交和正交基</h3><h4 id="正交正交补">正交、正交补</h4><ul><li><p>定义？</p></li><li><p>性质：</p><ul><li>勾股定理</li><li>若 <span class="math inline">\(x\perp y_n\)</span>，且 <spanclass="math inline">\(y_n \to y\)</span>，那么 <spanclass="math inline">\(x \perp y\)</span>​</li><li>若 <span class="math inline">\(x \perp M\)</span> 那么 <spanclass="math inline">\(x \perp span(M)\)</span>​</li><li><span class="math inline">\(M^\perp\)</span> 是一个闭线性子空间</li></ul></li></ul><h4 id="正交集正交规范集完备正交集">正交集、正交规范集、完备正交集</h4><ul><li>定义？</li><li>非平凡的内积空间一定有完备正交集</li></ul><blockquote><p>Zorn 引理</p></blockquote><p>有正交规范集，可以考虑：</p><h4 id="基fourier-系数">基、Fourier 系数</h4><ul><li><p>Bessel 不等式：<span class="math inline">\(\sum_{\alpha \in A}|(x, e_\alpha)|^2\le \| x \| ^ 2\)</span></p></li><li><p>假设 <span class="math inline">\(X\)</span> 是 Hilbert 空间，并且<span class="math inline">\(e_\alpha\)</span>是正交规范集，那么对于任意的 <span class="math inline">\(x\inX\)</span>，都有 <span class="math inline">\(\sum _{\alpha \in A }(x,e_\alpha) e_\alpha \in X\)</span>，并且</p><p><span class="math display">\[\|x-\sum_{\alpha\inA}^{}\left(x,e_{\alpha}\right)e_{\alpha}\|^2=\|x\|^2-\sum_{\alpha\inA}^{}\left|(x,e_{\alpha})\right|^2\]</span></p></li></ul><p>问：何时 Bessel 不等式取等号？</p><ul><li><p>Theorem：设 X 是 Hilbert 空间，若 <spanclass="math inline">\(S=\left\lbrace e_{\alpha}\,\vert\alpha\inA\,\right\rbrace\)</span> 是其中的正交规范集，那么下面三条等价：</p><ol type="1"><li>S 封闭</li><li>S 完备</li><li>Parseval 等式成立</li></ol></li></ul><p>例如：</p><ol type="1"><li><span class="math inline">\(L^2 [0, 2\pi]\)</span> 上 <spanclass="math inline">\(e_{n}(t)=\frac{1}{\sqrt{2\pi}}e^{\mathrm{i}nt}\)</span>是正交规范基</li><li><span class="math inline">\(l^2\)</span> 上，<spanclass="math inline">\(e_n = ( 0, ...., 0, 1, 0, ... )\)</span>是正交规范基</li><li>令 <span class="math inline">\(D\)</span> 是 <spanclass="math inline">\(C\)</span> 中的单位开圆域，<spanclass="math inline">\(H^2(D)\)</span> 表示其中 L2可积的解析函数组成的全体构成的空间，规定内积为：<spanclass="math inline">\((u,v)=\iint_{D}u\bar{v}dxdy\)</span>，那么 <spanclass="math inline">\(\varphi_n = \sqrt{ n / \pi } z ^ {n - 1}\)</span>是正交规范基</li></ol><h3 id="正交化和-hilbert-空间的同构">正交化和 Hilbert 空间的同构</h3><p>Gram-Schmidt 正交化过程可以在Hilbert空间中直接实施。</p><h4 id="同构">同构</h4><ul><li><p>定义</p></li><li><p>为了Hilbert空间可分，必须且仅须它有至多可数的正交规范基S；</p><ul><li>如果S中元素个数<span class="math inline">\(N &lt;\infty\)</span>，那么同构于<span class="math inline">\(K^N\)</span>​</li><li>否则同构于<span class="math inline">\(l^n\)</span>​</li></ul></li></ul><h3 id="最佳逼近问题-ext">最佳逼近问题-ext</h3><p>最佳逼近问题中我们将其看成求空间中一点到它的线性子空间的距离问题。当时我们要求了，子空间是<strong>有穷维</strong>的，并不知道<strong>无穷维</strong>的情况。</p><p>在Hilbert空间中，答案是肯定的，并且可以用更为一般的闭凸子集来替代原本考虑的闭子空间。</p><p>Theorem：如果<spanclass="math inline">\(C\)</span>是Hilbert空间中的一个闭凸子集，那么<spanclass="math inline">\(C\)</span>上<strong>存在唯一</strong>元素取最小模</p><ul><li>思路：首先找到下确界<span class="math inline">\(\inf \|z\|\)</span>，然后逐步逼近，注意到平行四边形不等式成立即可；</li><li>推论：对于任意元素<span class="math inline">\(x_0 \inX\)</span>，和闭凸子集<spanclass="math inline">\(C\)</span>，C中的最佳逼近是存在且唯一的</li></ul><p>我们还需要考虑，这样的最佳逼近元有什么样的性质：</p><p>Theorem：设<span class="math inline">\(C\)</span>是内积空间<spanclass="math inline">\(X\)</span>中的一个闭凸子集，为了<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(y\)</span>的最佳逼近，当且仅当：</p><p><span class="math display">\[\operatorname{Re}\left(y-x_0,x_0-x\right)\ge0\]</span></p><ul><li>思路：考察函数<span class="math inline">\(\varphi _ x (t) = \| y -tx - (1-t) x _ 0\|^2\)</span>​</li><li>推论：<strong>（正交分解）</strong>设M是Hilbert空间上的一个闭线性子空间，对于任意的<spanclass="math inline">\(x \inX\)</span>​<strong>存在唯一的</strong>正交分解<spanclass="math inline">\(x = y + z, ( y \in M , z \in M ^\perp)\)</span>​</li></ul><h3 id="应用">应用</h3><h4 id="最小二乘法">最小二乘法</h4><ol type="1"><li>实际观测问题（线性拟合）</li><li>平方平均逼近：类似与NPDE求解？</li><li>最佳估计问题</li></ol><h4 id="曲线光顺和样条函数spline">曲线光顺和样条函数（Spline）</h4><blockquote><p>TODO？</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图形变换算法</title>
      <link href="/2023/08/09/graphic-transformation-algorithm-z10h0cf/"/>
      <url>/2023/08/09/graphic-transformation-algorithm-z10h0cf/</url>
      
        <content type="html"><![CDATA[<h1 id="图形变换算法">图形变换算法</h1><blockquote><p>包括视点变换、世界坐标变换、局部坐标变换等各种矩阵变换方法；</p></blockquote><p>一般的，有如下几个坐标系之间需要相互转化：</p><ol type="1"><li>模型坐标系</li><li>世界坐标系</li><li>Eye coordinates</li><li>Clip coordinates</li><li>NDC</li><li>Window coordinates.</li></ol><h2 id="齐次坐标">齐次坐标</h2><p>考虑两个坐标系之间的转化：</p><p><span class="math display">\[\begin{bmatrix}u_1\\ u_2\\ u_3\end{bmatrix} = M \begin{bmatrix}\nu_1\\\nu_2\\ \nu_3\end{bmatrix}\]</span></p><p>如果一个向量表示为：</p><p><span class="math display">\[w=\alpha_1\nu_1+\alpha_2\nu_2+\alpha_3\nu_3\]</span></p><p>即在<span class="math inline">\(\mathbf \nu\)</span>下的坐标为<spanclass="math inline">\(\alpha\)</span>，那么在<spanclass="math inline">\(u\)</span>下的坐标为</p><p><span class="math display">\[\beta = T\alpha = M^{-T} \alpha\]</span></p><p>‍</p><p>而为了用矩阵来方便的表示3d仿射变换，引入齐次坐标：</p><p><span class="math display">\[P = P_0 + x \nu _1 + y\nu _2 + z \nu _3\]</span></p><ol type="1"><li>对于点：<span class="math inline">\((x, y, z) \rightarrow (x, y, z,1)\)</span>，并且认定<span class="math inline">\((kx, ky, kz,k)\)</span>等价于<span class="math inline">\((x, y, z, 1)\)</span></li><li>对于向量：<span class="math inline">\((x, y, z) \rightarrow (x, y,z, 0)\)</span></li></ol><p>这样：</p><ol type="1"><li>点 + 点 → 中点</li><li>点 + 向量 → 点</li><li>向量 + 向量 → 向量</li></ol><p>对于两个标架：<span class="math inline">\((u, Q), (\nu,P)\)</span>，之间可以用矩阵来进行转换，即：</p><p><span class="math display">\[\begin{bmatrix}u\\ Q\end{bmatrix}=M\begin{bmatrix}\nu\\ P\end{bmatrix}\]</span></p><p>假设坐标为<spanclass="math inline">\(\alpha\)</span>，求出另一标架下的坐标：</p><p><span class="math display">\[\alpha^{\prime}\begin{bmatrix}u\\Q\end{bmatrix}=\beta^{\prime}\begin{bmatrix}\nu\\P\end{bmatrix}=\beta^{\prime}M\begin{bmatrix}u\\ Q\end{bmatrix}\]</span></p><p>因此<span class="math inline">\(\beta = M^{-T}\alpha\)</span>​</p><h3 id="平移">平移</h3><p><span class="math inline">\((x, y, z) \rightarrow (x + dx, y + dy, z+ dz)\)</span>​</p><p><span class="math display">\[M=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; \mathrm{d}x\\ 0 &amp; 1 &amp; 0&amp; \mathrm{d}y\\ 0 &amp; 0 &amp; 1 &amp; dz\\ 0 &amp; 0 &amp; 0 &amp;1\end{bmatrix}\]</span></p><h3 id="旋转">旋转</h3><p>首先考虑二维的旋转，二维绕原点的旋转为：</p><p><span class="math display">\[\begin{bmatrix}\cos\theta &amp; -\sin\theta\\ \sin\theta &amp;\cos\theta\end{bmatrix}\]</span></p><p>可以看成是，三维中绕某一固定轴的旋转。</p><p>例如，绕z轴</p><p><span class="math display">\[\begin{bmatrix}\cos\theta &amp; -\sin\theta &amp; 0 &amp; 0\\ \sin\theta&amp; \cos\theta &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0&amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>需要注意的是，旋转矩阵一定满足<span class="math inline">\(R^{-T} =R\)</span>​</p><h3 id="缩放矩阵">缩放矩阵</h3><p><span class="math display">\[(x,y,z)\to\left(\beta_{x}x,\beta_{y}y,\beta_{z}z\right)\]</span></p><p><span class="math display">\[M=\mathrm{diag}(\beta_{x},\beta_{y},\beta_{z},1)\]</span></p><h3 id="复杂旋转">复杂旋转</h3><p>主要是考虑绕任意轴的旋转。</p><p>记绕<span class="math inline">\(x\)</span>轴的旋转为<spanclass="math inline">\(R_x(\theta)\)</span>，轴过点<spanclass="math inline">\(p\)</span>，且对于<span class="math inline">\(x,y\)</span>轴的角为<spanclass="math inline">\(\theta_{x},\theta_{y}\)</span>，那么：</p><p><span class="math display">\[M = T(p_0) R_x(-\theta_x) R_y(-\theta_y) R_z(\theta)R_y(\theta_y)R_x(\theta _x) T(-p_0)\]</span></p><h3 id="向量旋转公式">向量旋转公式</h3><p>另外，考虑绕向量<spanclass="math inline">\(u\)</span>的旋转，我们可以尝试将向量<spanclass="math inline">\(v\)</span>分解到沿<spanclass="math inline">\(u\)</span>的方向和垂直于<spanclass="math inline">\(u\)</span>的方向。</p><p>先考虑垂直方向：</p><p><span class="math display">\[\mathbf{v}^{\prime}=\cos\theta\mathbf{v}_{}+\sin\theta\left(u\times\mathbf{v}\right)\]</span></p><p>整合垂直方向和平行方向：</p><p><span class="math display">\[v^{\prime}=\cos\theta\left(v-\left(u\cdotv\right)u\right)+\sin\theta\left(u\times v\right)+\left(u\cdot v\right)u\]</span></p><h2 id="四元数光滑旋转">四元数、光滑旋转</h2><ol type="1"><li>将虚数推广到3d</li><li>一个实部、三个虚部<span class="math inline">\(q = q_0 + q_1 i + q_2j + q_3 k = (q_0, Q)\)</span></li><li><span class="math inline">\(i^2=j^2=k^2=ijk=-1\)</span></li></ol><p><span class="math display">\[pq = (p_0 q_0 - P\cdot Q, q_0 P + p_0 Q + P \times Q)\]</span></p><p><span class="math display">\[pq=\begin{bmatrix}p_0 &amp; -p_1 &amp; -p_2 &amp; -p_3\\ p_1 &amp; p_0&amp; -p_3 &amp; p_2\\ p_2 &amp; p_3 &amp; p_0 &amp; -p_1\\ p_3 &amp;-p_2 &amp; p_1 &amp; p_0\end{bmatrix}q\]</span></p><p>共轭四元数可以用于求逆：</p><p><span class="math display">\[qq^{*}=\|q\|^2\Rightarrow q^{-1}=\frac{q}{\|q\|^2}\]</span></p><p>‍</p><h3 id="四元数表示旋转">四元数表示旋转</h3><p>空间中的点表示为：</p><p><span class="math display">\[p = (0, Q)\]</span></p><p>定义：</p><p><span class="math display">\[r=\left(\cos\frac{\theta}{2},\sin\frac{\theta}{2}\mathbf{u}\right)\]</span></p><p>其中的<span class="math inline">\(\mathbfu\)</span>是一个单位向量。</p><p>那么<span class="math inline">\(r pr^{-1}\)</span>也是一个点，是<spanclass="math inline">\(Q\)</span>绕方向<spanclass="math inline">\(v\)</span>旋转<spanclass="math inline">\(\theta\)</span>角的位置。</p><p>我们考虑纯四元数<span class="math inline">\(v = (0, \mathbfv)\)</span>​</p><p>通过之前的公式，假设它垂直于我们的旋转轴<spanclass="math inline">\(u\)</span>，旋转后四元数应为：</p><p><span class="math display">\[v&#39; = (0,\cos\theta\mathbf{v}_{}+\sin\theta\left(u\times\mathbf{v}\right))\]</span></p><p>对比乘法公式，不难得到：</p><p><span class="math display">\[v&#39; = (\cos \theta , u \sin \theta )v\]</span></p><p>因此，一般情况下：</p><p><span class="math display">\[v&#39; = v_\|+qv_{\perp}\]</span></p><p>进一步化简需要用到如下的公式：</p><blockquote><p><span class="math display">\[\left(\cos\theta,u\sin\theta\right)^2=\left(\cos2\theta,u\sin2\theta\right)\]</span></p></blockquote><p>从而，令<spanclass="math inline">\(p=\left(\cos\frac{\theta}{2},u\sin\frac{\theta}{2}\right)\)</span>，我们可以对于原本的公式进行变形：</p><p><span class="math display">\[v^{\prime}=pp^{-1}v_{\parallel}+ppv_{\perp}\]</span></p><p>但考虑到</p><ol type="1"><li><span class="math inline">\(v_\parallel\)</span>平行于<spanclass="math inline">\(u\)</span>，因此<spanclass="math inline">\(pv_\parallel = v_\parallel p\)</span></li><li><span class="math inline">\(v_\perp\)</span>垂直于<spanclass="math inline">\(u\)</span>，因此<span class="math inline">\(qv_\perp = v_\perp q^{-1}\)</span>​</li></ol><p>交换两个顺序：</p><p><span class="math display">\[v&#39; = p v p^* = p v p ^{-1}\]</span></p><p>因此，如果单位四元数 <span class="math inline">\(q = [a, \mathbfb]\)</span>，那么可以通过：</p><p><span class="math display">\[\cos\frac{\theta}{2}=a,u\sin\theta=b\]</span></p><p>来反求出转轴和转动角。</p><h4 id="旋转复合">旋转复合</h4><p>如上定义的旋转也满足复合，可以通过旋转的复合，等价于四元数的乘法。</p><h4 id="双倍覆盖">双倍覆盖</h4><p>任意的单位四元数，<span class="math inline">\(q\)</span>和<spanclass="math inline">\(-q\)</span>代表的是同一个旋转。<spanclass="math inline">\(-q\)</span>可以看作是沿着转轴<spanclass="math inline">\(-u\)</span>旋转<span class="math inline">\(2\pi -\theta\)</span>。</p><h4 id="指数形式">指数形式</h4><p>类似于复数的欧拉公式，四元数有类似的公式。只考虑单位纯四元数的情况：</p><p><span class="math display">\[u=[0,\mathbf{u}]\implies\exp u\theta=\cos\theta+u\sin\theta\]</span></p><p>因此，沿着<spanclass="math inline">\(u\)</span>轴的旋转可以写作：</p><p><span class="math display">\[v^{\prime}=e^{u\frac{\theta}{2}}ve^{-u\frac{\theta}{2}}\]</span></p><h3 id="四元数旋转插值">四元数旋转插值</h3><p>假设有两个旋转变换，<span class="math inline">\(q_0\)</span>和<spanclass="math inline">\(q_1\)</span>，希望找到一些中间的变换<spanclass="math inline">\(q_t\)</span>。它可以将<spanclass="math inline">\(v_0 \rightarrow v_1\)</span>按照旋转插值到<spanclass="math inline">\(v_t\)</span>。</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230811161310-dt508l5.png"alt="image" />​</p><p>显然：</p><p><span class="math display">\[q_1vq_1^{*}=\Delta qq_0vq_0^{\ast}\left(\Delta q\right)^{*}\implies\Delta q = q_1 q_0 ^{*}\]</span></p><p>因此：</p><p><span class="math display">\[q_ t = (q_1 q_0 ^*)^t q_0\]</span></p><p>在本质上，<span class="math inline">\(q_0,q_1\)</span>仅能张成一个4d空间内的2d的超平面，因此可以在圆上考虑旋转差值：</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230811162708-mw83uf9.png"alt="image" />​</p><p>其中的<span class="math inline">\(\theta\)</span>可以通过 <spanclass="math inline">\(q_0\cdot q_1\)</span>计算得到。而恰巧的是，该角度刚刚好是<span class="math inline">\(\Deltaq\)</span>对应的旋转角度的一半。</p><h3 id="lerp-nlerp-slerp">Lerp Nlerp Slerp</h3><h4 id="lerp">Lerp</h4><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230811163152-e03be6w.png"alt="image" />​</p><p><span class="math display">\[Lerp(v_0, v_1, t) = v_t = (1-t) v_0 + tv_1\]</span></p><h4 id="nlerp">NLerp</h4><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230811163148-4thudqd.png"alt="image" />​</p><p><span class="math display">\[Nlerp(v_0, v_1, t) = Normalize(Lerp(v_0, v_1, t))\]</span></p><h4 id="slerp">Slerp</h4><p>球面线性插值</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230811163200-9qseiro.png"alt="image" />​</p><p><span class="math display">\[Slerp=\frac{\sin\left(1-t\right)\theta}{\sin\theta}v_0+\frac{\sint\theta}{\sin\theta}v_1\]</span></p><h2 id="图形变换">图形变换</h2><p>重新回到我们研究的图形变换问题上。</p><h3 id="观察viewing">观察（Viewing）</h3><h4 id="平行投影">平行投影</h4><ol type="1"><li>正投影：不改变距离和角度，距离和形状都没有失真；</li><li>轴测投影：投影线仍然垂直于投影面，但是投影平面相对于物体的方向是任意的；</li><li>斜投影：普通的平行投影</li></ol><h4 id="透视">透视</h4><p>尺寸会变化，同时分为：</p><ol type="1"><li>三点透视</li><li>两点透视</li><li>一点透视</li></ol><h3 id="定位照相机">定位照相机</h3><p>我们一般直接使用模-视变换，而非单独的的Model,View变换。初始的矩阵为IdentityMat，即照相机标架和对象标架重合。而且，MV变换是相对于相机标架的，作用在图元上。</p><p>一种可能的API是基于：</p><ol type="1"><li>相机的位置 <span class="math inline">\(p\)</span></li><li>相机的朝向 <span class="math inline">\(u\)</span></li><li>相机的上方向（Up） <span class="math inline">\(n\)</span></li></ol><p>来确定view变换。</p><p>通过<span class="math inline">\(v = n \timesu\)</span>来确定左方向，因此从<spanclass="math inline">\(uvn\)</span>到<spanclass="math inline">\(xyz\)</span>标架的矩阵为：</p><p><span class="math display">\[R=\begin{bmatrix}u_{x} &amp; v_{x} &amp; n_{x} &amp; 0\\ u_{y} &amp;v_{y} &amp; n_{y} &amp; 0\\ u_{z} &amp; v_{z} &amp; n_{z} &amp; 0\\ 0&amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>同时，考虑到相机的平移为<span class="math inline">\(T^{-1} = T(x, y,z)\)</span>，组合出mv矩阵为<span class="math inline">\(V=RT\)</span>​</p><p>另一种api可以基于俯仰角、滚转角、偏航角来确定。</p><h3 id="简单投影">简单投影</h3><h4 id="透视投影">透视投影</h4><p>考虑点<span class="math inline">\((x, y, z)\)</span>投影到平面<spanclass="math inline">\(z = d\)</span>上：</p><p><span class="math display">\[\left(x,y,z\right)\rightarrowtail\left(\frac{xd}{z},\frac{yd}{z},d\right)\]</span></p><p>不难看出，这不是一个仿射变换。但是考虑齐次坐标：</p><p><span class="math display">\[\left(x,y,z,1)\equiv\left(xd,\right.yd,zd,d\right)\]</span></p><p>我们可以定义变换：</p><p><span class="math display">\[M=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; \frac{1}{d} &amp;0\end{bmatrix}\]</span></p><p>可以得到：</p><p><span class="math display">\[(x,y,z,1)\to\left(x,y,z,\frac{z}{d}\right)\equiv\left(\frac{xd}{z},\frac{yd}{z},d,1\right)\]</span></p><p>即为所求的透视变换。</p><h3 id="opengl-投影">Opengl 投影</h3><p>定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glFrustum</span>(l, r, b, t, n ,f)</span><br></pre></td></tr></table></figure><h3 id="投影矩阵">投影矩阵</h3><h4 id="平行投影-1">平行投影</h4><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230814155754-rxl0joz.png"alt="image" />​</p><p><span class="math display">\[x,y,z\to x,y,0\]</span></p><p>OpenGL 中的平行投影API为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mat4 <span class="title">Ortho</span><span class="params">(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat near, GLfloat far)</span></span></span><br></pre></td></tr></table></figure><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230814155859-6eh5pu0.png"alt="image" />​</p><h4 id="投影规范化">投影规范化</h4><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230814160341-5s5oknr.png"alt="image" />​</p><p>‍</p><ol type="1"><li>在4d空间中计算</li><li>尽可能保留深度信息，然后进行深度测试</li><li>执行投影规范化，使得需要的投影变成一个固定的正交投影</li></ol><h4 id="正交投影">正交投影</h4><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230814161642-59uzx5m.png"alt="image" />​</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230814161648-z4qawdx.png"alt="image" />​</p><h4 id="斜投影">斜投影</h4><p>类似于正投影，但涵盖一个切变变换：</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230814173621-iknmmdr.png"alt="image" />​​</p><p><imgsrc="http://127.0.0.1:6806/assets/image-20230814173626-llgwro5.png"alt="image" />​</p><h3 id="透视投影-1">透视投影</h3><p>考察如下的透视投影问题：</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230814173745-5qx890u.png"alt="image" />​</p><p>现在我们考虑：<spanclass="math inline">\(z=-near\to-1\)</span>，<spanclass="math inline">\(z=-far\to1\)</span>，即：</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230815101557-jmiuyum.png"alt="image" />​</p><p>只考虑z轴，矩阵为</p><p><span class="math display">\[M=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; \alpha &amp; \beta\\ 0 &amp; 0 &amp; -1 &amp;0\end{bmatrix}\]</span></p><p>其中的：</p><p><span class="math display">\[\begin{cases}\alpha=-\frac{n+f}{n-f}\\ \beta=-\frac{2nf}{n-f}\end{cases}\]</span></p><p>‍</p><p>​<imgsrc="http://127.0.0.1:6806/assets/image-20230815105743-9ecc72j.png"alt="image" />​</p><h2 id="隐藏面消除">隐藏面消除</h2><p>两大类：</p><ol type="1"><li>对象空间算法：将场景中的对象表面排序</li><li>图像空间算法：确定每一条投影线于对象表面所有交点的关系，例如z-buffer</li></ol><p>‍</p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>06. 位势方程</title>
      <link href="/2023/08/07/position-equation-19h4du/"/>
      <url>/2023/08/07/position-equation-19h4du/</url>
      
        <content type="html"><![CDATA[<p>位势方程：</p><p><span class="math display">\[-\Delta u=f\left(x\right)\]</span></p><p>是椭圆形方程的代表：</p><ul><li><span class="math inline">\(f\equiv 0\)</span>：<strong>Laplace方程，</strong>​**** 称为调和函数；</li><li>否则称为 <strong>Poisson 方程</strong></li></ul><p>类似于下解、上解，引入：</p><p><span class="math display">\[-\Delta u\le0\]</span></p><p>为下调和函数。</p><h2 id="基本解">基本解</h2><h3 id="基本解green-公式">基本解、Green 公式</h3><p>固定球心，对于球坐标系，<span class="math inline">\(\Delta u\)</span>可以写作：</p><p><span class="math display">\[\Delta u=u&#39;&#39;(r)+\frac{n-1}{r}u^{\prime}\left(r\right)\]</span></p><p>解 Laplace 方程，得到：</p><p><span class="math display">\[u=\begin{cases}\frac{c}{2-n}r^{2-n} &amp; n&gt;2\\ c\ln r &amp;n=2\end{cases}\]</span></p><p>其中 <span class="math inline">\(r=\left|x-y\right|\)</span>。其满足Laplace 方程。取常数 <spanclass="math inline">\(c=\frac{1}{n\omega_{n}}\)</span>，定义调和方程的基本解<span class="math inline">\(k(x-y)\)</span>。</p><ul><li><span class="math inline">\(\omega_2 = \pi\)</span>​</li><li><span class="math inline">\(\omega_3=\frac43\pi\)</span></li></ul><h4 id="调和函数的基本积分公式">调和函数的基本积分公式</h4><blockquote><p>Green 第二公式: Integration by parts，（<ahref="assets/PDE-20230804142154-8fruti8.pdf?p=134">PDE.pdf - p134 -PDE-P134-20230807144704</a>）</p><p>​<imgsrc="assets/PDE-P134-20230807144704-20230807144941-o7y8zpr.png" />​</p></blockquote><p>对于 <span class="math inline">\(y\in \Omega\)</span>，作球 <spanclass="math inline">\(B_\rho (y) \sub \Omega\)</span>，在区域 <spanclass="math inline">\(\Omega-\bar {B}_{\rho}\)</span>中用调和函数的基本解，代入 Green 第二公式，</p><p><span class="math display">\[\int_{\Omega-B_{\rho}}^{}k\left(x-y\right)\Deltau\mathrm{d}x=\int_{\partial\Omega}^{}\left(k\frac{\partialu}{\partial\nu}-u\frac{\partialk}{\partial\nu}\right)\mathrm{d}S_{x}+\int_{\partialB_{\rho}}^{}\left(k\frac{\partial u}{\partial\nu}-u\frac{\partialk}{\partial\nu}\right)\]</span></p><p>对于第二个积分</p><p><span class="math display">\[\int_{\partial B}^{}k\frac{\partialu}{\partial\nu}dS_{x}\to0\quad\int_{\partial B}^{}u\frac{\partialk}{\partial\nu}dS_{x}→-u(y)\quad(\rho\to0)\]</span></p><p>因此，有 <span class="math inline">\(u\)</span> 的 Green 表示：</p><p><span class="math display">\[u(y)=\int_{\partial\Omega}^{}\left(u\frac{\partialk}{\partial\nu}-k\frac{\partialu}{\partial\nu}\right)\mathrm{d}S_{x}+\int_{\Omega}^{}k\Deltau\mathrm{d}x\]</span></p><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=135">PDE.pdf - p135- PDE-P135-20230807151753</a> ​<imgsrc="assets/PDE-P135-20230807151753-20230807151755-u1uhjc3.png" />​</p><blockquote><p>基本积分公式：</p><p><span class="math display">\[u(y)=\int_{\partial\Omega}^{}\left(u\frac{\partialk\left(x-y\right)}{\partial\nu}-k\left(x-y\right)\frac{\partialu}{\partial\nu}\right)\mathrm{d}S_{x}\]</span></p></blockquote><h3 id="平均值等式">平均值等式</h3><p>设 <span class="math inline">\(u\in C^2\)</span>，在 <spanclass="math inline">\(\Omega\)</span> 中满足</p><p><span class="math display">\[-\Delta u=0(\le 0)\]</span></p><p>那么对于任何一个球 <span class="math inline">\(B_R(y)\sub\Omega\)</span>，都有：</p><p><span class="math display">\[u(y)=(\le)\frac{1}{n\omega_{n}R^{n-1}}\int_{\partial B_{n}}^{}udS\]</span></p><p>和</p><p><span class="math display">\[u(y)=(\le)\frac{1}{\omega_{n}R^{n}}\int_{B_{R}}^{}u\mathrm{d}x\]</span></p><p>等号成立时，称为平均值定理。</p><h3 id="最大最小值原理">最大、最小值原理</h3><p><strong>下调和函数的强最大值原理</strong>：设 <spanclass="math inline">\(u\)</span> 是 <spanclass="math inline">\(\Omega\)</span> 内的下调和函数，且存在 <spanclass="math inline">\(y\in \Omega\)</span> 使得</p><p><span class="math display">\[u(y) = \sup_{\Omega} u\]</span></p><p>那么 <span class="math inline">\(u\)</span> 是常数。</p><p><strong>下调和函数的弱最大值原理</strong>：设 <spanclass="math inline">\(u\)</span> 是 <spanclass="math inline">\(\Omega\)</span> 内的下调和函数，且 <spanclass="math inline">\(\Omega\)</span> 有界，那么</p><p><span class="math display">\[\max _{\bar \Omega} u= \max _{\partial \Omega} u\]</span></p><p>由此可以直接得到调和函数的最大值/最小值原理、调和函数的比较定理</p><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=137">PDE.pdf - p137- PDE-P137-20230807155201</a> ​<imgsrc="assets/PDE-P137-20230807155201-20230807155203-u6jpn05.png" />​</p><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=138">PDE.pdf - p138- PDE-P138-20230807155210</a> ​<imgsrc="assets/PDE-P138-20230807155210-20230807155212-8h7op8n.png" />​</p><p>通过最大最小值原理，可以轻松得到：</p><ol type="1"><li>Poisson 方程的 Dirichlet<strong>内</strong>问题具有<strong>唯一性和稳定性</strong>；</li><li>Poisson 方程的 Dirichlet<strong>外</strong>问题具有<strong>唯一性和稳定性</strong>；</li></ol><h2 id="green-函数">Green 函数</h2><h3 id="green-函数的导出与性质">Green 函数的导出与性质</h3><p>我们试图求用：</p><blockquote><blockquote><p>基本积分公式：</p><p><span class="math display">\[u(y)=\int_{\partial\Omega}^{}\left(u\frac{\partialk\left(x-y\right)}{\partial\nu}-k\left(x-y\right)\frac{\partialu}{\partial\nu}\right)\mathrm{d}S_{x}\]</span></p></blockquote></blockquote><p>解调和方程、或 Poisson 方程的 Dirichlet 问题，</p><p><span class="math display">\[\begin{cases}-\Delta u=f\\u\left|_{\partial\Omega}\right.=\varphi\left(x\right)\end{cases}\]</span></p><p>显然，边界上的 <span class="math inline">\(\partial u/\partial\nu\)</span> 是未知的，不能直接求解，我们设法消去这一项。</p><p>考察一个调和函数 <span class="math inline">\(h(x;y)\)</span>，满足<span class="math inline">\(\Delta h=0\)</span>，对 <spanclass="math inline">\(h, u\)</span> 应用 Green 第二公式，先考虑 <spanclass="math inline">\(f\equiv 0\)</span> 的情况：</p><p><span class="math display">\[\int_{\partial\Omega}^{}u\frac{\partial h}{\partial\nu}-h\frac{\partialu}{\partial\nu}dS=0\]</span></p><p>要求 <span class="math inline">\(G|_{\partial\Omega}=0\)</span>，可得：</p><p><span class="math display">\[u(y)=\int_{\partial\Omega}^{}\varphi\left(x\right)\frac{\partialG}{\partial\nu}dS\]</span></p><p>一般的：<a href="assets/PDE-20230804142154-8fruti8.pdf?p=140">PDE.pdf- p140 - PDE-P140-20230808110623</a> ​<imgsrc="assets/PDE-P140-20230808110623-20230808110627-mq87mq1.png" />​</p><p>因此，问题转换为求解一个的 Dirichlet 问题，即求出特定区域上的 Green函数。</p><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=141">PDE.pdf - p141- PDE-P141-20230808105512</a> ​<imgsrc="assets/PDE-P141-20230808105512-20230808105516-dtv2fn4.png" />​</p><h3 id="球上的-green-函数poisson-积分公式">球上的 Green 函数、Poisson积分公式</h3><p>当区域为球时，可以使用<strong>镜像法</strong>来求 Green 函数。<ahref="assets/PDE-20230804142154-8fruti8.pdf?p=142">PDE.pdf - p142 -PDE-P142-20230808111049</a> ​<imgsrc="assets/PDE-P142-20230808111049-20230808111051-ejdecbp.png" />​</p><p>分两种情况：</p><ol type="1"><li><span class="math inline">\(y\ne 0\)</span>, <spanclass="math inline">\(G(x,y)=k\left(\left|x-y\right|\right)-k\left(\frac{\left|y\right|}{R}\left|x-\bar{y}\right|\right)\)</span>​</li><li><span class="math inline">\(y=0\)</span>, <spanclass="math inline">\(G(x,y) = k(|x|) - k(R)\)</span></li></ol><p>直接得到 Poisson 公式：</p><p>三维情况：<ahref="assets/PDE-20230804142154-8fruti8.pdf?p=143">PDE.pdf - p143 -PDE-P143-20230808111834</a> ​<imgsrc="assets/PDE-P143-20230808111834-20230808111836-xx6o93c.png" />​</p><p>二维情况：<ahref="assets/PDE-20230804142154-8fruti8.pdf?p=144">PDE.pdf - p144 -PDE-P144-20230808111855</a> ​<imgsrc="assets/PDE-P144-20230808111855-20230808111857-2vbip2i.png" />​</p><h3 id="上半空间的-green-函数">上半空间的 Green 函数</h3><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=144">PDE.pdf - p144- PDE-P144-20230808111411</a> ​<imgsrc="assets/PDE-P144-20230808111411-20230808111413-rb45wia.png" />​</p><p>定义 Green 函数为</p><p><span class="math display">\[G(x, y) = k (x-y) - k (x - y^*)\]</span></p><p>Poisson 公式：<ahref="assets/PDE-20230804142154-8fruti8.pdf?p=145">PDE.pdf - p145 -PDE-P145-20230808112021</a> ​<imgsrc="assets/PDE-P145-20230808112021-20230808112023-fz9y67m.png" />​</p><h3 id="能量法">能量法</h3><p>用能量法，也能得到解的存在性和唯一性。</p><ol type="1"><li>唯一性：通过 Green 公式可以直接得到。<spanclass="math inline">\(0=\int_{\Omega}^{}w\Deltaw\mathrm{d}x=\int_{\Omega}^{}\left|Dw\right|^2\mathrm{d}x\)</span></li></ol><p>Dirichlet 原理：能量泛函定义为</p><p><span class="math display">\[I[w]=\int_{\Omega}^{}\left(\frac12\left|Dw\right|^2-wf\right)\mathrm{d}x\]</span></p><p>其中的 <span class="math inline">\(w\in A=\left\lbracew|_{\partial\Omega}=\varphi\right\rbrace\)</span>，假设 <spanclass="math inline">\(u\)</span> 是 Dirichlet 问题的解，那么 <spanclass="math inline">\(u\)</span> 满足 <spanclass="math inline">\(I[u]=\min I[w]\)</span>，反之亦然。</p><blockquote><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=148">PDE.pdf - p148- PDE-P148-20230808112645</a> ​<imgsrc="assets/PDE-P148-20230808112645-20230808112648-hzjesmv.png" />​</p></blockquote><h2 id="调和函数的基本性质">调和函数的基本性质</h2><h3 id="逆平均值性质">逆平均值性质</h3><p>从之前的讨论中知道，调和函数具有平均值性质：</p><blockquote><h3 id="平均值等式-1">平均值等式</h3><p>设 <span class="math inline">\(u\in C^2\)</span>，在 <spanclass="math inline">\(\Omega\)</span> 中满足</p><p><span class="math display">\[-\Delta u=0(\le 0)\]</span></p><p>那么对于任何一个球 <span class="math inline">\(B_R(y)\sub\Omega\)</span>，都有：</p><p><span class="math display">\[u(y)=(\le)\frac{1}{n\omega_{n}R^{n-1}}\int_{\partial B_{n}}^{}udS\]</span></p><p>和</p><p><span class="math display">\[u(y)=(\le)\frac{1}{\omega_{n}R^{n}}\int_{B_{R}}^{}u\mathrm{d}x\]</span></p><p>等号成立时，称为平均值定理。</p></blockquote><p>但是并没有给出其逆定理。</p><p><strong>逆平均值定理</strong>：设 <spanclass="math inline">\(u\)</span> 连续，且对于任意一个 <spanclass="math inline">\(B = B_R(y) \subset\Omega\)</span>，都满足平均值等式，那么 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(\Omega\)</span> 内调和。</p><p>另外，假设调和函数列 <span class="math inline">\(u_n\rightarrowu\)</span> 一致收敛，那么 <span class="math inline">\(u\)</span>是调和函数。</p><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=150">PDE.pdf - p150- PDE-P150-20230808145235</a><br />​<imgsrc="assets/PDE-P150-20230808145235-20230808145236-0epamw2.png" /></p><h3 id="harnack不等式">Harnack不等式</h3><blockquote><p>一个非负调和函数在其调和区域内一个紧子域上的最大值，可以被其最小值乘以一个与函数无关的常数界定。</p></blockquote><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=150">PDE.pdf - p150- PDE-P150-20230808145422</a><br />​<imgsrc="assets/PDE-P150-20230808145422-20230808145423-q5b5g8h.png" />​</p><h3 id="liouville-定理">Liouville 定理</h3><p><strong>Liouville 定理</strong>：全空间<spanclass="math inline">\(\mathbb{R}^{n}\)</span>上的有界调和函数一定是常数。</p><h3 id="奇点可去性">奇点可去性</h3><p>假设<span class="math inline">\(u\)</span>在<spanclass="math inline">\(\Omega-\left\lbracex_0\right\rbrace\)</span>调和，在<spanclass="math inline">\(x_0\)</span>有：</p><p><span class="math display">\[\lim_{x\to x_0}\left|x-x_0\right|^{n-2}u\left(x\right)=0,n&gt;2\]</span></p><p>那么可以重新定义<span class="math inline">\(u\)</span>在<spanclass="math inline">\(x_0\)</span>的值，使得<spanclass="math inline">\(u\)</span>在<spanclass="math inline">\(\Omega\)</span>中调和。</p><h3 id="正则性">正则性</h3><p>调和函数是无穷次可微的。</p><h3 id="局部微商估计">局部微商估计</h3><p>对于每个球<span class="math inline">\(B_r\)</span>，满足<spanclass="math inline">\(|\alpha|=k\)</span>的多重指标，</p><p><span class="math display">\[\left|D^{\alpha}u\left(x_0\right)\right|\le\frac{C_{k}}{r^{n+k}}\|u\|_{L^1}\]</span></p><h3 id="解析性">解析性</h3><p>调和函数都是解析的。</p><h2 id="hopf最大值原理及其应用">Hopf最大值原理及其应用</h2><h3 id="hopf最大值原理">Hopf最大值原理</h3><p>调和方程描述的稳定的温度分布，通过最大值/最小值原理可知，温度的最高点和最低点一定在边界上取得。</p><p><strong>Hopf引理</strong>：设<spanclass="math inline">\(B_R(y)\subset R^n\)</span>，在其中<spanclass="math inline">\(-\Delta u \le 0\)</span>，假设有边界点<spanclass="math inline">\(x_0\)</span>，以及</p><ol type="1"><li><span class="math inline">\(u\in C(\bar B_R)\)</span></li><li><span class="math inline">\(\forall x \in B_R, u(x_0) &gt;u(x)\)</span></li></ol><p>若<span class="math inline">\(u\)</span>在<spanclass="math inline">\(x_0\)</span>沿着外法向的微商存在，那么<spanclass="math inline">\(\frac{\partial u}{\partial\nu}&gt;0\)</span></p><p><strong>Hopf最大最小值原理</strong>：设在<spanclass="math inline">\(\Omega\)</span>中<spanclass="math inline">\(-\Delta u \le 0\)</span>，<spanclass="math inline">\(x_0 \in \partial \Omega\)</span>且：</p><ol type="1"><li><span class="math inline">\(u\)</span>在<spanclass="math inline">\(x_0\)</span>连续</li><li>对所有的<span class="math inline">\(x\)</span>，有<spanclass="math inline">\(u(x_0) &gt; u(x)\)</span>​</li><li><span class="math inline">\(\Omega\)</span>在<spanclass="math inline">\(x_0\)</span>满足内部球条件</li></ol><p>那么<span class="math inline">\(u\)</span>在<spanclass="math inline">\(x_0\)</span>的外法向微商若存在，则满足<spanclass="math inline">\(\frac{\partial u}{\partial\nu}&gt;0\)</span></p><h3 id="hopf原理应用">Hopf原理应用</h3><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=163">PDE.pdf - p163- PDE-P163-20230809111748</a><br />​<imgsrc="assets/PDE-P163-20230809111748-20230809111751-ui0lq8w.png" />​</p><p>第二边值问题的解，除去一个常数是唯一的</p><h2 id="位势方程的弱解">位势方程的弱解</h2><h3 id="伴随微分算子">伴随微分算子</h3><p>考察齐次边界的函数类：<span class="math inline">\(D =C_0^2(\Omega)\)</span></p><p><span class="math inline">\(L_2\)</span>内积：</p><p><span class="math display">\[(u, v) = \int _ {\Omega} uv \mathrm dx\]</span></p><p>伴随微分算子：对于任意的<span class="math inline">\(u,v\)</span>都有：</p><p><span class="math display">\[(L u , v)  = (u, L^*v)\]</span></p><p>一般的二阶偏微分算子：</p><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=164">PDE.pdf - p164- PDE-P164-20230809112250</a><br />​<imgsrc="assets/PDE-P164-20230809112250-20230809112252-djc45ds.png" />​</p><p>Laplace 算子、波动算子都是自伴随微分算子。</p><h3 id="弱微商">弱微商</h3><p>设<span class="math inline">\(u, \psi \inL^1_{loc}\)</span>，等式</p><p><span class="math display">\[\int_{\Omega}^{}uD^{\alpha}\varphidx=\left(-1\right)^{\left|\alpha\right|}\int_{\Omega}^{}\psi\varphi dx\]</span></p><p>对任意的<span class="math inline">\(\varphi \in C_0^{|\alpha|}(\Omega)\)</span>成立，那么称<spanclass="math inline">\(\psi\)</span>为<spanclass="math inline">\(u\)</span>的<spanclass="math inline">\(\alpha\)</span>弱微商。</p><p><a href="assets/PDE-20230804142154-8fruti8.pdf?p=166">PDE.pdf - p166- PDE-P166-20230809114813</a><br />​<imgsrc="assets/PDE-P166-20230809114813-20230809114815-1jleqeg.png" />​</p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性赋范空间、Banach空间</title>
      <link href="/2023/02/22/measuring-space-z25ss6v/"/>
      <url>/2023/02/22/measuring-space-z25ss6v/</url>
      
        <content type="html"><![CDATA[<h2 id="线性赋范空间">线性赋范空间</h2><p>之前我们的讨论只涉及了“距离”，其只包含拓扑结构，我们还需要考虑其代数结构。</p><h3 id="线性空间">线性空间</h3><p><strong>线性空间、线性同构、线性子空间、线性流形、线性相关、线性基、维数、线性包、线性和和直和</strong></p><h3 id="线性空间上的距离">线性空间上的距离</h3><p>结合距离和线性运算，我们要求这个距离具有如下性质：</p><ol type="1"><li>平移不变性：<span class="math inline">\(\rho (x, y) = \rho (x+ z,y+z) \forall z\)</span></li><li>数乘连续性：<spanclass="math inline">\(\rho\left(x_{n},y\right)\to0\Rightarrow\rho\left(\alphax_{n,}\alphax\right)\to0,\alpha_{n}\to\alpha\Rightarrow\rho\left(\alpha_{n}x,\alphax\right)\to0\)</span></li></ol><p>从而可以将其公理化为某一函数 <span class="math inline">\(p\)</span>的条件，因为 <span class="math inline">\(\rho (x, y) = \rho (x-y, 0)=p(x- y)\)</span></p><p>**准范数（准模）、F*空间、F 空间（Frechet）**</p><ul><li><p>定义？（四个条件）</p></li><li><p>例如：</p><ul><li><span class="math inline">\(C(M)\)</span>，按 <spanclass="math inline">\(\max |x- y|\)</span> ​是 <spanclass="math inline">\(F\)</span> 空间</li><li>Euclid 空间是 F 空间</li><li>数列，按照 <spanclass="math inline">\(\|x\|=\sum_{n=1}^{\infty}\frac{1}{2^{n}}\frac{|x_{n}|}{1+\left|x_{n}\right|}\)</span>是 F 空间</li></ul></li></ul><h3 id="范数banach-空间">范数、Banach 空间</h3><p>**范数、线性赋范空间（B*空间）、Banach 空间**</p><ul><li><p>定义？（三个性质）</p></li><li><p>例如：</p><ul><li><span class="math inline">\(L^p(1\le p &lt; \infty)\)</span> 是 B空间，三角形不等式由 Minkowski 不等式给出</li><li><span class="math inline">\(L^\infty\)</span> 是 B 空间</li><li><span class="math inline">\(C^k(M)\)</span> 按照 <spanclass="math inline">\(\| u \| = \max_{|\alpha |&lt; k, x \in \bar\Omega}| \partial^\alpha u|\)</span> 是 B 空间</li><li><span class="math inline">\(C^k(M)\)</span> 按照 <spanclass="math inline">\(\|u\|_{m,p}=\left(\sum_{\left|\alpha\right|\lem}^{}\int_{\Omega}^{}\left|\partial^{\alpha}u\left(x\right)\right|^{p}dx\right)^{\frac{1}{p}}\)</span>是 B*空间，其完备化记作 <span class="math inline">\(H^{m,p}\)</span>，是 B 空间</li><li>当 <span class="math inline">\(p=2\)</span> 时，<spanclass="math inline">\(H^{m, 2}\)</span> 简单地记为 <spanclass="math inline">\(H^m(\Omega)\)</span></li></ul></li></ul><h3 id="线性赋范空间中的模等价">线性赋范空间中的模等价</h3><p><strong>（范数的）强、等价</strong></p><ul><li>定义？</li><li>为了 <span class="math inline">\(\|\cdot\|_2\)</span> 比 <spanclass="math inline">\(\|\cdot\|_1\)</span> 强，当且仅当存在常数 <spanclass="math inline">\(C\)</span>，使得 <spanclass="math inline">\(\|\cdot\|_1 \le C\|\cdot\|_2\)</span></li></ul><p>有穷维线性空间：任意两个有相同维数的线性空间等价，我们想知道，其拓扑之间有什么联系？（思路：写出每一个点的坐标，然后将原先的范数用<span class="math inline">\(K^n\)</span> 中的 L2 范数建立联系）</p><ul><li>有穷维线性空间上的范数之间时相互等价的</li><li>有穷维 B*空间一定是 B 空间</li></ul><p><strong>次线性泛函</strong></p><ul><li>定义？（次可加性、正齐次性）</li><li>Theorem：设有穷维 B*空间上的次线性泛函 <spanclass="math inline">\(P\)</span>，若 <span class="math inline">\(P(x)\ge 0, P(x) = 0 \iff x = 0\)</span>，那么存在正常数 <spanclass="math inline">\(c_1, c_2\)</span> 使得 <spanclass="math inline">\(c_1 \| x\| \le P(x) \le c_2\|x\|\)</span></li></ul><h3 id="最佳逼近问题">最佳逼近问题</h3><p>逼近论的一个基本问题是：给定一组函数 <spanclass="math inline">\(\phi_1 ... \phi_n\)</span>，和函数 <spanclass="math inline">\(f\)</span>，尝试用 <spanclass="math inline">\(\phi\)</span> 的线性组合去逼近 <spanclass="math inline">\(f\)</span>，问是否有最佳逼近存在？</p><p>换成 B* 空间：给定 B*空间，和其中的有穷个向量 <spanclass="math inline">\(e_i\)</span>，对于给定向量，求一组系数，使得按照空间中的范数而言误差最小。</p><p>首先，最小值是存在的，定义：</p><p><span class="math display">\[F(a)=\left\|x-\sum_{i=1}^{n}a_{i}e_{i}\right\|\]</span></p><p><span class="math inline">\(F\)</span> 是连续函数，且 <spanclass="math inline">\(F(a) &gt; \| \sum a_i e_i \| - \| x\|\ge c_1 |a| -\| x\|\)</span></p><blockquote><p>???</p></blockquote><ul><li>Theorem：这样的最佳逼近系数是存在的</li><li>问题：唯一性？</li></ul><p><strong>严格凸</strong></p><ul><li>定义：<span class="math inline">\(\forall x\ney,\|x\|=\|y\|=1\implies\|\alpha x+\beta y\|&lt;1\)</span></li><li>Theorem：严格凸的 B*空间中的最佳逼近系数是存在且唯一的；</li></ul><p>Summary：有穷个向量的情况下，</p><ul><li><p>普通B*空间，最佳逼近存在；</p></li><li><p>严格凸的B*空间，最佳逼近存在，并且唯一</p></li><li><p>例如：</p><ul><li>习题 1.4.7：用不超过<spanclass="math inline">\(n\)</span>次的多项式逼近<spanclass="math inline">\(C[ a,b]\)</span>上的函数，存在唯一的最佳逼近元</li></ul></li></ul><h3 id="有穷维-b空间的刻画">有穷维 B*空间的刻画</h3><ol type="1"><li>为了 B*空间是有穷维的，当且仅当其单位球面是列紧的</li><li>定义：有界</li><li>为了 B*空间是有穷维的，当且仅当其中的任意有界集是列紧的</li></ol><p>Riesz 引理：</p><ul><li>如果 <span class="math inline">\(X_0\)</span> 是 <spanclass="math inline">\(X\)</span> 的一个真闭子空间，那么对于 <spanclass="math inline">\(\forall 0 &lt; \varepsilon &lt; 1, \exists y \inX, \| y \| = 1 , \| y - x\| \ge 1-\varepsilon\)</span></li></ul><h2 id="凸集和不动点">凸集和不动点</h2><h3 id="定义和基本性质">定义和基本性质</h3><p><strong>凸集、凸包、凸组合</strong></p><ol type="1"><li>定义？</li><li>凸集的任意并集也是凸集</li><li>凸包：集合中元素的任意凸组合的全体</li></ol><p><strong>Minkowski泛函</strong></p><ul><li>定义：<span class="math inline">\(P(x) = \inf \{ \lambda &gt; 0|x/\lambda \in C , x \in X\}\)</span>（其中<span class="math inline">\(C\subset X\)</span>是凸集）</li><li>性质：正齐次性、次可加性、<span class="math inline">\(P(x) \in [0,\infty], P(\theta) = 0\)</span></li><li>问：何时<spanclass="math inline">\(P(x)\)</span>成为函数，即何时<spanclass="math inline">\(P &lt; \infty\)</span>？</li></ul><p><strong>（实线性空间上、凸集的）吸收性、对称性、（复线性空间）均衡</strong></p><ul><li>定义：吸收是指<span class="math inline">\(P\)</span>是函数，即<spanclass="math inline">\(\forall x, \exists \lambda x/ \lambda \inC\)</span>；对称是指，<span class="math inline">\(x \in C \iff -x \inC\)</span>​</li><li>Prop：吸收<span class="math inline">\(\iffP\)</span>是函数、对称<span class="math inline">\(\RightarrowP\)</span>是齐次的；</li><li>均衡的定义：<span class="math inline">\(x \in C \Rightarrow \alpha x\in C, \forall |\alpha | = 1\)</span>​</li><li>Prop：复线性空间上的一个均衡吸收凸集<spanclass="math inline">\(C\)</span>决定了一个半模（Minkowski泛函）</li></ul><p>对于线性赋范空间中的凸集，有更强的结果：</p><ul><li><p>设<span class="math inline">\(X\)</span>是一个B*空间，<spanclass="math inline">\(C\)</span>是一个含有<spanclass="math inline">\(\theta\)</span>点的闭凸集，<spanclass="math inline">\(P\)</span>是下半连续的，并且</p><p><span class="math display">\[C=\left\lbrace x\in X{|}P\left(x\right)\le1\right\rbrace\]</span></p><p>如果<span class="math inline">\(C\)</span>还是有界的，那么<spanclass="math inline">\(P= 0 \iff x = \theta\)</span></p><p>如果<span class="math inline">\(C\)</span>还以<spanclass="math inline">\(\theta\)</span>为内点，那么<spanclass="math inline">\(C\)</span>是吸收的、并且<spanclass="math inline">\(P\)</span>一致连续</p></li><li><p>若<span class="math inline">\(C\)</span> 是<spanclass="math inline">\(R^n\)</span>中的一个紧凸子集，那么存在一个正整数<spanclass="math inline">\(m\le n\)</span>，使得<spanclass="math inline">\(C\)</span>同胚于<spanclass="math inline">\(R^m\)</span>中的单位球</p></li></ul><p>‍</p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向夏令营的实变函数整理</title>
      <link href="/2022/12/04/sorting-the-real-changing-function-for-the-summer-camp-zezzds/"/>
      <url>/2022/12/04/sorting-the-real-changing-function-for-the-summer-camp-zezzds/</url>
      
        <content type="html"><![CDATA[<hr /><ul><li>Title: 面向夏令营的实变函数整理</li><li>Tags: #Analysis#​, #RealAnalysis#​, #SummerCamp#​</li></ul><hr /><h2 id="集合论">集合论</h2><h3 id="集合">集合</h3><h4 id="集合运算">集合运算：</h4><ol type="1"><li>代数 – 交并补差</li><li>分析 – 上下极限</li><li>直积</li></ol><p>上下极限可以有两种定义方式：</p><p><span class="math display">\[\lim\sup _{n\rightarrow \infty} A_n =\lim _{ n \rightarrow\infty}\bigcup_{k = n}  ^ \infty A_n  = \bigcap _ { n = 1} ^\infty\bigcup_{k = n}  ^ \infty A_n\]</span></p><p>对于下极限同样定义。</p><h4 id="上极限和下极限相关内容">上极限和下极限相关内容：</h4><p>集合的上下确界 <span class="math inline">\(\sup, \inf\)</span></p><dl><dt>Theo</dt><dd>确界存在定理</dd></dl><p>上下极限也可以通过上下界定义：</p><p><span class="math display">\[\lim \sup = \inf \sup \quad \lim \inf = \sup \inf\]</span></p><blockquote><p>类比点列、函数的上下极限定义</p></blockquote><h3 id="映射">映射</h3><ol type="1"><li>映射</li><li>集合势</li></ol><p>研究可列：</p><ol type="1"><li>任何无穷集合中包含可列的子集</li><li>可列集的无穷子集可列</li><li>可列集的交并都可列</li></ol><h3 id="rn-空间">Rn 空间</h3><ol type="1"><li>定义 <span class="math inline">\({\mathbb R}^n\)</span></li><li>线性空间、范数、柯西不等式、距离、球</li></ol><p>考察点集：</p><ol type="1"><li>点：内点、边界点、聚点</li><li>诱导集合：闭包、边界</li><li>相互关系：稠密</li></ol><h4 id="闭集开集borel-集">闭集、开集、Borel 集</h4><ol type="1"><li>闭集、开集的定义</li></ol><p>极限性质：</p><ol type="1"><li>开集的并始终是开的，两个开集的交是开的</li><li>闭集的交始终是闭的，两个闭集的并是闭的</li><li>从而定义 <span class="math inline">\(F_\sigma\)</span>型集（可数闭集并）和 <span class="math inline">\(G_\delta\)</span>型集（可数开集的交）</li></ol><p>推广上述性质：<span class="math inline">\(\sigma\)</span>-代数</p><h4 id="开集结构连续性">开集结构、连续性</h4><dl><dt>Theo</dt><dd><span class="math inline">\({\mathbb R}\)</span>上任意非空开集是至多可数个开集的并</dd><dt>Theo</dt><dd><span class="math inline">\({\mathbb R}^n\)</span>上的任意非空开集是之多可数个互不相交的半开矩体的并。</dd></dl><p>通过这两个定理，我们来观察函数的连续性：</p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(f:{\mathbb R}^n \rightarrow {\mathbbR}\)</span> 则 TFAE：</dd></dl><ol type="1"><li><span class="math inline">\(f\in C\)</span></li><li><span class="math inline">\(\forall \lambda, \{f &lt; \lambda\}, \{f&gt; \lambda \}\)</span> 是开的</li><li><span class="math inline">\(\forall \lambda, \{f &lt;= \lambda\},\{f &gt;= \lambda \}\)</span> 是闭的</li></ol><h4 id="基本定理">基本定理</h4><ol type="1"><li>Cauchy-收敛原理</li><li>有限覆盖定理</li><li>闭区间套定理</li><li>魏尔斯特拉斯定理</li></ol><p>关于紧集：</p><ol type="1"><li>定义：任意开覆盖有有限子覆盖</li><li>性质：在 <span class="math inline">\({\mathbb R} ^ n\)</span>中就是有界闭集</li></ol><h2 id="勒贝格测度">勒贝格测度</h2><h3 id="外测度可测集">外测度、可测集</h3><h4 id="外测度">外测度</h4><dl><dt>外测度</dt><dd>设 <span class="math inline">\(E\)</span> 是 <spanclass="math inline">\({\mathbb R} ^ n\)</span> 中的点集，若 <spanclass="math inline">\(\{I_k\}\)</span> 是一列开矩体，且为 <spanclass="math inline">\(E\)</span> 的一个开覆盖，确定了一个实数：<spanclass="math inline">\(u = \sum _{k} I_k\)</span>，令：</dd></dl><p><span class="math display">\[m^*(E) = \inf \{u\}\]</span></p><p>称为其的 <span class="math inline">\(Lebesgue\)</span> 外测度。</p><p>关于外测度的性质：</p><ol type="1"><li>非负性</li><li>单调性</li><li>次可加性</li><li>平移不变性</li></ol><blockquote><ol type="1"><li>单点集、可数点集的外测度都为 0</li><li><span class="math inline">\(n-1\)</span> 维超平面测度为 0</li><li>康托集外测度为 0</li></ol></blockquote><p>题目</p><ol type="1"><li><p>求证 <span class="math inline">\(m^* = \sup / \inf\)</span>这一类</p><ol type="1"><li>一般一边好证明（直接用单调性）</li><li>另一边用次可加性 +<span class="math inline">\(\varepsilon\)</span>的任意性来描述</li></ol></li><li><p>求证有子集满足 xxx 条件</p><ol type="1"><li>设函数，利用连续性</li></ol></li></ol><h4 id="lebesgue-可测集">Lebesgue 可测集</h4><p>外测度不符合可加性！因此在集合上加 Carathedory 条件：</p><dl><dt>可测</dt><dd>设 <span class="math inline">\(E \subseteq {\mathbb R} ^ n\)</span> 如果<span class="math inline">\(\forall T \subset {\mathbb R} ^n\)</span>，有</dd></dl><p><span class="math display">\[m^*(T) = m^*(T \cap E) + m^*(T\cap E^c)\]</span></p><p>则称之为 Lebesgue 可测，全体记为 <span class="math inline">\(\mathcalM\)</span> 测度即其外侧度</p><blockquote><p>上述条件中实际上只需要 <span class="math inline">\(\ge\)</span>成立即可（另一侧自然成立）</p></blockquote><p>考虑原来的简单集合：</p><p>Theorem:</p><ol type="1"><li>外测度的零测集是可测的，即为零测集。</li><li>对开矩体而言，其测度为其“长度”</li></ol><p>对于可测集，其具有如下性质：</p><ol type="1"><li>空集可测，测度为 0</li><li>可测集的交并补差都是可测集</li><li><strong>可数可加性</strong>：对于互不相交的可测集 <spanclass="math inline">\(E_i\)</span>，取并和取测度可换</li><li>平移不变性</li></ol><p>进一步考察和极限的关系：</p><dl><dt>Theo</dt><dd>可测集合的可数交是可测的</dd></dl><p>考虑极限和测度交换：</p><dl><dt>Theo</dt><dd>对于递增的可测集列 <spanclass="math inline">\(E_i\)</span>，则其极限可测，且有极限和测度可换</dd><dt>Theo</dt><dd>对于递减的可测集列 <span class="math inline">\(E_i\)</span>，若存在<span class="math inline">\(m(E_i) &lt;+\infty\)</span>，则其极限可测，且有极限和测度可换</dd></dl><blockquote><p>上式要求存在一个集合测度有限：考察 <span class="math inline">\(E_i =[i, \infty)\)</span> 的极限的测度和其测度的极限</p></blockquote><p>下面的定理表述了可测集和 Borel 集的关系</p><dl><dt>Theo</dt><dd>若 <span class="math inline">\(E\)</span> 可测，则存在 Borel 集 <spanclass="math inline">\(G, F\)</span>，使得 <spanclass="math inline">\(F\subset E\subset G\)</span> 且 <spanclass="math inline">\(m(F) = m(E) = m(G)\)</span>换句话说，对于任意可测集，存在 Borel 集来从两侧（在测度意义上）逼近。</dd></dl><h4 id="测度空间">测度空间</h4><blockquote><p>TODO</p></blockquote><h3 id="可测函数">可测函数</h3><p>对于函数，正如我们一开始用开集闭集来表征连续性一样，考察用可测集来表述可测性。</p><dl><dt>可测函数</dt><dd>设 <span class="math inline">\(E \subseteq \mathbb R^n\)</span>可测，<span class="math inline">\(f\)</span> 是 <spanclass="math inline">\(E\)</span> 上的函数，若对于任何 <spanclass="math inline">\(t\in {\mathbb R}\)</span> 有</dd></dl><p><span class="math display">\[E(f&gt;t) := \{x\in E| f(x) &gt; t\}\]</span></p><p>都可测，则称函数在 <span class="math inline">\(E\)</span> 上可测，用<span class="math inline">\(M(E)\)</span> 表示。</p><ol type="1"><li>对于上述定理中的 <span class="math inline">\(t\inE\)</span>，只需要考察稠密的 <span class="math inline">\(t\inE&#39;\subset E\)</span> 即可</li><li>对于 <span class="math inline">\(&gt;\)</span>，可以等价替换为 <spanclass="math inline">\(\ge, \le , &lt;\)</span></li></ol><p>对于以上的定义，我们还有一些基础的结论：</p><ol type="1"><li>可测函数列的收敛点集和发散点集是可测的。</li><li>若 <span class="math inline">\(f,g\)</span> 都可测，则 <spanclass="math inline">\(E[f&gt;g], E[f\ne g]\)</span> 可测（用有理数集插在<span class="math inline">\(f,g\)</span> 之间）</li></ol><p>我们考察在这个定义下的简单函数，他们通过特征函数来定义：</p><dl><dt>简单函数</dt><dd>设有互不相交的 <span class="math inline">\(E_i\)</span> 是 <spanclass="math inline">\(E\)</span> 的一个分划，称</dd></dl><p><span class="math display">\[\varphi (x) = \sum_{i = 1} ^ m \alpha _ i \chi _{E_i} (x)\]</span></p><p>是简单函数，当 <span class="math inline">\(E_i\)</span>是矩体时，<span class="math inline">\(\varphi\)</span> 是阶梯函数</p><p>显然，简单函数是可测的。而下面的定理说明了简单函数能够构建出一个可测函数：</p><h4 id="基本性质">基本性质</h4><dl><dt>Theo</dt><dd>对于可测函数集，</dd></dl><ol type="1"><li>是线性空间（对非零除法也是）</li><li>连续函数都可测</li></ol><p>下面考察其极限性质：</p><dl><dt>Theo</dt><dd>对于可测函数列的 <span class="math inline">\(f_k\)</span> 的上确界，下确界，上极限，下极限 都是可测函数</dd><dt>Theo</dt><dd>对于可测函数列，若 <span class="math inline">\(f_k \rightarrowf\)</span>，则 <span class="math inline">\(f\)</span> 可测。</dd></dl><p>下面考虑取绝对值前后的可测性：</p><dl><dt>Theo</dt><dd>对于实值函数，可测的充要条件是正部和负部都是可测的，且若 <spanclass="math inline">\(f\)</span> 可测，则 <spanclass="math inline">\(|f|\)</span> 可测</dd></dl><p>考虑复合函数的可测性：</p><dl><dt>Theo</dt><dd>对于 <span class="math inline">\(f\in C\)</span> 和 <spanclass="math inline">\(g\in M\)</span> 有 <spanclass="math inline">\(h=f\circ g\)</span> 可测</dd></dl><p>下面引入几乎处处的概念：</p><dl><dt>几乎处处</dt><dd>称 E 在 <span class="math inline">\(A\)</span> 几乎处处满足P(E)，是指存在一个固定的零测的 <span class="math inline">\(Z\)</span>使得对 <span class="math inline">\(A - Z\)</span> 满足 P(E)</dd></dl><p>从而，我们有：</p><dl><dt>Theo</dt><dd>对于实函数，若 <span class="math inline">\(f = g\quad a.e.\)</span> 则<span class="math inline">\(f\)</span> 与 <spanclass="math inline">\(g\)</span> 有相同的可测性。</dd></dl><p>从上面的描述中不难看出，相比于<strong>连续性</strong>，可测性在极限运算下具有良好的性质（保持、交换），这也是我们需要可测的原因。</p><h4 id="测度空间上的可测函数">测度空间上的可测函数</h4><blockquote><p>TODO</p></blockquote><h3 id="lesbegue-可测函数列的收敛性">Lesbegue 可测函数列的收敛性</h3><p>这一节，我们详细讨论收敛的概念。</p><h4 id="几乎处处收敛几乎一致收敛">几乎处处收敛/几乎一致收敛</h4><dl><dt>几乎处处收敛</dt><dd>（直接从几乎处处收敛的定义得到）</dd></dl><p>相对于几乎处处收敛，我们有稍弱一些的几乎一致收敛，其描述的是定义域极限意义下的收敛性。（即我们不需要得到零测集，而得到测度充分小的集合）</p><dl><dt>几乎一致收敛</dt><dd><span class="math inline">\(\forall \delta &gt; 0, \exists E_\delta\subset E\)</span> 使得（测度充分小）<spanclass="math inline">\(m(E_\delta) &lt; \delta\)</span>，且在 <spanclass="math inline">\(E - E_\delta\)</span> 上满足一直收敛到 <spanclass="math inline">\(f\)</span>。</dd></dl><p>下面的定理说明了这两个收敛行的关系：</p><dl><dt>叶戈罗夫定理</dt><dd>对于<strong>有限测度集</strong>上的几乎处处<strong>有限</strong>的可测函数列，若函数列几乎处处收敛，则函数列几乎一致收敛</dd></dl><p>有限和有界是不同的：<span class="math inline">\(y = 1/x\)</span> 在<span class="math inline">\((0, 1)\)</span>无界，但其是有限的。有界是对于区间而言，而有限是对于点（<spanclass="math inline">\(&lt; +\infty\)</span> 而言）</p><h4 id="依测度收敛">依测度收敛</h4><p>条件更弱，去掉的集合甚至不一定“稳定”，即该集合只需要测度的极限为0，而不需要考虑其极限是否存在。</p><dl><dt>依测度收敛</dt><dd>对于几乎处处有限的可测函数，对于给定的 <spanclass="math inline">\(\epsilon&gt;0\)</span>，其能够满足</dd></dl><p><span class="math display">\[m(E(|f_k - f| &gt; \epsilon)) \rightarrow 0\]</span></p><p>则其是在 <span class="math inline">\(E\)</span> 上依测度收敛到 <spanclass="math inline">\(f\)</span>（<spanclass="math inline">\(f_k\rightarrow_m f\)</span>）</p><p>显然，几乎处处收敛和几乎一致收敛蕴含了依测度收敛。但依测度收敛给出了收敛到什么函数的本质问题。</p><dl><dt>Theo</dt><dd>若函数列 <span class="math inline">\(f_k\)</span> 依测度收敛于 <spanclass="math inline">\(f, g\)</span> ，则 <span class="math inline">\(f=g \quad a.e.\)</span></dd><dt>Theo — 勒贝格定理</dt><dd>对于有限测度集上的几乎处处有限的可测函数，则其依测度收敛到该极限函数</dd></dl><blockquote><p>如果我们将几乎处处相等作为等价关系，实变函数考察的始终是这个等价关系下对于可测函数集的划分。</p></blockquote><p>考虑从依测度收敛到几乎处处收敛的条件：</p><dl><dt>Theo — Riesz 引理</dt><dd>若 <span class="math inline">\(f_k \rightarrow _mf\)</span>，则存在子列几乎处处收敛到 <spanclass="math inline">\(f\)</span></dd></dl><p>依测度收敛意义下，我们可以类比柯西收敛准则：</p><dl><dt>依测度基本列</dt><dd>设有 <span class="math inline">\(f_k\)</span> 为 <spanclass="math inline">\(E\)</span> 上几乎处处有限的可测函数列，若</dd></dl><p><span class="math display">\[\forall \varepsilon &gt; 0, \quad \lim_{k , j \rightarrow \infty}m(E(|f_i - f_j| &gt; \varepsilon)) = 0\]</span></p><p>则称其为 <span class="math inline">\(E\)</span> 上的依测度基本列</p><p>类似柯西收敛准则：</p><dl><dt>Theo</dt><dd>对于几乎处处有限的可测函数列，依测度收敛当且仅当它是依测度基本列</dd></dl><h4 id="可测函数和连续函数的关系">可测函数和连续函数的关系</h4><p>连续函数在数学分析中具有重要的作用（特别是一致连续的函数）。因此我们考察连续和可测之间是否有一定的联系。</p><p>下面的定理描述了函数可测和连续之间的差别。</p><dl><dt>Theo — 鲁金定理</dt><dd>设 <span class="math inline">\(f\)</span>是<strong>有限测度集</strong>上几乎处处有限的可测函数，对于任一（充分小的）<spanclass="math inline">\(\delta &gt; 0\)</span>，存在 <spanclass="math inline">\(E\)</span> 中的闭集 <spanclass="math inline">\(F\)</span>，满足 <span class="math inline">\(m(E\backslash F) &lt; \delta\)</span> 使 <spanclass="math inline">\(f\)</span> 在 <spanclass="math inline">\(F\)</span> 上连续。</dd></dl><p>下面的定理描述了如何从连续函数构造一个可测函数：</p><dl><dt>Theo</dt><dd>对于任意可测函数 <span class="math inline">\(f\)</span>，存在连续函数列<span class="math inline">\(g_k\)</span>，使得 <spanclass="math inline">\(g_k \rightarrow f\quad a.e.\)</span></dd></dl><p>上面的定理可以推广为：</p><dl><dt>Theo</dt><dd>对于几乎处处有限的函数 <span class="math inline">\(f\)</span>，<spanclass="math inline">\(f\)</span> 可测，当且仅当 <spanclass="math inline">\(\exists g_k\in C\)</span> 使得 <spanclass="math inline">\(g_k \rightarrow f\quad a.e.\)</span></dd></dl><h2 id="lebesgue-积分">Lebesgue 积分</h2><p>至此，我们得到了可测函数优秀的极限性质，我们开始考虑一类特殊的极限 –积分，这也是实变函数论目的：给积分 -极限之间的互换关系一个完备的解释。</p><h3 id="lebesgue-可测函数的积分">Lebesgue 可测函数的积分</h3><h4 id="非负可测函数的积分">非负可测函数的积分</h4><dl><dt>非负简单函数的积分</dt><dd>设 <span class="math inline">\(h(x)\)</span> 是可测集 <spanclass="math inline">\(E\)</span> 上的非负可测函数，定义</dd></dl><p><span class="math display">\[h(x) = \sum_{j = 1} ^ m a_j m(E_j) \Longrightarrow \int _ E h(x) \mathrmdx = \sum _{j = 1} ^ m a_j m ( E _ j )\]</span></p><p>为 <span class="math inline">\(h(x)\)</span> 在可测集 <spanclass="math inline">\(E\)</span> 傻姑娘的积分。</p><p>关于上面定义的积分，其满足：</p><ol type="1"><li>线性性质</li><li>对定义域的连续性：</li></ol><p><span class="math display">\[\lim E_k = E \Rightarrow \lim \int _{E_k} h(x)\mathrm dx = \int _ E h(x)\mathrm dx\]</span></p><p>其中的 <span class="math inline">\(\mathrm d\)</span>仅仅是一个记号，并不代表自变量的微元。</p><p>从而我们可以定义：</p><dl><dt>非负可测函数的积分</dt><dd>对于 <span class="math inline">\(f\in \mathcal M ( E)\)</span> 定义</dd></dl><p><span class="math display">\[\int _ E f(x) \mathrm dx = \sup \left\{ \int _ E h(x) \mathrm dx | h(x)\le f(x), h(x) 是简单函数 \right\}\]</span></p><p>若上式有限，则称 <span class="math inline">\(f\)</span> 在 <spanclass="math inline">\(E\)</span> 上可积。</p><p>综合上面的定义可以看出：</p><ol type="1"><li><p>对于一个零测集，任何函数的积分都为 0（因为在实变函数中我们是中认为 <span class="math inline">\(0 \cdot\infty = 0\)</span>）</p></li><li><p>对于一个非负可测函数，我们通过和特征函数内积来确定在子集上的积分：</p><p><span class="math display">\[\int _A f = \int _E f \cdot \chi _ A\]</span></p></li><li><p>积分具有保序性</p></li></ol><p>同时，由于上述的定义中 <strong>可积</strong>这个条件实际上非常宽泛，所以我们很容易得到这样的结论：</p><dl><dt>Theo</dt><dd>有限测度集上的几乎处处有界函数必可积。</dd></dl><p>这是区别于 Riemann 积分很大的一个地方，因为在 Riemann积分中，我们甚至连 dirichlet 函数的积分都无法定义！</p><p>下面介绍一个著名的定理，它揭示了可测函数积分在极限过程中体现出的性质：</p><dl><dt>Levi Theo</dt><dd>设 <span class="math inline">\(\{ f _ k \}\)</span> 是可测集 <spanclass="math inline">\(E\)</span> 上的非负可测函数，满足 <spanclass="math inline">\(f_1 \le f_2 \le \cdots\)</span> 且有</dd></dl><p><span class="math display">\[\lim _ {k \rightarrow \infty} f_k ( x) = f(x), \quad \forall x \in E\]</span></p><p>则有</p><p><span class="math display">\[\lim _ {k \rightarrow \infty} \int _ E f_k (x)\mathrm dx = \int _ E f(x)\mathrm dx\]</span></p><p>这个定理说明，对于单调、收敛的可测函数，其积分的极限就是极限的积分。</p><h4 id="一般可测函数">一般可测函数</h4><p>通过非负可测函数的积分、将可测函数分为正负两部分，我们可以定义：</p><dl><dt>可测函数积分</dt><dd>设 <span class="math inline">\(f\)</span> 是可测函数，<spanclass="math inline">\(f^+\)</span> 和 <spanclass="math inline">\(f^-\)</span> 至少有一个是可积的，则称</dd></dl><p><span class="math display">\[\int_E f(x) \mathrm dx = \int _ E f ^+ (x)\mathrm dx - \int _ E f ^ -(x) \mathrm dx\]</span></p><p>是 <span class="math inline">\(f\)</span> 在 <spanclass="math inline">\(E\)</span>上的积分，如果右端两个积分都有限，则称该函数可积 <spanclass="math inline">\(f\in \mathcal L(E)\)</span>。</p><p>显然，其具有这样的简单性质：</p><p><span class="math display">\[f\in \mathcal L ( E ) \rightarrow | \int_E f(x)\mathrm dx| \le \int _ E| f(x) | \mathrm dx\]</span></p><dl><dt>Theo Lebesgue 可测函数积分性质</dt><dd>对于积分：</dd></dl><ol type="1"><li><span class="math inline">\(|f| &lt; \infty,\quad a.e.\)</span></li><li>如果其中一个可积，<span class="math inline">\(f = g\quada.e.\implies \int f = \int g\)</span></li><li>（控制性）若存在 <span class="math inline">\(|f| &lt; |g|\in\mathcal L\)</span>，则 <span class="math inline">\(f\in \mathcalL\)</span>，且 <span class="math inline">\(|\int f| \le \int|g|\)</span></li><li>对于有限测度集，有界函数都可积</li></ol><dl><dt>Theo</dt><dd>Lebesgue 积分具有线性性</dd></dl><p>下面给出 Lebesgue 积分的等价描述</p><dl><dt>Theo 可积/积分的等价描述</dt><dd>设 <span class="math inline">\(f\)</span>是<strong>有限测度集</strong>上的<strong>有界可测</strong>函数，<spanclass="math inline">\(|f| \le M\)</span>，作 <spanclass="math inline">\([-M, M]\)</span> 的划分，</dd></dl><p><span class="math display">\[-M = \alpha_0 &lt; \cdots &lt; \alpha_k = M\]</span></p><p>设 <span class="math inline">\(E_j= E(\alpha_{j-1} &lt; f &lt;\alpha_j)\)</span>，对于任意的</p><p><span class="math display">\[\eta_j \in [\alpha_{j - 1}, \alpha _ j]\]</span></p><p>极限</p><p><span class="math display">\[\lim_{\max \alpha_j - \alpha_{j-1} \rightarrow 0} \sum_{j = 1} ^ k\eta_j m(E_j)\]</span></p><p>存在，则该极限就是 Lebesgue 积分。</p><p>对于 Lebesgue积分，其具有绝对连续性（定义域测度充分小，则积分值充分小）：</p><dl><dt>Theo 绝对连续性</dt><dd>设 <span class="math inline">\(f\in \mathcal L\)</span>，则对于任意的<span class="math inline">\(\varepsilon &gt; 0\)</span>，存在 <spanclass="math inline">\(\delta &gt;0\)</span>，使得对于<strong>任何</strong>的子集 <spanclass="math inline">\(A\)</span>，当 <span class="math inline">\(m(A)&lt; \delta\)</span> 时，</dd></dl><p><span class="math display">\[|\int_A f(x) \mathrm dx | \le \int_A |f(x)|\mathrm dx \le \varepsilon\]</span></p><p>当然，对于 Lebesgue 积分，也有平移不变性。</p><p>我们之前考察了可测和连续的关系，在这里我们也有类似的结论：</p><dl><dt>Theo</dt><dd>对于任意 Lebesgue 可积函数，对于任意 <spanclass="math inline">\(\varepsilon &gt;0\)</span>，存在一个具有紧支集的连续函数 <spanclass="math inline">\(g\)</span> 使得</dd></dl><p><span class="math display">\[\int_ E| f(x) - g(x) | \mathrm dx &lt; \varepsilon\]</span></p><p>。因此，可以构造具有紧支集的连续函数列 <spanclass="math inline">\(g_k\)</span>，使得</p><p><span class="math display">\[\lim_{k\rightarrow \infty}\int_ E| f(x) - g_k(x) | \mathrm dx &lt;\varepsilon, \quad 即 g_k \rightarrow f\quad a.e.\]</span></p><h4 id="riemann-积分和-lebesgue-积分的关系">Riemann 积分和 Lebesgue积分的关系</h4><dl><dt>Theo Riemann 积分和 Lebesgue 积分值的相等性</dt><dd>闭区间上有界函数 <span class="math inline">\(f(x)\)</span> Riemann可积，则它时 Lebesgue 可积的且其积分值相等。</dd></dl><h4 id="测度空间上的可测函数积分">测度空间上的可测函数积分</h4><h3 id="极限定理">极限定理</h3><p>这一节我们考虑极限和 Lebesgue 积分的互换关系。</p><dl><dt>Lebesgue 基本定理</dt><dd>设 <span class="math inline">\(f_n\)</span> 是可测集 <spanclass="math inline">\(E\)</span> 上的非负可测函数列，</dd></dl><p><span class="math display">\[f(x) = \sum_{n = 1} ^ \infty f_n(x)\]</span></p><p>则</p><p><span class="math display">\[\int _ E f(x) \mathrm dx = \sum _ {n = 1} ^ \infty \int _ E f_n (x)\mathrm dx\]</span></p><blockquote><p>正函数项级数，和函数积分为积分的和。（积分与求和交换）</p></blockquote><p>从上述定理，我们可以应用到定义域上：</p><dl><dt>Col</dt><dd>设 <span class="math inline">\(E = \bigsqcup E_n\)</span>，若 <spanclass="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(E\)</span> 上有积分时，<spanclass="math inline">\(f(x)\)</span> 在每一个子集 <spanclass="math inline">\(E_n\)</span> 时有积分的，且</dd></dl><p><span class="math display">\[\int _ E f(x) \mathrm dx = \sum _ {n = 1} ^ \infty \int _{E_n} f(x)\mathrm dx\]</span></p><p>我们始终不希望只考虑单调的函数列</p><dl><dt>Fatou 引理</dt><dd>对于非负可测函数列 <span class="math inline">\(f_n\)</span>，有</dd></dl><p><span class="math display">\[\int _ E \lim \inf f_n(x) \mathrm dx \le \lim \inf \int _ Ef_n(x)\mathrm dx\]</span></p><p>得到这样一个定理是不够的，我们希望得到更好的结论，而不局限于下确界和不等号：</p><dl><dt>控制收敛定理</dt><dd>给定可测集 <span class="math inline">\(E\)</span>，设 <spanclass="math inline">\(f_n\subset \mathcal M\)</span>，且有</dd></dl><p><span class="math display">\[f_n (x) \rightarrow f(x)\quad a.e.[E]\]</span></p><p>如果存在函数 <span class="math inline">\(F(x) \in \mathcalL(E)\)</span>，控制了 <span class="math inline">\(|f_n| \le F\quad,a.e.[E]\)</span>，那么，<span class="math inline">\(f\in \mathcalL(E)\)</span> 且</p><p><span class="math display">\[\lim _ {n \rightarrow \infty} \int_{E} f_n (x) \mathrm dx = \int_ E f(x)\mathrm dx\]</span></p><p>从而，我们有如下几个定理：</p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(E\)</span> 是可测集，<spanclass="math inline">\(f_n\)</span> 是 <spanclass="math inline">\(E\)</span> 上的可测函数列，该函数列依测度收敛到<span class="math inline">\(f\)</span> ，若存在 <spanclass="math inline">\(F\in \mathcal L(E)\)</span> 使得 <spanclass="math inline">\(|f_n| \le F, a.e.[E]\)</span> 则 <spanclass="math inline">\(f_n, f\)</span> 都在 <spanclass="math inline">\(E\)</span> 上 Lebesgue 可积，且积分和极限可换。</dd></dl><p>当然，对于有界函数，其在有限测度集上积分有很好的性质：</p><dl><dt>Theo 有界收敛原理</dt><dd>设 <span class="math inline">\(m(E)&lt; \infty\)</span>，<spanclass="math inline">\(\{f_n\} \subset L(E)\)</span>且一致有界，则当其依测度收敛时，其积分和极限可换。</dd></dl><p>对于函数项级数，有类似的定理：</p><dl><dt>Theo</dt><dd>对于可积函数列，若</dd></dl><p><span class="math display">\[\sum _ {n = 1} ^ \infty \int _ E | f_n ( x ) | \mathrm dx &lt; \infty\]</span></p><p>则级数 <span class="math inline">\(\sum f_n (x)\)</span> 在 <spanclass="math inline">\(E\)</span>上几乎处处收敛，且和函数的积分是各函数积分的和。</p><h4 id="riemann-可积的刻画">Riemann 可积的刻画</h4><p>首先，我们使用振幅函数来入手描述 Riemann 可积性</p><dl><dt>Theo</dt><dd>对于区间上的有界函数 <span class="math inline">\(f\)</span>，有</dd></dl><p><span class="math display">\[\int _ I \omega _f (x) \mathrm dx = \bar \int _ a ^ b f -\underline{\int}_{a}^b f\]</span></p><p>与此同时，我们揭示了 Riemann 可积的充要条件：</p><dl><dt>Riemann 可积</dt><dd>对闭区间上的有界函数 <span class="math inline">\(f\)</span> ：Riemann可积，当且仅当不连续点集是零测的</dd></dl><h3 id="重积分和累次积分">重积分和累次积分</h3><blockquote><p>重积分的交换就是极限过程的交换。</p></blockquote><h4 id="fubini-定理">Fubini 定理</h4><dl><dt>截口</dt><dd>设 <span class="math inline">\(E\subset {\mathbbR}^{p+q}\)</span>，对于任意的 <span class="math inline">\(x\in {\mathbbR}^p\)</span>，令</dd></dl><p><span class="math display">\[E_x = \{ y \in {\mathbb R}^ q| (x, y) \in E\}\]</span></p><p>对于任意的 <span class="math inline">\(y\)</span>，对应定义 <spanclass="math inline">\(E_y\)</span>。其中，<spanclass="math inline">\(E_x\)</span> 称为 <spanclass="math inline">\(E\)</span> 的 <spanclass="math inline">\(x\)</span> 截口</p><p>显然：</p><p><span class="math display">\[m(E) = \int _ {\mathbb R ^ p} m(E_x)\mathrm dx = \int _ {\mathbb R ^ q}m(E_y)\mathrm dy\]</span></p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(n = p + q\)</span>，<spanclass="math inline">\(E \in \mathcal M _ n\)</span> 则</dd></dl><ol type="1"><li>对几乎处处的 <span class="math inline">\(x\in \mathbb R ^p\)</span>，有 <span class="math inline">\(E_x \in \mathbbR^q\)</span></li><li><span class="math inline">\(m(E_x)\)</span> 在 <spanclass="math inline">\(\mathbb R^q\)</span>上几乎处处有定义，且是非负可测函数</li></ol><p>借助截口，我们一步步引入 Fubini定理，来解决重积分和累次积分关系的问题：</p><dl><dt>Theo</dt><dd>假设 <span class="math inline">\(E_1\)</span> 和 <spanclass="math inline">\(E_2\)</span> 是 <spanclass="math inline">\(\mathbb R^p\)</span> 和 <spanclass="math inline">\(\mathbb R^q\)</span> 中的可测集则 <spanclass="math inline">\(E_1\times E_2 \in M_n\)</span> 且有</dd></dl><p><span class="math display">\[m(E_1\times E_2) = m(E_1)m(E_2)\]</span></p><p>借助该定理，以及测度、积分在极限下的交换关系，我们有：</p><dl><dt>Toneli</dt><dd>设 <span class="math inline">\(n = p + q\)</span>，<spanclass="math inline">\(f(x,y)\in \mathcal M (\mathbb R ^ {p +q})\)</span> 且非负，则</dd></dl><ol type="1"><li>对于几乎处处的 <span class="math inline">\(x\in \mathbb R ^p\)</span>，<span class="math inline">\(f(x, \cdot )\)</span>是非负可测函数；</li><li>积分 <span class="math inline">\(F_f(x) = \int _ {\mathbb R^q}f(x,y) \mathrm dy\)</span> 几乎处处有定义，是非负可测函数；</li><li>重积分和累次积分相等。</li></ol><p>对于上述定理，我们可以将条件加强为 <code>可积</code>，得到：</p><dl><dt>Fubini 定理</dt><dd>设 <span class="math inline">\(n = p + q\)</span>，<spanclass="math inline">\(f(x,y)\in \mathcal L (\mathbb R ^ {p +q})\)</span>，则</dd></dl><ol type="1"><li>对于几乎处处的 <span class="math inline">\(x\in \mathbb R ^p\)</span>，<span class="math inline">\(f(x, \cdot )\)</span>可积；</li><li>积分 <span class="math inline">\(F_f(x) = \int _ {\mathbb R^q}f(x,y) \mathrm dy\)</span> 几乎处处有定义，且可积；</li><li>重积分和累次积分相等。</li></ol><p>至此，我们已经几乎研究完了定积分的极限性质，下面将研究微积分基本定理的成立条件</p><h2 id="微分和不定积分">微分和不定积分</h2><h3 id="单调函数的可微性">单调函数的可微性</h3><p>我们先研究单调函数，它是一个性质好（有界变差）的函数！</p><dl><dt>Vitali 覆盖</dt><dd>设 <span class="math inline">\(E \subset \mathbb R\)</span>，设 <spanclass="math inline">\(\tau = \{ I _ \alpha \}\)</span>是一个区间族，若对于任意的 <span class="math inline">\(x\in E\)</span>和 <span class="math inline">\(\varepsilon &gt; 0\)</span>，存在一个<span class="math inline">\(I_\alpha \in \tau\)</span>，使得 <spanclass="math inline">\(x\in I _ \alpha\)</span> 且 <spanclass="math inline">\(|I_\alpha| &lt; \varepsilon\)</span>，则称 <spanclass="math inline">\(E\)</span> 是在 Vitali 意义下的覆盖。</dd></dl><p>研究 Vitali覆盖，一方面是因为其对于任意点都可以找到充分小的区间覆盖，另一方面是其可以任意有限外测度集合，都能找到误差充分笑的有限覆盖：</p><dl><dt>Vitali 覆盖定理</dt><dd>设 <span class="math inline">\(E \subset \mathbb{R}\)</span>，且 <spanclass="math inline">\(m^*(E)&lt;\infty\)</span>，则对于任意的 <spanclass="math inline">\(\varepsilon &gt; 0\)</span> 存在有限个互不相交的<span class="math inline">\(I_j\in \tau\)</span> 使得</dd></dl><p><span class="math display">\[m^*(E -\cup_{j=1}^n I_j) &lt; \varepsilon\]</span></p><p>srds，这个东西用的也不多。我们下面先考虑微分的问题：</p><dl><dt>Dini 导数</dt><dd>记如下的</dd></dl><p><span class="math display">\[D^+f(x_0):= \limsup_{h\rightarrow 0 ^ +} \frac{f(x_0 + h) - f(x_0)}{h}\]</span></p><p>同理定义 <span class="math inline">\(D^-,D_+,D_-\)</span> 为 Dini导数。</p><p>显然，函数可导（左右同理），当且仅当 Dini 导数全部存在且相等。</p><dl><dt>Lebesgue 定理</dt><dd>设 <span class="math inline">\(f(x)\)</span> 是 <spanclass="math inline">\([a,b]\)</span> 上的递增函数，那么 <spanclass="math inline">\(f\)</span> 的不可微点集为零测集，且有</dd></dl><p><span class="math display">\[\int_ a ^ b f&#39;(x) \mathrm dx \le f(b) - f(a)\]</span></p><p>例如，</p><p><span class="math display">\[f(x) = I(x&gt;0)\]</span></p><p>满足上述不等号（因为 <span class="math inline">\(0\cdot \infty =0\)</span>）</p><dl><dt>Fubini 逐项积分定理</dt><dd>设 <span class="math inline">\(f_n\)</span> 是 <spanclass="math inline">\([a,b]\)</span> 上的递增函数列，且 <spanclass="math inline">\(\sum_{n = 1} ^ \infty f_n\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上收敛，那么有：</dd></dl><p><span class="math display">\[\frac{d}{dx} \left(\sum_{n = 1}^\infty f_n(x)\right)= \sum_{n = 1}^\infty \frac{d}{dx}f_n(x) \quad a.e.\]</span></p><p>至此，我们已经解决了一些问题，至少对于单调函数而言是这样的。</p><h3 id="有界变差函数">有界变差函数</h3><p>这里我们引入有界变差函数，用于描述这个函数的在充分小的区间里<strong>变化</strong>的能力。</p><dl><dt>有界变差函数</dt><dd>设 <span class="math inline">\(f\)</span> 是 <spanclass="math inline">\([a,b]\)</span> 上的实函数，做定义域的分划，则：</dd></dl><p><span class="math display">\[V_\Delta = \sum_{i = 1}^n | f(x_i) - f(x_{i-1}|)\]</span></p><p>是 <span class="math inline">\(f\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上的一个变差。对上式取上极限：</p><p><span class="math display">\[\bigvee_{a}^b (f)  := \sup\{V_\Delta\}\]</span></p><p>是函数在该区间上的<strong>全变差</strong>，若上式有限，那么 <spanclass="math inline">\(f\)</span> 是 <spanclass="math inline">\([a,b]\)</span> 上的有界变差函数。</p><p>显然：</p><ol type="1"><li>单调函数是有界变差函数</li><li>可微函数是有界变差函数</li><li>有界变差函数空间是线性空间。</li></ol><p>有界变差函数对于函数做出了一定的限制，即全区间上的绝对变化是有界的。显然：</p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(f(x)\)</span> 是一个实函数，<spanclass="math inline">\(a&lt;c&lt;b\)</span>，有：</dd></dl><p><span class="math display">\[\bigvee_{a}^b (f) = \bigvee_{a}^c (f) +\bigvee_{c}^b (f)\]</span></p><p>直觉告诉我们，一个有界变差函数可能可以拆成两个函数的差：值增加的时候，为正的函数增加，值减少的时候，权为负的函数增加。那么我们有如下的定理成立：</p><dl><dt>Jordan 分解定理</dt><dd><span class="math inline">\(f \in BV([a,b])\)</span> 当且仅当 <spanclass="math inline">\(f = g - h\)</span>，其中 <spanclass="math inline">\(g, h\)</span> 是 <spanclass="math inline">\([a,b]\)</span> 上的递增函数</dd></dl><h3 id="不定积分的微分">不定积分的微分</h3><p>这里我们开始研究不定积分。而所谓不定积分，我们可以认为是一个变上限积分+C：</p><dl><dt>Lemma</dt><dd>设 <span class="math inline">\(f\in \mathcal L [a,b]\)</span>，令</dd></dl><p><span class="math display">\[F_h(x) = \frac{1}{h} \int _ x ^ {x + h} f(t) \mathrm dt\]</span></p><p>显然：</p><p><span class="math display">\[\lim_ {h\rightarrow 0} \int _ a ^ b |F_h( x) - f(x)| \mathrm dx = 0\]</span></p><p>因此，我们有如下的性质</p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(f\in \mathcal L\)</span>，令 <spanclass="math inline">\(F(x) = \int _a^x f(t) \mathrm dt\)</span>，则有</dd></dl><p><span class="math display">\[F&#39;(x) = f(x) \quad a.e. x\in [a,b]\]</span></p><h4 id="绝对连续函数和微积分基本定理">绝对连续函数和微积分基本定理</h4><p>至此，我们已经非常接近我们要的答案了（即微积分基本定理成立的充要条件）。为此，我们需要观察出变上限积分一些额外的性质</p><dl><dt>Lemma</dt><dd>设 <span class="math inline">\(f\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 几乎处处可微，且 <spanclass="math inline">\(f&#39;(x) = 0\quad a.e.\)</span>，如果 <spanclass="math inline">\(f(x)\)</span> 不是常函数，那么存在 <spanclass="math inline">\(\varepsilon&gt;0\)</span> 对于任意 <spanclass="math inline">\(\delta &gt; 0\)</span> 存在 <spanclass="math inline">\([a,b]\)</span>上有限个互不相交的区间，使得其测度之和小于 <spanclass="math inline">\(\delta\)</span>，但：</dd></dl><p><span class="math display">\[\sum_{i = 1} ^ n| f(y_i) - f(x_i)| &gt; \varepsilon\]</span></p><p>很显然我们之前构造的阶跃函数满足这样的条件。从而我们希望将这一类函数暂时得从我们的考虑范围内去除。</p><dl><dt>绝对连续函数</dt><dd>设 <span class="math inline">\(f(x)\)</span> 是实函数，若 <spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，存在 <spanclass="math inline">\(\delta &gt; 0\)</span>对于任意两个互不相交的开区间 <span class="math inline">\((x_i, y _ i)\)</span> 满足其 <span class="math inline">\(\sum |y_i - x_i| &lt;\delta\)</span> 且有</dd></dl><p><span class="math display">\[\sum_{i = 1} ^ n |f(y _ i ) - f(x_i)| &lt; \varepsilon\]</span></p><p>则称其为绝对连续函数</p><p>这类函数有些简单的结论：</p><ol type="1"><li>绝对连续函数是连续函数</li><li>绝对连续函数构成线性空间</li></ol><dl><dt>Theo</dt><dd>设 <span class="math inline">\(f\inL\)</span>，那么其变上限积分是绝对连续函数。</dd></dl><p>至此，我们找到了微积分基本定理成立的一个充分条件，借助上一节推出的结论，对一个函数先进行变上限积分，拿到的这个变上限积分函数是能够满足微积分基本定理的。这让我们不经怀疑，是否这个条件可以更进一步呢，我们直接引入微积分基本定理：</p><dl><dt>微积分基本定理</dt><dd>若 <span class="math inline">\(f(x)\)</span> 是 <spanclass="math inline">\([a,b]\)</span> 上的绝对连续函数，那么</dd></dl><p><span class="math display">\[f(x) - f(a) = \int _ a ^ x f&#39;(t) \mathrm dt\]</span></p><p>即绝对连续函数导数的积分就是自身。</p><p>综合以上的讨论，我们得出结论：</p><p>微积分基本定理成立 <span class="math inline">\(\iff\)</span>绝对连续</p><h3 id="分部积分公式和积分中值定理">分部积分公式和积分中值定理</h3><p>老朋友了：</p><dl><dt>分部积分公式</dt><dd>对于可积函数（作为被积函数）成立。</dd><dt>积分第一中值定理</dt><dd>若 <span class="math inline">\(f(x)\)</span> 是连续函数，且 <spanclass="math inline">\(g\)</span> 是非负可积函数，则存在一个 <spanclass="math inline">\(\xi \in [a,b]\)</span> 使得</dd></dl><p><span class="math display">\[\int f\cdot g = f(\xi)\int_a^b g(x) \mathrm dx\]</span></p><dl><dt>第二中值定理</dt><dd>若 <span class="math inline">\(f\int \mathcal L\)</span>，<spanclass="math inline">\(g\)</span> 单调，啧 <spanclass="math inline">\(\exists \xi \in [a,b]\)</span> 使得</dd></dl><p><span class="math display">\[\int _ a ^ b f \cdot g \mathrm dx = g(a) \int _ a ^ \xi f + g(b) \int _\xi ^ b f\]</span></p><p>当然还有更多的积分换元公式，不在这里继续讨论，因为我们有更加重要的内容需要引入：</p><h2 id="lp空间">L<sup>p</sup>空间</h2><h3 id="定义和基本性质">定义和基本性质</h3><p>引入 <span class="math inline">\(L^p\)</span>空间的很大的原因是积分变换（例如傅立叶等）。</p><dl><dt>Lp 空间</dt><dd>设 <span class="math inline">\(f(x)\)</span> 是 <spanclass="math inline">\(E\subseteq \mathbb R ^ n\)</span> 上的可测函数，记</dd></dl><p><span class="math display">\[\|f\|_p = \left(\int _E |f(x)|^p\mathrm dx\right)^{1/p}\quad 0 &lt; p&lt;= \infty\]</span></p><p>用 <span class="math inline">\(L^p\)</span>来表示使得上式有限的函数全体，构成 <spanclass="math inline">\(L^p\)</span> 空间。</p><p>显然 Lp 空间是线性空间。</p><p>显然我们有两种方式定义这个空间：</p><ol type="1"><li>直接定义：<span class="math inline">\(L^\infty\)</span>表示本性有界（<span class="math inline">\(\exists M, |f(x) | \le M,\quad a.e.\)</span>）</li><li>极限定义：<span class="math inline">\(L^\infty = \lim_{p\rightarrow\infty} L^p\)</span></li></ol><p>这两个定义是等价的</p><p>另一方面，我们要研究两个线性空间之间的关系，两个范数之间的关系：</p><dl><dt>Holder 不等式</dt><dd>设 <span class="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span> 是共轭指标（<spanclass="math inline">\(p^-1 + q ^ -1 = 2, p, q &gt; 1\)</span>，另有<span class="math inline">\(f\in L^p, g\in L^q\)</span>，那么：</dd></dl><p><span class="math display">\[\|f\cdot g\|_1 = \| f \| _p \cdot \| g \| _ q\quad 1\le p \le \infty\]</span></p><blockquote><p>上述定理的另一方面也成立，即反 Holder 不等式</p></blockquote><dl><dt>Minkowski 不等式</dt><dd>设 <span class="math inline">\(f,g \in L ^ p\)</span>，那么：</dd></dl><p><span class="math display">\[\|f + g\| _ p \le \| f \| _ p + \| g \| _ p\]</span></p><p><span class="math inline">\(p=2\)</span> 即三角不等式。</p><p>借助以上不等关系，我们来研究 <span class="math inline">\(L^p\)</span>空间的结构！</p><h3 id="lp-空间的结构">Lp 空间的结构</h3><h4 id="完备空间">完备空间</h4><p>定义 <span class="math inline">\(d(f, g) = \| f - g\| _p\)</span>，那么 <span class="math inline">\(\left(L^p(E),d\right)\)</span> 是一个距离空间。</p><dl><dt>依 Lp 收敛</dt><dd>设 <span class="math inline">\(\{f_k\}\in L^p\)</span> 若存在 <spanclass="math inline">\(f\in L^p\)</span> 使得</dd></dl><p><span class="math display">\[\lim _ {k\rightarrow\infty} d(f_k, f) = \lim_{k\rightarrow \infty} \| f_k - f \|_ p = 0\]</span></p><p>则称 <span class="math inline">\(f_k\)</span> 依 <spanclass="math inline">\(L^p(E)\)</span> 意义收敛于 <spanclass="math inline">\(f\)</span>。</p><p>关于上述极限：</p><ol type="1"><li>极限函数在几乎处处相等的意义下唯一</li><li>保范数性：极限函数的范数等于范数列的极限</li></ol><dl><dt>完备距离空间</dt><dd>若 <span class="math inline">\(\forall f_k\)</span> 是依 <spanclass="math inline">\(L^p\)</span> 收敛列，且 <spanclass="math inline">\(f_k \rightarrow f\)</span>，那么 <spanclass="math inline">\(f\in L^p\)</span>，则称 <spanclass="math inline">\(L^p\)</span> 是完备距离空间。</dd><dt>Theo</dt><dd><span class="math inline">\(L^p, p &gt; 1\)</span> 都是完备的</dd></dl><h4 id="可分空间">可分空间</h4><dl><dt>可分</dt><dd>设 <span class="math inline">\(\tau\)</span> 是 <spanclass="math inline">\(L^p\)</span> 的子集，若 <spanclass="math inline">\(\forall f\in L^p\)</span> 存在 <spanclass="math inline">\(\{g_k\}\in \tau\)</span>，使得 <spanclass="math inline">\(g_k\rightarrow f\quad L^p\)</span>，那么称 <spanclass="math inline">\(\tau\)</span> 在 <spanclass="math inline">\(L^p\)</span> 中稠密。如果 <spanclass="math inline">\(\tau\)</span> 可数，那么 <spanclass="math inline">\(L^p\)</span> 可分。</dd></dl><p>对于 <span class="math inline">\(p\ge 1\)</span>的情况，我们也有：</p><dl><dt>Theo</dt><dd>$1p &lt; +<span class="math inline">\(时，\)</span> L^p$ 可分</dd></dl><p>我们考虑用一个 Lp 空间来描述另一个 Lp 空间：</p><dl><dt>Theo</dt><dd>设 $1p &lt; , 1r <span class="math inline">\(那么\)</span> L^p L^r <spanclass="math inline">\(在\)</span> L^p$ 中稠密</dd></dl><h3 id="l2-内积空间">L2 内积空间</h3><p>我们希望不仅仅得到距离，我们还希望得到内积，这要求对于两个函数位置都线性，那么两个函数的次数都必须为1，从而 <span class="math inline">\(p=2\)</span></p><h4 id="内积和正交系">内积和正交系</h4><dl><dt>L2 内积</dt><dd>令</dd></dl><p><span class="math display">\[\langle f, g \rangle =\int_E f(x) g(x) \mathrm dx\]</span></p><p>为 <span class="math inline">\(L^2\)</span>空间上的内积（对称正定双线性函数）。</p><p>不难证明，该内积对于极限过程可交换。</p><p>有了内积的概念，我们试图在 <span class="math inline">\(L^2\)</span>这个线性空间中找标准正交基，来分解所有的函数。</p><dl><dt>Theo</dt><dd><span class="math inline">\(L^2\)</span> 中的所有正交系都是可数的。</dd></dl><h4 id="广义-fourier-级数">广义 Fourier 级数</h4><p>从线性代数的知识我们可以知道，广义上说，给定：</p><ol type="1"><li>内积</li><li>标准正交基</li><li>向量</li></ol><p>我们可以将向量分解到标准正交基上：</p><p><span class="math display">\[c_i = \langle e_i, f\rangle\quad f \sim \sum_{i = 1} ^ \infty c_i e_i\]</span></p><p>显然，我们还希望有更好的性质，例如我们不希望用 <spanclass="math inline">\(\sim\)</span> 符号（因为这里并不能直接相等）</p><dl><dt>Theo</dt><dd>对于标准正交基 <span class="math inline">\(\{\varphi_i\}\)</span>，<spanclass="math inline">\(f\in L^2\)</span>，取定 <spanclass="math inline">\(k\)</span>，作</dd></dl><p><span class="math display">\[f_k (x) = \sum_{i = 1}^ k a_i \varphi _ i\]</span></p><p>则当 <span class="math inline">\(a_i = c_i\)</span> 时，<spanclass="math inline">\(\|f-f_k\|_2\)</span> 取最小值</p><blockquote><p>利用标准正交基来证明</p></blockquote><p>一般情况下，帕斯瓦尔定理不成立，但我们仍有如下的不等式：</p><dl><dt>Bessel 不等式</dt><dd>设 <span class="math inline">\(\varphi_k\)</span> 是 <spanclass="math inline">\(L^2\)</span> 中的正交基，<spanclass="math inline">\(c_i\)</span> 是函数 <spanclass="math inline">\(f\)</span> 的 Fourier 系数，那么：</dd></dl><p><span class="math display">\[\sum _ {k = 1} ^ \infty c_k ^ 2 \le \|f_k\|^2\]</span></p><p>如果我们对于一个函数进行 Fourier分解，我们考虑是否能够复原这一个函数，下面的定理说明函数的 Fourier系数一定能够对应 L2 空间中的一个函数。</p><dl><dt>Riesz-Fisher</dt><dd>设 <span class="math inline">\(\varphi_k\)</span> 是标准正交基，若 <spanclass="math inline">\(c_k\)</span> 是 Fourier 系数且 <spanclass="math inline">\(\sum_{k =1} ^ \infty c_k^2&lt;+\infty\)</span>，存在</dd></dl><p><span class="math display">\[g\in L^2\quad \langle g, \varphi_k\rangle = c_k, k = 1, 2, ....\]</span></p><p>上面还只是考察了正交系（L2的子集），但我们并不知道这个正交基张成的空间的正交补空间的情况（即是否有一个函数不能用这个正交系表出）因此我们定义：</p><dl><dt>完全正交系</dt><dd>我们称一个正交系是完全的，当 <span class="math inline">\(L^2\)</span>中不存在任何的非零元和任一 <spanclass="math inline">\(\varphi_k\)</span> 正交。</dd><dt>Theo</dt><dd>三角函数系是完全正交系</dd></dl><p>正如之前提到的，完全正交系的补空间是零。不难理解：</p><dl><dt>Theo</dt><dd>设 <span class="math inline">\(\varphi_k\)</span> 是标准完全正交系，那么</dd></dl><p><span class="math display">\[\forall f\in L ^ 2\quad \lim_{k \rightarrow \infty} \| f - \sum_{i = 1}^k c_i \varphi_i \| _ 2 = 0\]</span></p><h3 id="lp-中的范数公式">Lp 中的范数公式</h3><p>我们在这里考虑一些 Lp中的范数不等式，来帮助我们在一些问题中进行放缩。</p><dl><dt>Theo</dt><dd>若 <span class="math inline">\(f\in L ^ p\)</span>，且 $1p &lt; <spanclass="math inline">\(，那么存在\)</span> gL ^{p’}<spanclass="math inline">\(，且\)</span>| g| _ {p’} = 1$ 使得，</dd></dl><p><span class="math display">\[\|f\|_p = \int _ E f(x) g(x) \mathrm dx\]</span></p><p>当然上式也可以推广到 <spanclass="math inline">\(L^\infty\)</span>：</p><p><span class="math display">\[\| f \| _ \infty = \sup _{\| g \| = 1}\{ | \int _ E f(x) g( x) \mathrmdx\}\]</span></p><p>最后我们研究 Minkowski 不等式的推广</p><dl><dt>广义 Minkowski</dt><dd>设 <span class="math inline">\(f(x, y)\)</span> 可测，若对于几乎处处的<span class="math inline">\(y\in \mathbb R ^ n\)</span> 有</dd></dl><p><span class="math display">\[f(x, y ) \in L ^p\quad \int _{\mathbb R^n}\left[\int _{\mathbb R ^n}|f(x, y) |^p  \mathrm dx \right] ^{1/p} \mathrm dy = M &lt; \infty\]</span></p><p>那么</p><p><span class="math display">\[\int _{\mathbb R^n}\left[\int _{\mathbb R ^ n}|f(x, y) |^p  \mathrm dy\right] ^{1/p} \mathrm dx\le \int _{\mathbb R^n}\left[\int _{\mathbb R ^n}|f(x, y) |^p  \mathrm dx \right] ^{1/p} \mathrm dy\]</span></p><p><span class="math display">\[\int _{\mathbb R^n}\left[\int _{\mathbb R ^ n}|f(x, y) |^p  \mathrm dy\right] ^{1/p} \mathrm dx\le \int _{\mathbb R^n}\left[\int _{\mathbb R ^n}|f(x, y) |^p  \mathrm dx \right] ^{1/p} \mathrm dy\]</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Test: An overview of all Markdown elements</title>
      <link href="/2016/11/01/all-elements/"/>
      <url>/2016/11/01/all-elements/</url>
      
        <content type="html"><![CDATA[<p>This post gives an overview of all Markdown elements and how they arerendered by this theme. <span id="more"></span></p><ul><li><a href="#block-elements">Block Elements</a><ul><li><a href="#paragraphs-and-line-breaks">Paragraphs and Line Breaks</a><ul><li><a href="#paragraphs">Paragraphs</a></li><li><a href="#line-breaks">Line Breaks</a></li></ul></li><li><a href="#headers">Headers</a><ul><li><a href="#setext">Setext</a></li><li><a href="#atx">atx</a></li></ul></li><li><a href="#blockquotes">Blockquotes</a></li><li><a href="#lists">Lists</a><ul><li><a href="#unordered">Unordered</a></li><li><a href="#ordered">Ordered</a></li><li><a href="#indented">Indented</a><ul><li><a href="#blockquote">Blockquote</a></li><li><a href="#code-block">Code Block</a></li><li><a href="#nested-list">Nested List</a></li></ul></li></ul></li><li><a href="#code-blocks">Code Blocks</a><ul><li><a href="#fenced-code-blocks">Fenced Code Blocks</a></li><li><a href="#syntax-highlighting">Syntax Highlighting</a></li></ul></li><li><a href="#horizontal-rules">Horizontal Rules</a></li><li><a href="#table">Table</a></li></ul></li><li><a href="#span-elements">Span Elements</a><ul><li><a href="#links">Links</a><ul><li><a href="#inline">Inline</a></li><li><a href="#reference">Reference</a></li></ul></li><li><a href="#emphasis">Emphasis</a></li><li><a href="#code">Code</a></li><li><a href="#images">Images</a><ul><li><a href="#inline-1">Inline</a></li><li><a href="#reference-1">Reference</a></li></ul></li><li><a href="#strikethrough">Strikethrough</a></li></ul></li><li><a href="#miscellaneous">Miscellaneous</a><ul><li><a href="#automatic-links">Automatic Links</a></li><li><a href="#backslash-escapes">Backslash Escapes</a></li></ul></li><li><a href="#inline-html">Inline HTML</a></li></ul><!-- more --><h2 id="block-elements">Block Elements</h2><h3 id="paragraphs-and-line-breaks">Paragraphs and Line Breaks</h3><h4 id="paragraphs">Paragraphs</h4><p>HTML Tag: <code>&lt;p&gt;</code></p><p>One or more blank lines. (A blank line is a line containing nothingbut <strong>spaces</strong> or <strong>tabs</strong> is consideredblank.)</p><p>Code:</p><pre><code>This will beinline.This is second paragraph.</code></pre><p>Preview: *** This will be inline.</p><p>This is second paragraph. *** #### Line Breaks HTML Tag:<code>&lt;br /&gt;</code></p><p>End a line with <strong>two or more spaces</strong>.</p><p>Code:</p><pre><code>This will be notinline.</code></pre><p>Preview: <strong><em> This will be not inline. </em></strong></p><h3 id="headers">Headers</h3><p>Markdown supports two styles of headers, Setext and atx. #### SetextHTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code></p><p>“Underlined” using <strong>equal signs (=)</strong> as<code>&lt;h1&gt;</code> and <strong>dashes (-)</strong> as<code>&lt;h2&gt;</code> in any number.</p><p>Code:</p><pre><code>This is an H1=============This is an H2-------------</code></pre><h4 id="atx">atx</h4><p>HTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>,<code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>,<code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code></p><p>Uses 1-6 <strong>hash characters (#)</strong> at the start of theline, corresponding to <code>&lt;h1&gt;</code> -<code>&lt;h6&gt;</code>.</p><p>Code:</p><pre><code># This is an H1## This is an H2###### This is an H6</code></pre><p>Optionally, you may “close” atx-style headers. The closing hashes<strong>don’t need to match</strong> the number of hashes used to openthe header.</p><p>Code:</p><pre><code># This is an H1 ### This is an H2 ##### This is an H3 ######</code></pre><h3 id="blockquotes">Blockquotes</h3><p>HTML Tag: <code>&lt;blockquote&gt;</code></p><p>Markdown uses email-style <strong>&gt;</strong> characters forblockquoting. It looks best if you hard wrap the text and put a &gt;before every line.</p><p>Code:</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.</code></pre><p>Preview: *** &gt; This is a blockquote with two paragraphs. Loremipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit miposuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus.</p><blockquote><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</p></blockquote><hr /><p>Markdown allows you to be lazy and only put the &gt; before the firstline of a hard-wrapped paragraph.</p><p>Code:</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</code></pre><p>Preview: *** &gt; This is a blockquote with two paragraphs. Loremipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit miposuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus.</p><blockquote><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</p></blockquote><hr /><p>Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) byadding additional levels of &gt;.</p><p>Code:</p><pre><code>&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><p>Preview: *** &gt; This is the first level of quoting.</p><blockquote><blockquote><p>This is nested blockquote.</p></blockquote></blockquote><blockquote><p>Back to the first level.</p></blockquote><hr /><p>Blockquotes can contain other Markdown elements, including headers,lists, and code blocks.</p><p>Code:</p><pre><code>&gt; ## This is a header.&gt;&gt; 1.   This is the first list item.&gt; 2.   This is the second list item.&gt;&gt; Here&#39;s some example code:&gt;&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><h3 id="lists">Lists</h3><p>Markdown supports ordered (numbered) and unordered (bulleted) lists.#### Unordered HTML Tag: <code>&lt;ul&gt;</code></p><p>Unordered lists use **asterisks (*)<strong>, </strong>pluses(+)<strong>, and </strong>hyphens (-)**.</p><p>Code:</p><pre><code>*   Red*   Green*   Blue</code></pre><p>Preview: **<em> </em> Red * Green * Blue</p><hr /><p>is equivalent to:</p><p>Code:</p><pre><code>+   Red+   Green+   Blue</code></pre><p>and:</p><p>Code:</p><pre><code>-   Red-   Green-   Blue</code></pre><h4 id="ordered">Ordered</h4><p>HTML Tag: <code>&lt;ol&gt;</code></p><p>Ordered lists use numbers followed by periods:</p><p>Code:</p><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><p>Preview: *** 1. Bird 2. McHale 3. Parish</p><hr /><p>It’s possible to trigger an ordered list by accident, by writingsomething like this:</p><p>Code:</p><pre><code>1986. What a great season.</code></pre><p>Preview: *** 1986. What a great season.</p><hr /><p>You can <strong>backslash-escape (\)</strong> the period:</p><p>Code:</p><pre><code>1986\. What a great season.</code></pre><p>Preview: *** 1986. What a great season.</p><hr /><h4 id="indented">Indented</h4><h5 id="blockquote">Blockquote</h5><p>To put a blockquote within a list item, the blockquote’s &gt;delimiters need to be indented:</p><p>Code:</p><pre><code>*   A list item with a blockquote:    &gt; This is a blockquote    &gt; inside a list item.</code></pre><p>Preview: **<em> </em> A list item with a blockquote:</p><pre><code>&gt; This is a blockquote&gt; inside a list item.</code></pre><hr /><h5 id="code-block">Code Block</h5><p>To put a code block within a list item, the code block needs to beindented twice — <strong>8 spaces</strong> or <strong>twotabs</strong>:</p><p>Code:</p><pre><code>*   A list item with a code block:        &lt;code goes here&gt;</code></pre><p>Preview: **<em> </em> A list item with a code block:</p><pre><code>    &lt;code goes here&gt;</code></pre><hr /><h5 id="nested-list">Nested List</h5><p>Code:</p><pre><code>* A  * A1  * A2* B* C</code></pre><p>Preview: **<em> </em> A * A1 * A2 * B * C</p><hr /><h3 id="code-blocks">Code Blocks</h3><p>HTML Tag: <code>&lt;pre&gt;</code></p><p>Indent every line of the block by at least <strong>4 spaces</strong>or <strong>1 tab</strong>.</p><p>Code:</p><pre><code>This is a normal paragraph:    This is a code block.</code></pre><p>Preview: *** This is a normal paragraph:</p><pre><code>This is a code block.</code></pre><hr /><p>A code block continues until it reaches a line that is not indented(or the end of the article).</p><p>Within a code block, <strong><em>ampersands (&amp;)</em></strong> andangle <strong>brackets (&lt; and &gt;)</strong> are automaticallyconverted into HTML entities.</p><p>Code:</p><pre><code>    &lt;div class=&quot;footer&quot;&gt;        &amp;copy; 2004 Foo Corporation    &lt;/div&gt;</code></pre>Preview: ***<div class="footer"><pre><code>    &amp;copy; 2004 Foo Corporation&lt;/div&gt;</code></pre><hr /><p>Following sections Fenced Code Blocks and Syntax Highlighting areextensions, you can use the other way to write the code block. ####Fenced Code Blocks Just wrap your code in <code>```</code> (as shownbelow) and you won’t need to indent it by four spaces.</p><p>Code:</p><pre><code>Here&#39;s an example:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  console.log(&quot;notice the blank line before this function?&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>Preview: *** Here’s an example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  console.log(&quot;notice the blank line before this function?&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="syntax-highlighting">Syntax Highlighting</h4><p>In your fenced block, add an optional language identifier and we’llrun it through syntax highlighting (<ahref="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">SupportLanguages</a>).</p><p>Code:</p><pre><code><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;redcarpet&#x27;</span></span><br><span class="line">markdown = <span class="title class_">Redcarpet</span>.new(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">puts markdown.to_html</span><br></pre></td></tr></table></figure></code></pre><p>Preview: <strong><em> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;redcarpet&#x27;</span></span><br><span class="line">markdown = <span class="title class_">Redcarpet</span>.new(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">puts markdown.to_html</span><br></pre></td></tr></table></figure> </em></strong> ### HorizontalRules HTML Tag: <code>&lt;hr /&gt;</code> Places **three or more hyphens(-), asterisks (*), or underscores (_)** on a line by themselves. Youmay use spaces between the hyphens or asterisks.</p><p>Code:</p><pre><code>* * *********- - ----------------------------------------___</code></pre><p>Preview: <strong><em> </em> * <em> </em></strong> ***** - - - ___ ***### Table HTML Tag: <code>&lt;table&gt;</code></p><p>It’s an extension.</p><p>Separates column by <strong>pipe (|)</strong> and header by<strong>dashes (-)</strong>, and uses <strong>colon (:)</strong> foralignment.</p><p>The outer <strong>pipes (|)</strong> and alignment are optional.There are <strong>3 delimiters</strong> each cell at least forseparating header.</p><p>Code: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">| Left | Center | Right |</span><br><span class="line">|:-----|:------:|------:|</span><br><span class="line">|aaa   |bbb     |ccc    |</span><br><span class="line">|ddd   |eee     |fff    |</span><br><span class="line"></span><br><span class="line"> A | B</span><br><span class="line">---|---</span><br><span class="line">123|456</span><br><span class="line"></span><br><span class="line">A |B</span><br><span class="line">--|--</span><br><span class="line">12|45</span><br></pre></td></tr></table></figure> Preview: *** | Left | Center | Right ||:—–|:——:|——:| |aaa |bbb |ccc | |ddd |eee |fff |</p><table><thead><tr class="header"><th>A</th><th>B</th></tr></thead><tbody><tr class="odd"><td>123</td><td>456</td></tr></tbody></table><table><thead><tr class="header"><th>A</th><th>B</th></tr></thead><tbody><tr class="odd"><td>12</td><td>45</td></tr></tbody></table><hr /><h2 id="span-elements">Span Elements</h2><h3 id="links">Links</h3><p>HTML Tag: <code>&lt;a&gt;</code></p><p>Markdown supports two style of links: inline and reference.</p><h4 id="inline">Inline</h4><p>Inline link format like this:<code>[Link Text](URL "Title")</code></p><p>Title is optional.</p><p>Code:</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><p>Preview: *** This is <a href="http://example.com/" title="Title">anexample</a> inline link.</p><p><a href="http://example.net/">This link</a> has no title attribute.*** If you’re referring to a local resource on the same server, you canuse relative paths:</p><p>Code:</p><pre><code>See my [About](/cactus-dark/about/) page for details.</code></pre><p>Preview: <strong><em> See my <a href="/cactus-dark/about/">About</a>page for details. </em></strong> #### Reference You could predefine linkreferences. Format like this: <code>[id]: URL "Title"</code></p><p>Title is also optional. And the you refer the link, format like this:<code>[Link Text][id]</code></p><p>Code:</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;This is [an example][id] reference-style link.</code></pre><p>Preview: <strong><em> [id]: http://example.com/ “Optional Title Here”This is [an example][id] reference-style link. </em></strong> Thatis:</p><ul><li>Square brackets containing the link identifier (<strong>not casesensitive</strong>, optionally indented from the left margin using up tothree spaces);</li><li>followed by a colon;</li><li>followed by one or more spaces (or tabs);</li><li>followed by the URL for the link;</li><li>The link URL may, optionally, be surrounded by angle brackets.</li><li>optionally followed by a title attribute for the link, enclosed indouble or single quotes, or enclosed in parentheses.</li></ul><p>The following three link definitions are equivalent:</p><p>Code:</p><pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;[foo]: http://example.com/  &#39;Optional Title Here&#39;[foo]: http://example.com/  (Optional Title Here)[foo]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</code></pre><p>Uses an empty set of square brackets, the link text itself is used asthe name.</p><p>Code:</p><pre><code>[Google]: http://google.com/[Google][]</code></pre><p>Preview: <strong><em> [Google]: http://google.com/ [Google][]</em></strong> ### Emphasis HTML Tags: <code>&lt;em&gt;</code>,<code>&lt;strong&gt;</code></p><p>Markdown treats **asterisks (*)<strong> and </strong>underscores(_)** as indicators of emphasis. <strong>One delimiter</strong> will be<code>&lt;em&gt;</code>; **double delimiters* will be<code>&lt;strong&gt;</code>.</p><p>Code:</p><pre><code>*single asterisks*_single underscores_**double asterisks**__double underscores__</code></pre><p>Preview: **<em> </em>single asterisks*</p><p><em>single underscores</em></p><p><strong>double asterisks</strong></p><p><strong>double underscores</strong> **<em> But if you surround an</em> or _ with spaces, it’ll be treated as a literal asterisk orunderscore.</p><p>You can backslash escape it:</p><p>Code:</p><pre><code>\*this text is surrounded by literal asterisks\*</code></pre><p>Preview: <strong><em> *this text is surrounded by literal asterisks*</em></strong> ### Code HTML Tag: <code>&lt;code&gt;</code></p><p>Wraps it with <strong>backtick quotes (`)</strong>.</p><p>Code:</p><pre><code>Use the `printf()` function.</code></pre><p>Preview: <strong><em> Use the <code>printf()</code> function.</em></strong> To include a literal backtick character within a codespan, you can use <strong>multiple backticks</strong> as the opening andclosing delimiters:</p><p>Code:</p><pre><code>``There is a literal backtick (`) here.``</code></pre><p>Preview: <strong><em><code>There is a literal backtick (`) here.</code> </em></strong> Thebacktick delimiters surrounding a code span may include spaces — oneafter the opening, one before the closing. This allows you to placeliteral backtick characters at the beginning or end of a code span:</p><p>Code:</p><pre><code>A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``</code></pre><p>Preview: *** A single backtick in a code span: <code>`</code></p><p>A backtick-delimited string in a code span: <code>`foo`</code> ***### Images HTML Tag: <code>&lt;img /&gt;</code></p><p>Markdown uses an image syntax that is intended to resemble the syntaxfor links, allowing for two styles: inline and reference. ####Inline</p><p>Inline image syntax looks like this:<code>![Alt text](URL "Title")</code></p><p>Title is optional.</p><p>Code:</p><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre><p>Preview: *** <img src="/cactus-dark/assets/wallpaper-878514.jpg"alt="Alt text" /></p><p><img src="/cactus-dark/assets/cactus.png" title="Optional title"alt="Alt text" /> *** That is:</p><ul><li>An exclamation mark: !;</li><li>followed by a set of square brackets, containing the alt attributetext for the image;</li><li>followed by a set of parentheses, containing the URL or path to theimage, and an optional title attribute enclosed in double or singlequotes.</li></ul><h4 id="reference">Reference</h4><p>Reference-style image syntax looks like this:<code>![Alt text][id]</code></p><p>Code:</p><pre><code>[img id]: url/to/image  &quot;Optional title attribute&quot;![Alt text][img id]</code></pre><p>Preview: <strong><em> [img id]:https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Markdown-mark.svg/208px-Markdown-mark.svg.png“Optional title attribute” ![Alt text][img id] </em></strong> ###Strikethrough HTML Tag: <code>&lt;del&gt;</code></p><p>It’s an extension.</p><p>GFM adds syntax to strikethrough text.</p><p>Code: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~Mistaken text.~~</span><br></pre></td></tr></table></figure> Preview: <strong><em> <del>Mistaken text.</del></em></strong> ## Miscellaneous ### Automatic Links Markdown supports ashortcut style for creating “automatic” links for URLs and emailaddresses: simply surround the URL or email address with anglebrackets.</p><p>Code:</p><pre><code>&lt;http://example.com/&gt;&lt;address@example.com&gt;</code></pre><p>Preview: *** <a href="http://example.com/"class="uri">http://example.com/</a></p><p><a href="mailto:address@example.com"class="email">address@example.com</a> *** GFM will autolink standardURLs.</p><p>Code: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/emn178/markdown</span><br></pre></td></tr></table></figure> Preview: <strong><em>https://github.com/emn178/markdown </em></strong></p><h3 id="backslash-escapes">Backslash Escapes</h3><p>Markdown allows you to use backslash escapes to generate literalcharacters which would otherwise have special meaning in Markdown’sformatting syntax.</p><p>Code:</p><pre><code>\*literal asterisks\*</code></pre><p>Preview: <strong><em> *literal asterisks* </em></strong> Markdownprovides backslash escapes for the following characters:</p><p>Code:</p><pre><code>\   backslash`   backtick*   asterisk_   underscore&#123;&#125;  curly braces[]  square brackets()  parentheses#   hash mark+   plus sign-   minus sign (hyphen).   dot!   exclamation mark</code></pre><h2 id="inline-html">Inline HTML</h2><p>For any markup that is not covered by Markdown’s syntax, you simplyuse HTML itself. There’s no need to preface it or delimit it to indicatethat you’re switching from Markdown to HTML; you just use the tags.</p><p>Code:</p><pre><code>This is a regular paragraph.&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;Foo&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph.</code></pre><p>Preview: *** This is a regular paragraph.</p><table><tr><td>Foo</td></tr></table><p>This is another regular paragraph. *<strong> Note that Markdownformatting syntax is </strong>not processed within block-level HTMLtags**.</p><p>Unlike block-level HTML tags, Markdown syntax is <strong>processedwithin span-level tags</strong>.</p><p>Code:</p><pre><code>&lt;span&gt;**Work**&lt;/span&gt;&lt;div&gt;    **No Work**&lt;/div&gt;</code></pre><p>Preview: *** <span><strong>Work</strong></span></p><div><p><strong>No Work</strong></p></div><hr />]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
